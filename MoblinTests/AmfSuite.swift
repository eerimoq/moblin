import AVFoundation
@testable import Moblin
import Testing

struct AmfSuite {
    @Test
    func number() async throws {
        let value = 1.0
        let serializer = Amf0Encoder()
        serializer.encode(.number(value))
        let encoded = serializer.data
        #expect(encoded == Data([0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]))
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        #expect(decoded == .number(value))
    }

    struct BoolParameters {
        let value: Bool
        let encoded: Data
    }

    @Test(arguments: [
        BoolParameters(value: true, encoded: Data([1, 1])),
        BoolParameters(value: false, encoded: Data([1, 0])),
    ])
    func bool(_ parameters: BoolParameters) async throws {
        let serializer = Amf0Encoder()
        serializer.encode(.bool(parameters.value))
        let encoded = serializer.data
        #expect(encoded == parameters.encoded)
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        #expect(decoded == .bool(parameters.value))
    }

    @Test
    func string() async throws {
        let value = "1234"
        let serializer = Amf0Encoder()
        serializer.encode(.string(value))
        let encoded = serializer.data
        #expect(encoded == Data([0x02, 0x00, 0x04, 0x31, 0x32, 0x33, 0x34]))
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        #expect(decoded == .string(value))
    }

    @Test
    func object() async throws {
        let value: AsObject = ["1": .string("2")]
        let serializer = Amf0Encoder()
        serializer.encode(.object(value))
        let encoded = serializer.data
        #expect(encoded == Data([0x03, 0x00, 0x01, 0x31, 0x02, 0x00, 0x01, 0x32, 0x00, 0x00, 0x09]))
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        #expect(decoded == .object(value))
    }

    @Test
    func typedObject() async throws {
        let encoded = Data([
            0x10,
            // Type "21",
            0x00, 0x02, 0x32, 0x31,
            // Key "1".
            0x00, 0x01, 0x31,
            // Value "2".
            0x02, 0x00, 0x01, 0x32,
            // Empty string and object end.
            0x00, 0x00, 0x09,
        ])
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        #expect(decoded == .typedObject(AsTypedObject(type: "21", value: ["1": .string("2")])))
    }

    @Test
    func null() async throws {
        let serializer = Amf0Encoder()
        serializer.encode(.null)
        let encoded = serializer.data
        #expect(encoded == Data([0x05]))
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        #expect(decoded == .null)
    }

    @Test
    func undefined() async throws {
        let encoded = Data([0x06])
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        #expect(decoded == .undefined)
    }

    @Test
    func ecmaArray() async throws {
        let encoded = Data([
            0x08,
            // 2 elements.
            0x00, 0x00, 0x00, 0x02,
            // Element key "foo".
            0x00, 0x03, 0x66, 0x6F, 0x6F,
            // Element value true.
            0x01, 0x01,
            // Element key "bar".
            0x00, 0x03, 0x62, 0x61, 0x72,
            // Element value "fie".
            0x02, 0x00, 0x03, 0x66, 0x69, 0x65,
            // Empty end key.
            0x00, 0x00,
            // End marker.
            0x09,
        ])
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        guard case let .ecmaArray(decoded) = decoded else {
            throw "error"
        }
        #expect(try decoded.get(key: "foo") == .bool(true))
        #expect(try decoded.get(key: "bar") == .string("fie"))
    }

    @Test
    func strictArray() async throws {
        let encoded = Data([
            0x0A,
            // 2 elements.
            0x00, 0x00, 0x00, 0x02,
            // Element true.
            0x01, 0x01,
            // Element "fie".
            0x02, 0x00, 0x03, 0x66, 0x69, 0x65,
        ])
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        guard case let .strictArray(decoded) = decoded else {
            throw "error"
        }
        #expect(decoded.count == 2)
        #expect(decoded[0] == .bool(true))
        #expect(decoded[1] == .string("fie"))
    }

    @Test
    func date() async throws {
        let value = Date(timeIntervalSince1970: 15)
        let serializer = Amf0Encoder()
        serializer.encode(.date(value))
        let encoded = serializer.data
        #expect(encoded == Data([0x0B, 0x40, 0xCD, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]))
        let decoder = Amf0Decoder(data: encoded)
        let decoded = try decoder.decode()
        #expect(decoded == .date(value))
    }

    @Test
    func decodeRtmpFoo() async throws {
        let data = Data([
            0x02, 0x00, 0x07, 0x5F, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74,
            0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
            0x00, 0x06, 0x66, 0x6D, 0x73, 0x56, 0x65, 0x72, 0x02, 0x00,
            0x0D, 0x46, 0x4D, 0x53, 0x2F, 0x33, 0x2C, 0x35, 0x2C, 0x33,
            0x2C, 0x38, 0x38, 0x38, 0x00, 0x0C, 0x63, 0x61, 0x70, 0x61,
            0x62, 0x69, 0x6C, 0x69, 0x74, 0x69, 0x65, 0x73, 0x00, 0x40,
            0x5F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6D,
            0x6F, 0x64, 0x65, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x09, 0x03, 0x00, 0x05, 0x6C, 0x65,
            0x76, 0x65, 0x6C, 0x02, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74,
            0x75, 0x73, 0x00, 0x04, 0x63, 0x6F, 0x64, 0x65, 0x02, 0x00,
            0x1D, 0x4E, 0x65, 0x74, 0x43, 0x6F, 0x6E, 0x6E, 0x65, 0x63,
            0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x43, 0x6F, 0x6E, 0x6E, 0x65,
            0x63, 0x74, 0x2E, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73,
            0x00, 0x0B, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
            0x69, 0x6F, 0x6E, 0x02, 0x00, 0x14, 0x43, 0x6F, 0x6E, 0x6E,
            0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x75, 0x63,
            0x63, 0x65, 0x65, 0x64, 0x65, 0x64, 0x00, 0x0E, 0x6F, 0x62,
            0x6A, 0x65, 0x63, 0x74, 0x45, 0x6E, 0x63, 0x6F, 0x64, 0x69,
            0x6E, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x04, 0x64, 0x61, 0x74, 0x61, 0x08, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F,
            0x6E, 0x02, 0x00, 0x09, 0x33, 0x2C, 0x35, 0x2C, 0x33, 0x2C,
            0x38, 0x38, 0x38, 0x00, 0x07, 0x73, 0x72, 0x73, 0x5F, 0x73,
            0x69, 0x67, 0x02, 0x00, 0x03, 0x53, 0x52, 0x53, 0x00, 0x0A,
            0x73, 0x72, 0x73, 0x5F, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
            0x02, 0x00, 0x10, 0x53, 0x52, 0x53, 0x2F, 0x35, 0x2E, 0x30,
            0x2E, 0x32, 0x30, 0x38, 0x28, 0x42, 0x65, 0x65, 0x29, 0x00,
            0x0B, 0x73, 0x72, 0x73, 0x5F, 0x6C, 0x69, 0x63, 0x65, 0x6E,
            0x73, 0x65, 0x02, 0x00, 0x03, 0x4D, 0x49, 0x54, 0x00, 0x07,
            0x73, 0x72, 0x73, 0x5F, 0x75, 0x72, 0x6C, 0x02, 0x00, 0x1C,
            0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x67, 0x69,
            0x74, 0x68, 0x75, 0x62, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x6F,
            0x73, 0x73, 0x72, 0x73, 0x2F, 0x73, 0x72, 0x73, 0x00, 0x0B,
            0x73, 0x72, 0x73, 0x5F, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F,
            0x6E, 0x02, 0x00, 0x07, 0x35, 0x2E, 0x30, 0x2E, 0x32, 0x30,
            0x38, 0x00, 0x0B, 0x73, 0x72, 0x73, 0x5F, 0x61, 0x75, 0x74,
            0x68, 0x6F, 0x72, 0x73, 0x02, 0x01, 0x34, 0x57, 0x69, 0x6E,
            0x6C, 0x69, 0x6E, 0x3C, 0x77, 0x69, 0x6E, 0x6C, 0x69, 0x6E,
            0x40, 0x76, 0x69, 0x70, 0x2E, 0x31, 0x32, 0x36, 0x2E, 0x63,
            0x6F, 0x6D, 0x3E, 0x20, 0x5A, 0x68, 0x61, 0x6F, 0x57, 0x65,
            0x6E, 0x6A, 0x69, 0x65, 0x3C, 0x7A, 0x68, 0x61, 0x6F, 0x77,
            0x65, 0x6E, 0x6A, 0x69, 0x65, 0x40, 0x74, 0x61, 0x6C, 0x2E,
            0x63, 0x6F, 0x6D, 0x3E, 0x20, 0x53, 0x68, 0x69, 0x57, 0x65,
            0x69, 0x3C, 0x73, 0x68, 0x69, 0x77, 0x65, 0x69, 0x30, 0x35,
            0x40, 0x6B, 0x75, 0x61, 0x69, 0x73, 0x68, 0x6F, 0x75, 0x2E,
            0x63, 0x6F, 0x6D, 0x3E, 0x20, 0x58, 0x69, 0x61, 0x6F, 0x5A,
            0x68, 0x69, 0x68, 0x6F, 0x6E, 0x67, 0x3C, 0x68, 0x6F, 0x6E,
            0x64, 0x61, 0x78, 0x69, 0x61, 0x6F, 0x40, 0x74, 0x65, 0x6E,
            0x63, 0x65, 0x6E, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x3E, 0x20,
            0x57, 0x75, 0x50, 0x65, 0x6E, 0x67, 0x71, 0x69, 0x61, 0x6E,
            0x67, 0x3C, 0x70, 0x65, 0x6E, 0x67, 0x71, 0x69, 0x61, 0x6E,
            0x67, 0x2E, 0x77, 0x70, 0x71, 0x40, 0x61, 0x6C, 0x69, 0x62,
            0x61, 0x62, 0x61, 0x2D, 0x69, 0x6E, 0x63, 0x2E, 0x63, 0x6F,
            0x6D, 0x3E, 0x20, 0x58, 0x69, 0x61, 0x4C, 0x69, 0x78, 0x69,
            0x6E, 0x3C, 0x78, 0x69, 0x61, 0x6C, 0x69, 0x78, 0x69, 0x6E,
            0x40, 0x6B, 0x61, 0x6E, 0x7A, 0x68, 0x75, 0x6E, 0x2E, 0x63,
            0x6F, 0x6D, 0x3E, 0x20, 0x4C, 0x69, 0x50, 0x65, 0x6E, 0x67,
            0x3C, 0x6D, 0x6F, 0x7A, 0x68, 0x61, 0x6E, 0x2E, 0x6C, 0x70,
            0x40, 0x61, 0x6C, 0x69, 0x62, 0x61, 0x62, 0x61, 0x2D, 0x69,
            0x6E, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x3E, 0x20, 0x43, 0x68,
            0x65, 0x6E, 0x47, 0x75, 0x61, 0x6E, 0x67, 0x68, 0x75, 0x61,
            0x3C, 0x6A, 0x69, 0x6E, 0x78, 0x75, 0x65, 0x2E, 0x63, 0x67,
            0x68, 0x40, 0x61, 0x6C, 0x69, 0x62, 0x61, 0x62, 0x61, 0x2D,
            0x69, 0x6E, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x3E, 0x20, 0x43,
            0x68, 0x65, 0x6E, 0x48, 0x61, 0x69, 0x62, 0x6F, 0x3C, 0x6E,
            0x6D, 0x67, 0x63, 0x68, 0x65, 0x6E, 0x68, 0x61, 0x69, 0x62,
            0x6F, 0x40, 0x66, 0x6F, 0x78, 0x6D, 0x61, 0x69, 0x6C, 0x2E,
            0x63, 0x6F, 0x6D, 0x3E, 0x20, 0x00, 0x0D, 0x73, 0x72, 0x73,
            0x5F, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5F, 0x69, 0x70,
            0x02, 0x00, 0x0A, 0x31, 0x37, 0x32, 0x2E, 0x31, 0x37, 0x2E,
            0x30, 0x2E, 0x32, 0x00, 0x07, 0x73, 0x72, 0x73, 0x5F, 0x70,
            0x69, 0x64, 0x00, 0x40, 0x44, 0x80, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x06, 0x73, 0x72, 0x73, 0x5F, 0x69, 0x64, 0x02,
            0x00, 0x08, 0x38, 0x38, 0x30, 0x37, 0x37, 0x33, 0x32, 0x32,
            0x00, 0x00, 0x09, 0x00, 0x00, 0x09,
        ])
        let decoder = Amf0Decoder(data: data)
        #expect(try RtmpCommandName(rawValue: decoder.decodeString()) == .result)
        #expect(try decoder.decodeInt() == 1)
        #expect(try decoder.decodeObject() == [
            "fmsVer": .string("FMS/3,5,3,888"),
            "capabilities": .number(127),
            "mode": .number(1),
        ])
        #expect(try decoder.decode() == .object([
            "level": .string("status"),
            "code": .string("NetConnection.Connect.Success"),
            "description": .string("Connection succeeded"),
            "objectEncoding": .number(0),
            "data": .ecmaArray(AsEcmaArray([
                "version": .string("3,5,3,888"),
                "srs_sig": .string("SRS"),
                "srs_server": .string("SRS/5.0.208(Bee)"),
                "srs_license": .string("MIT"),
                "srs_url": .string("https://github.com/ossrs/srs"),
                "srs_version": .string("5.0.208"),
                "srs_authors": .string(
                    """
                    Winlin<winlin@vip.126.com> ZhaoWenjie<zhaowenjie@tal.com> \
                    ShiWei<shiwei05@kuaishou.com> XiaoZhihong<hondaxiao@tencent.com> \
                    WuPengqiang<pengqiang.wpq@alibaba-inc.com> XiaLixin<xialixin@kanzhun.com> \
                    LiPeng<mozhan.lp@alibaba-inc.com> ChenGuanghua<jinxue.cgh@alibaba-inc.com> \
                    ChenHaibo<nmgchenhaibo@foxmail.com>
                    """ + " "
                ),
                "srs_server_ip": .string("172.17.0.2"),
                "srs_pid": .number(41),
                "srs_id": .string("88077322"),
            ])),
        ]))
        #expect(decoder.bytesAvailable == 0)
    }
}
