// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: car_server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum CarServer_OperationStatus_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case operationstatusOk // = 0
  case rror // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .operationstatusOk
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .operationstatusOk
    case 1: self = .rror
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .operationstatusOk: return 0
    case .rror: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [CarServer_OperationStatus_E] = [
    .operationstatusOk,
    .rror,
  ]

}

struct CarServer_Action: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionMsg: CarServer_Action.OneOf_ActionMsg? = nil

  var vehicleAction: CarServer_VehicleAction {
    get {
      if case .vehicleAction(let v)? = actionMsg {return v}
      return CarServer_VehicleAction()
    }
    set {actionMsg = .vehicleAction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ActionMsg: Equatable, Sendable {
    case vehicleAction(CarServer_VehicleAction)

  }

  init() {}
}

struct CarServer_VehicleAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleActionMsg: CarServer_VehicleAction.OneOf_VehicleActionMsg? = nil

  var getVehicleData: CarServer_GetVehicleData {
    get {
      if case .getVehicleData(let v)? = vehicleActionMsg {return v}
      return CarServer_GetVehicleData()
    }
    set {vehicleActionMsg = .getVehicleData(newValue)}
  }

  var chargingSetLimitAction: CarServer_ChargingSetLimitAction {
    get {
      if case .chargingSetLimitAction(let v)? = vehicleActionMsg {return v}
      return CarServer_ChargingSetLimitAction()
    }
    set {vehicleActionMsg = .chargingSetLimitAction(newValue)}
  }

  var chargingStartStopAction: CarServer_ChargingStartStopAction {
    get {
      if case .chargingStartStopAction(let v)? = vehicleActionMsg {return v}
      return CarServer_ChargingStartStopAction()
    }
    set {vehicleActionMsg = .chargingStartStopAction(newValue)}
  }

  var drivingClearSpeedLimitPinAction: CarServer_DrivingClearSpeedLimitPinAction {
    get {
      if case .drivingClearSpeedLimitPinAction(let v)? = vehicleActionMsg {return v}
      return CarServer_DrivingClearSpeedLimitPinAction()
    }
    set {vehicleActionMsg = .drivingClearSpeedLimitPinAction(newValue)}
  }

  var drivingSetSpeedLimitAction: CarServer_DrivingSetSpeedLimitAction {
    get {
      if case .drivingSetSpeedLimitAction(let v)? = vehicleActionMsg {return v}
      return CarServer_DrivingSetSpeedLimitAction()
    }
    set {vehicleActionMsg = .drivingSetSpeedLimitAction(newValue)}
  }

  var drivingSpeedLimitAction: CarServer_DrivingSpeedLimitAction {
    get {
      if case .drivingSpeedLimitAction(let v)? = vehicleActionMsg {return v}
      return CarServer_DrivingSpeedLimitAction()
    }
    set {vehicleActionMsg = .drivingSpeedLimitAction(newValue)}
  }

  var hvacAutoAction: CarServer_HvacAutoAction {
    get {
      if case .hvacAutoAction(let v)? = vehicleActionMsg {return v}
      return CarServer_HvacAutoAction()
    }
    set {vehicleActionMsg = .hvacAutoAction(newValue)}
  }

  var hvacSetPreconditioningMaxAction: CarServer_HvacSetPreconditioningMaxAction {
    get {
      if case .hvacSetPreconditioningMaxAction(let v)? = vehicleActionMsg {return v}
      return CarServer_HvacSetPreconditioningMaxAction()
    }
    set {vehicleActionMsg = .hvacSetPreconditioningMaxAction(newValue)}
  }

  var hvacSteeringWheelHeaterAction: CarServer_HvacSteeringWheelHeaterAction {
    get {
      if case .hvacSteeringWheelHeaterAction(let v)? = vehicleActionMsg {return v}
      return CarServer_HvacSteeringWheelHeaterAction()
    }
    set {vehicleActionMsg = .hvacSteeringWheelHeaterAction(newValue)}
  }

  var hvacTemperatureAdjustmentAction: CarServer_HvacTemperatureAdjustmentAction {
    get {
      if case .hvacTemperatureAdjustmentAction(let v)? = vehicleActionMsg {return v}
      return CarServer_HvacTemperatureAdjustmentAction()
    }
    set {vehicleActionMsg = .hvacTemperatureAdjustmentAction(newValue)}
  }

  var mediaPlayAction: CarServer_MediaPlayAction {
    get {
      if case .mediaPlayAction(let v)? = vehicleActionMsg {return v}
      return CarServer_MediaPlayAction()
    }
    set {vehicleActionMsg = .mediaPlayAction(newValue)}
  }

  var mediaUpdateVolume: CarServer_MediaUpdateVolume {
    get {
      if case .mediaUpdateVolume(let v)? = vehicleActionMsg {return v}
      return CarServer_MediaUpdateVolume()
    }
    set {vehicleActionMsg = .mediaUpdateVolume(newValue)}
  }

  var mediaNextFavorite: CarServer_MediaNextFavorite {
    get {
      if case .mediaNextFavorite(let v)? = vehicleActionMsg {return v}
      return CarServer_MediaNextFavorite()
    }
    set {vehicleActionMsg = .mediaNextFavorite(newValue)}
  }

  var mediaPreviousFavorite: CarServer_MediaPreviousFavorite {
    get {
      if case .mediaPreviousFavorite(let v)? = vehicleActionMsg {return v}
      return CarServer_MediaPreviousFavorite()
    }
    set {vehicleActionMsg = .mediaPreviousFavorite(newValue)}
  }

  var mediaNextTrack: CarServer_MediaNextTrack {
    get {
      if case .mediaNextTrack(let v)? = vehicleActionMsg {return v}
      return CarServer_MediaNextTrack()
    }
    set {vehicleActionMsg = .mediaNextTrack(newValue)}
  }

  var mediaPreviousTrack: CarServer_MediaPreviousTrack {
    get {
      if case .mediaPreviousTrack(let v)? = vehicleActionMsg {return v}
      return CarServer_MediaPreviousTrack()
    }
    set {vehicleActionMsg = .mediaPreviousTrack(newValue)}
  }

  var getNearbyChargingSites: CarServer_GetNearbyChargingSites {
    get {
      if case .getNearbyChargingSites(let v)? = vehicleActionMsg {return v}
      return CarServer_GetNearbyChargingSites()
    }
    set {vehicleActionMsg = .getNearbyChargingSites(newValue)}
  }

  var vehicleControlCancelSoftwareUpdateAction: CarServer_VehicleControlCancelSoftwareUpdateAction {
    get {
      if case .vehicleControlCancelSoftwareUpdateAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlCancelSoftwareUpdateAction()
    }
    set {vehicleActionMsg = .vehicleControlCancelSoftwareUpdateAction(newValue)}
  }

  var vehicleControlFlashLightsAction: CarServer_VehicleControlFlashLightsAction {
    get {
      if case .vehicleControlFlashLightsAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlFlashLightsAction()
    }
    set {vehicleActionMsg = .vehicleControlFlashLightsAction(newValue)}
  }

  var vehicleControlHonkHornAction: CarServer_VehicleControlHonkHornAction {
    get {
      if case .vehicleControlHonkHornAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlHonkHornAction()
    }
    set {vehicleActionMsg = .vehicleControlHonkHornAction(newValue)}
  }

  var vehicleControlResetValetPinAction: CarServer_VehicleControlResetValetPinAction {
    get {
      if case .vehicleControlResetValetPinAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlResetValetPinAction()
    }
    set {vehicleActionMsg = .vehicleControlResetValetPinAction(newValue)}
  }

  var vehicleControlScheduleSoftwareUpdateAction: CarServer_VehicleControlScheduleSoftwareUpdateAction {
    get {
      if case .vehicleControlScheduleSoftwareUpdateAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlScheduleSoftwareUpdateAction()
    }
    set {vehicleActionMsg = .vehicleControlScheduleSoftwareUpdateAction(newValue)}
  }

  var vehicleControlSetSentryModeAction: CarServer_VehicleControlSetSentryModeAction {
    get {
      if case .vehicleControlSetSentryModeAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlSetSentryModeAction()
    }
    set {vehicleActionMsg = .vehicleControlSetSentryModeAction(newValue)}
  }

  var vehicleControlSetValetModeAction: CarServer_VehicleControlSetValetModeAction {
    get {
      if case .vehicleControlSetValetModeAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlSetValetModeAction()
    }
    set {vehicleActionMsg = .vehicleControlSetValetModeAction(newValue)}
  }

  var vehicleControlSunroofOpenCloseAction: CarServer_VehicleControlSunroofOpenCloseAction {
    get {
      if case .vehicleControlSunroofOpenCloseAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlSunroofOpenCloseAction()
    }
    set {vehicleActionMsg = .vehicleControlSunroofOpenCloseAction(newValue)}
  }

  var vehicleControlTriggerHomelinkAction: CarServer_VehicleControlTriggerHomelinkAction {
    get {
      if case .vehicleControlTriggerHomelinkAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlTriggerHomelinkAction()
    }
    set {vehicleActionMsg = .vehicleControlTriggerHomelinkAction(newValue)}
  }

  var vehicleControlWindowAction: CarServer_VehicleControlWindowAction {
    get {
      if case .vehicleControlWindowAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlWindowAction()
    }
    set {vehicleActionMsg = .vehicleControlWindowAction(newValue)}
  }

  var hvacBioweaponModeAction: CarServer_HvacBioweaponModeAction {
    get {
      if case .hvacBioweaponModeAction(let v)? = vehicleActionMsg {return v}
      return CarServer_HvacBioweaponModeAction()
    }
    set {vehicleActionMsg = .hvacBioweaponModeAction(newValue)}
  }

  var hvacSeatHeaterActions: CarServer_HvacSeatHeaterActions {
    get {
      if case .hvacSeatHeaterActions(let v)? = vehicleActionMsg {return v}
      return CarServer_HvacSeatHeaterActions()
    }
    set {vehicleActionMsg = .hvacSeatHeaterActions(newValue)}
  }

  var scheduledChargingAction: CarServer_ScheduledChargingAction {
    get {
      if case .scheduledChargingAction(let v)? = vehicleActionMsg {return v}
      return CarServer_ScheduledChargingAction()
    }
    set {vehicleActionMsg = .scheduledChargingAction(newValue)}
  }

  var scheduledDepartureAction: CarServer_ScheduledDepartureAction {
    get {
      if case .scheduledDepartureAction(let v)? = vehicleActionMsg {return v}
      return CarServer_ScheduledDepartureAction()
    }
    set {vehicleActionMsg = .scheduledDepartureAction(newValue)}
  }

  var setChargingAmpsAction: CarServer_SetChargingAmpsAction {
    get {
      if case .setChargingAmpsAction(let v)? = vehicleActionMsg {return v}
      return CarServer_SetChargingAmpsAction()
    }
    set {vehicleActionMsg = .setChargingAmpsAction(newValue)}
  }

  var hvacClimateKeeperAction: CarServer_HvacClimateKeeperAction {
    get {
      if case .hvacClimateKeeperAction(let v)? = vehicleActionMsg {return v}
      return CarServer_HvacClimateKeeperAction()
    }
    set {vehicleActionMsg = .hvacClimateKeeperAction(newValue)}
  }

  var ping: CarServer_Ping {
    get {
      if case .ping(let v)? = vehicleActionMsg {return v}
      return CarServer_Ping()
    }
    set {vehicleActionMsg = .ping(newValue)}
  }

  var autoSeatClimateAction: CarServer_AutoSeatClimateAction {
    get {
      if case .autoSeatClimateAction(let v)? = vehicleActionMsg {return v}
      return CarServer_AutoSeatClimateAction()
    }
    set {vehicleActionMsg = .autoSeatClimateAction(newValue)}
  }

  var hvacSeatCoolerActions: CarServer_HvacSeatCoolerActions {
    get {
      if case .hvacSeatCoolerActions(let v)? = vehicleActionMsg {return v}
      return CarServer_HvacSeatCoolerActions()
    }
    set {vehicleActionMsg = .hvacSeatCoolerActions(newValue)}
  }

  var setCabinOverheatProtectionAction: CarServer_SetCabinOverheatProtectionAction {
    get {
      if case .setCabinOverheatProtectionAction(let v)? = vehicleActionMsg {return v}
      return CarServer_SetCabinOverheatProtectionAction()
    }
    set {vehicleActionMsg = .setCabinOverheatProtectionAction(newValue)}
  }

  var setVehicleNameAction: CarServer_SetVehicleNameAction {
    get {
      if case .setVehicleNameAction(let v)? = vehicleActionMsg {return v}
      return CarServer_SetVehicleNameAction()
    }
    set {vehicleActionMsg = .setVehicleNameAction(newValue)}
  }

  var chargePortDoorClose: CarServer_ChargePortDoorClose {
    get {
      if case .chargePortDoorClose(let v)? = vehicleActionMsg {return v}
      return CarServer_ChargePortDoorClose()
    }
    set {vehicleActionMsg = .chargePortDoorClose(newValue)}
  }

  var chargePortDoorOpen: CarServer_ChargePortDoorOpen {
    get {
      if case .chargePortDoorOpen(let v)? = vehicleActionMsg {return v}
      return CarServer_ChargePortDoorOpen()
    }
    set {vehicleActionMsg = .chargePortDoorOpen(newValue)}
  }

  var guestModeAction: CarServer_VehicleState.GuestMode {
    get {
      if case .guestModeAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleState.GuestMode()
    }
    set {vehicleActionMsg = .guestModeAction(newValue)}
  }

  var setCopTempAction: CarServer_SetCopTempAction {
    get {
      if case .setCopTempAction(let v)? = vehicleActionMsg {return v}
      return CarServer_SetCopTempAction()
    }
    set {vehicleActionMsg = .setCopTempAction(newValue)}
  }

  var eraseUserDataAction: CarServer_EraseUserDataAction {
    get {
      if case .eraseUserDataAction(let v)? = vehicleActionMsg {return v}
      return CarServer_EraseUserDataAction()
    }
    set {vehicleActionMsg = .eraseUserDataAction(newValue)}
  }

  var vehicleControlSetPinToDriveAction: CarServer_VehicleControlSetPinToDriveAction {
    get {
      if case .vehicleControlSetPinToDriveAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlSetPinToDriveAction()
    }
    set {vehicleActionMsg = .vehicleControlSetPinToDriveAction(newValue)}
  }

  var vehicleControlResetPinToDriveAction: CarServer_VehicleControlResetPinToDriveAction {
    get {
      if case .vehicleControlResetPinToDriveAction(let v)? = vehicleActionMsg {return v}
      return CarServer_VehicleControlResetPinToDriveAction()
    }
    set {vehicleActionMsg = .vehicleControlResetPinToDriveAction(newValue)}
  }

  var addChargeScheduleAction: CarServer_ChargeSchedule {
    get {
      if case .addChargeScheduleAction(let v)? = vehicleActionMsg {return v}
      return CarServer_ChargeSchedule()
    }
    set {vehicleActionMsg = .addChargeScheduleAction(newValue)}
  }

  var removeChargeScheduleAction: CarServer_RemoveChargeScheduleAction {
    get {
      if case .removeChargeScheduleAction(let v)? = vehicleActionMsg {return v}
      return CarServer_RemoveChargeScheduleAction()
    }
    set {vehicleActionMsg = .removeChargeScheduleAction(newValue)}
  }

  var addPreconditionScheduleAction: CarServer_PreconditionSchedule {
    get {
      if case .addPreconditionScheduleAction(let v)? = vehicleActionMsg {return v}
      return CarServer_PreconditionSchedule()
    }
    set {vehicleActionMsg = .addPreconditionScheduleAction(newValue)}
  }

  var removePreconditionScheduleAction: CarServer_RemovePreconditionScheduleAction {
    get {
      if case .removePreconditionScheduleAction(let v)? = vehicleActionMsg {return v}
      return CarServer_RemovePreconditionScheduleAction()
    }
    set {vehicleActionMsg = .removePreconditionScheduleAction(newValue)}
  }

  var batchRemovePreconditionSchedulesAction: CarServer_BatchRemovePreconditionSchedulesAction {
    get {
      if case .batchRemovePreconditionSchedulesAction(let v)? = vehicleActionMsg {return v}
      return CarServer_BatchRemovePreconditionSchedulesAction()
    }
    set {vehicleActionMsg = .batchRemovePreconditionSchedulesAction(newValue)}
  }

  var batchRemoveChargeSchedulesAction: CarServer_BatchRemoveChargeSchedulesAction {
    get {
      if case .batchRemoveChargeSchedulesAction(let v)? = vehicleActionMsg {return v}
      return CarServer_BatchRemoveChargeSchedulesAction()
    }
    set {vehicleActionMsg = .batchRemoveChargeSchedulesAction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_VehicleActionMsg: Equatable, Sendable {
    case getVehicleData(CarServer_GetVehicleData)
    case chargingSetLimitAction(CarServer_ChargingSetLimitAction)
    case chargingStartStopAction(CarServer_ChargingStartStopAction)
    case drivingClearSpeedLimitPinAction(CarServer_DrivingClearSpeedLimitPinAction)
    case drivingSetSpeedLimitAction(CarServer_DrivingSetSpeedLimitAction)
    case drivingSpeedLimitAction(CarServer_DrivingSpeedLimitAction)
    case hvacAutoAction(CarServer_HvacAutoAction)
    case hvacSetPreconditioningMaxAction(CarServer_HvacSetPreconditioningMaxAction)
    case hvacSteeringWheelHeaterAction(CarServer_HvacSteeringWheelHeaterAction)
    case hvacTemperatureAdjustmentAction(CarServer_HvacTemperatureAdjustmentAction)
    case mediaPlayAction(CarServer_MediaPlayAction)
    case mediaUpdateVolume(CarServer_MediaUpdateVolume)
    case mediaNextFavorite(CarServer_MediaNextFavorite)
    case mediaPreviousFavorite(CarServer_MediaPreviousFavorite)
    case mediaNextTrack(CarServer_MediaNextTrack)
    case mediaPreviousTrack(CarServer_MediaPreviousTrack)
    case getNearbyChargingSites(CarServer_GetNearbyChargingSites)
    case vehicleControlCancelSoftwareUpdateAction(CarServer_VehicleControlCancelSoftwareUpdateAction)
    case vehicleControlFlashLightsAction(CarServer_VehicleControlFlashLightsAction)
    case vehicleControlHonkHornAction(CarServer_VehicleControlHonkHornAction)
    case vehicleControlResetValetPinAction(CarServer_VehicleControlResetValetPinAction)
    case vehicleControlScheduleSoftwareUpdateAction(CarServer_VehicleControlScheduleSoftwareUpdateAction)
    case vehicleControlSetSentryModeAction(CarServer_VehicleControlSetSentryModeAction)
    case vehicleControlSetValetModeAction(CarServer_VehicleControlSetValetModeAction)
    case vehicleControlSunroofOpenCloseAction(CarServer_VehicleControlSunroofOpenCloseAction)
    case vehicleControlTriggerHomelinkAction(CarServer_VehicleControlTriggerHomelinkAction)
    case vehicleControlWindowAction(CarServer_VehicleControlWindowAction)
    case hvacBioweaponModeAction(CarServer_HvacBioweaponModeAction)
    case hvacSeatHeaterActions(CarServer_HvacSeatHeaterActions)
    case scheduledChargingAction(CarServer_ScheduledChargingAction)
    case scheduledDepartureAction(CarServer_ScheduledDepartureAction)
    case setChargingAmpsAction(CarServer_SetChargingAmpsAction)
    case hvacClimateKeeperAction(CarServer_HvacClimateKeeperAction)
    case ping(CarServer_Ping)
    case autoSeatClimateAction(CarServer_AutoSeatClimateAction)
    case hvacSeatCoolerActions(CarServer_HvacSeatCoolerActions)
    case setCabinOverheatProtectionAction(CarServer_SetCabinOverheatProtectionAction)
    case setVehicleNameAction(CarServer_SetVehicleNameAction)
    case chargePortDoorClose(CarServer_ChargePortDoorClose)
    case chargePortDoorOpen(CarServer_ChargePortDoorOpen)
    case guestModeAction(CarServer_VehicleState.GuestMode)
    case setCopTempAction(CarServer_SetCopTempAction)
    case eraseUserDataAction(CarServer_EraseUserDataAction)
    case vehicleControlSetPinToDriveAction(CarServer_VehicleControlSetPinToDriveAction)
    case vehicleControlResetPinToDriveAction(CarServer_VehicleControlResetPinToDriveAction)
    case addChargeScheduleAction(CarServer_ChargeSchedule)
    case removeChargeScheduleAction(CarServer_RemoveChargeScheduleAction)
    case addPreconditionScheduleAction(CarServer_PreconditionSchedule)
    case removePreconditionScheduleAction(CarServer_RemovePreconditionScheduleAction)
    case batchRemovePreconditionSchedulesAction(CarServer_BatchRemovePreconditionSchedulesAction)
    case batchRemoveChargeSchedulesAction(CarServer_BatchRemoveChargeSchedulesAction)

  }

  init() {}
}

struct CarServer_GetVehicleData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var getChargeState: CarServer_GetChargeState {
    get {return _getChargeState ?? CarServer_GetChargeState()}
    set {_getChargeState = newValue}
  }
  /// Returns true if `getChargeState` has been explicitly set.
  var hasGetChargeState: Bool {return self._getChargeState != nil}
  /// Clears the value of `getChargeState`. Subsequent reads from it will return its default value.
  mutating func clearGetChargeState() {self._getChargeState = nil}

  var getClimateState: CarServer_GetClimateState {
    get {return _getClimateState ?? CarServer_GetClimateState()}
    set {_getClimateState = newValue}
  }
  /// Returns true if `getClimateState` has been explicitly set.
  var hasGetClimateState: Bool {return self._getClimateState != nil}
  /// Clears the value of `getClimateState`. Subsequent reads from it will return its default value.
  mutating func clearGetClimateState() {self._getClimateState = nil}

  var getDriveState: CarServer_GetDriveState {
    get {return _getDriveState ?? CarServer_GetDriveState()}
    set {_getDriveState = newValue}
  }
  /// Returns true if `getDriveState` has been explicitly set.
  var hasGetDriveState: Bool {return self._getDriveState != nil}
  /// Clears the value of `getDriveState`. Subsequent reads from it will return its default value.
  mutating func clearGetDriveState() {self._getDriveState = nil}

  var getClosuresState: CarServer_GetClosuresState {
    get {return _getClosuresState ?? CarServer_GetClosuresState()}
    set {_getClosuresState = newValue}
  }
  /// Returns true if `getClosuresState` has been explicitly set.
  var hasGetClosuresState: Bool {return self._getClosuresState != nil}
  /// Clears the value of `getClosuresState`. Subsequent reads from it will return its default value.
  mutating func clearGetClosuresState() {self._getClosuresState = nil}

  var getChargeScheduleState: CarServer_GetChargeScheduleState {
    get {return _getChargeScheduleState ?? CarServer_GetChargeScheduleState()}
    set {_getChargeScheduleState = newValue}
  }
  /// Returns true if `getChargeScheduleState` has been explicitly set.
  var hasGetChargeScheduleState: Bool {return self._getChargeScheduleState != nil}
  /// Clears the value of `getChargeScheduleState`. Subsequent reads from it will return its default value.
  mutating func clearGetChargeScheduleState() {self._getChargeScheduleState = nil}

  var getPreconditioningScheduleState: CarServer_GetPreconditioningScheduleState {
    get {return _getPreconditioningScheduleState ?? CarServer_GetPreconditioningScheduleState()}
    set {_getPreconditioningScheduleState = newValue}
  }
  /// Returns true if `getPreconditioningScheduleState` has been explicitly set.
  var hasGetPreconditioningScheduleState: Bool {return self._getPreconditioningScheduleState != nil}
  /// Clears the value of `getPreconditioningScheduleState`. Subsequent reads from it will return its default value.
  mutating func clearGetPreconditioningScheduleState() {self._getPreconditioningScheduleState = nil}

  var getTirePressureState: CarServer_GetTirePressureState {
    get {return _getTirePressureState ?? CarServer_GetTirePressureState()}
    set {_getTirePressureState = newValue}
  }
  /// Returns true if `getTirePressureState` has been explicitly set.
  var hasGetTirePressureState: Bool {return self._getTirePressureState != nil}
  /// Clears the value of `getTirePressureState`. Subsequent reads from it will return its default value.
  mutating func clearGetTirePressureState() {self._getTirePressureState = nil}

  var getMediaState: CarServer_GetMediaState {
    get {return _getMediaState ?? CarServer_GetMediaState()}
    set {_getMediaState = newValue}
  }
  /// Returns true if `getMediaState` has been explicitly set.
  var hasGetMediaState: Bool {return self._getMediaState != nil}
  /// Clears the value of `getMediaState`. Subsequent reads from it will return its default value.
  mutating func clearGetMediaState() {self._getMediaState = nil}

  var getMediaDetailState: CarServer_GetMediaDetailState {
    get {return _getMediaDetailState ?? CarServer_GetMediaDetailState()}
    set {_getMediaDetailState = newValue}
  }
  /// Returns true if `getMediaDetailState` has been explicitly set.
  var hasGetMediaDetailState: Bool {return self._getMediaDetailState != nil}
  /// Clears the value of `getMediaDetailState`. Subsequent reads from it will return its default value.
  mutating func clearGetMediaDetailState() {self._getMediaDetailState = nil}

  var getSoftwareUpdateState: CarServer_GetSoftwareUpdateState {
    get {return _getSoftwareUpdateState ?? CarServer_GetSoftwareUpdateState()}
    set {_getSoftwareUpdateState = newValue}
  }
  /// Returns true if `getSoftwareUpdateState` has been explicitly set.
  var hasGetSoftwareUpdateState: Bool {return self._getSoftwareUpdateState != nil}
  /// Clears the value of `getSoftwareUpdateState`. Subsequent reads from it will return its default value.
  mutating func clearGetSoftwareUpdateState() {self._getSoftwareUpdateState = nil}

  var getParentalControlsState: CarServer_GetParentalControlsState {
    get {return _getParentalControlsState ?? CarServer_GetParentalControlsState()}
    set {_getParentalControlsState = newValue}
  }
  /// Returns true if `getParentalControlsState` has been explicitly set.
  var hasGetParentalControlsState: Bool {return self._getParentalControlsState != nil}
  /// Clears the value of `getParentalControlsState`. Subsequent reads from it will return its default value.
  mutating func clearGetParentalControlsState() {self._getParentalControlsState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _getChargeState: CarServer_GetChargeState? = nil
  fileprivate var _getClimateState: CarServer_GetClimateState? = nil
  fileprivate var _getDriveState: CarServer_GetDriveState? = nil
  fileprivate var _getClosuresState: CarServer_GetClosuresState? = nil
  fileprivate var _getChargeScheduleState: CarServer_GetChargeScheduleState? = nil
  fileprivate var _getPreconditioningScheduleState: CarServer_GetPreconditioningScheduleState? = nil
  fileprivate var _getTirePressureState: CarServer_GetTirePressureState? = nil
  fileprivate var _getMediaState: CarServer_GetMediaState? = nil
  fileprivate var _getMediaDetailState: CarServer_GetMediaDetailState? = nil
  fileprivate var _getSoftwareUpdateState: CarServer_GetSoftwareUpdateState? = nil
  fileprivate var _getParentalControlsState: CarServer_GetParentalControlsState? = nil
}

struct CarServer_GetTirePressureState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetMediaState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetMediaDetailState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetSoftwareUpdateState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetChargeState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetClimateState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetDriveState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetClosuresState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetChargeScheduleState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetPreconditioningScheduleState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_GetParentalControlsState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_EraseUserDataAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionStatus: CarServer_ActionStatus {
    get {return _actionStatus ?? CarServer_ActionStatus()}
    set {_actionStatus = newValue}
  }
  /// Returns true if `actionStatus` has been explicitly set.
  var hasActionStatus: Bool {return self._actionStatus != nil}
  /// Clears the value of `actionStatus`. Subsequent reads from it will return its default value.
  mutating func clearActionStatus() {self._actionStatus = nil}

  var responseMsg: CarServer_Response.OneOf_ResponseMsg? = nil

  var vehicleData: CarServer_VehicleData {
    get {
      if case .vehicleData(let v)? = responseMsg {return v}
      return CarServer_VehicleData()
    }
    set {responseMsg = .vehicleData(newValue)}
  }

  var getSessionInfoResponse: Signatures_SessionInfo {
    get {
      if case .getSessionInfoResponse(let v)? = responseMsg {return v}
      return Signatures_SessionInfo()
    }
    set {responseMsg = .getSessionInfoResponse(newValue)}
  }

  var getNearbyChargingSites: CarServer_NearbyChargingSites {
    get {
      if case .getNearbyChargingSites(let v)? = responseMsg {return v}
      return CarServer_NearbyChargingSites()
    }
    set {responseMsg = .getNearbyChargingSites(newValue)}
  }

  var ping: CarServer_Ping {
    get {
      if case .ping(let v)? = responseMsg {return v}
      return CarServer_Ping()
    }
    set {responseMsg = .ping(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ResponseMsg: Equatable, Sendable {
    case vehicleData(CarServer_VehicleData)
    case getSessionInfoResponse(Signatures_SessionInfo)
    case getNearbyChargingSites(CarServer_NearbyChargingSites)
    case ping(CarServer_Ping)

  }

  init() {}

  fileprivate var _actionStatus: CarServer_ActionStatus? = nil
}

struct CarServer_ActionStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: CarServer_OperationStatus_E = .operationstatusOk

  var resultReason: CarServer_ResultReason {
    get {return _resultReason ?? CarServer_ResultReason()}
    set {_resultReason = newValue}
  }
  /// Returns true if `resultReason` has been explicitly set.
  var hasResultReason: Bool {return self._resultReason != nil}
  /// Clears the value of `resultReason`. Subsequent reads from it will return its default value.
  mutating func clearResultReason() {self._resultReason = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resultReason: CarServer_ResultReason? = nil
}

struct CarServer_ResultReason: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: CarServer_ResultReason.OneOf_Reason? = nil

  var plainText: String {
    get {
      if case .plainText(let v)? = reason {return v}
      return String()
    }
    set {reason = .plainText(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Reason: Equatable, Sendable {
    case plainText(String)

  }

  init() {}
}

struct CarServer_EncryptedData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fieldNumber: Int32 = 0

  var ciphertext: Data = Data()

  var tag: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_ChargingSetLimitAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var percent: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_ChargingStartStopAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargingAction: CarServer_ChargingStartStopAction.OneOf_ChargingAction? = nil

  var unknown: CarServer_Void {
    get {
      if case .unknown(let v)? = chargingAction {return v}
      return CarServer_Void()
    }
    set {chargingAction = .unknown(newValue)}
  }

  var start: CarServer_Void {
    get {
      if case .start(let v)? = chargingAction {return v}
      return CarServer_Void()
    }
    set {chargingAction = .start(newValue)}
  }

  var startStandard: CarServer_Void {
    get {
      if case .startStandard(let v)? = chargingAction {return v}
      return CarServer_Void()
    }
    set {chargingAction = .startStandard(newValue)}
  }

  var startMaxRange: CarServer_Void {
    get {
      if case .startMaxRange(let v)? = chargingAction {return v}
      return CarServer_Void()
    }
    set {chargingAction = .startMaxRange(newValue)}
  }

  var stop: CarServer_Void {
    get {
      if case .stop(let v)? = chargingAction {return v}
      return CarServer_Void()
    }
    set {chargingAction = .stop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ChargingAction: Equatable, Sendable {
    case unknown(CarServer_Void)
    case start(CarServer_Void)
    case startStandard(CarServer_Void)
    case startMaxRange(CarServer_Void)
    case stop(CarServer_Void)

  }

  init() {}
}

struct CarServer_DrivingClearSpeedLimitPinAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_DrivingSetSpeedLimitAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limitMph: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_DrivingSpeedLimitAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activate: Bool = false

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_HvacAutoAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var powerOn: Bool = false

  var manualOverride: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_HvacSeatHeaterActions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hvacSeatHeaterAction: [CarServer_HvacSeatHeaterActions.HvacSeatHeaterAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct HvacSeatHeaterAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var seatHeaterLevel: CarServer_HvacSeatHeaterActions.HvacSeatHeaterAction.OneOf_SeatHeaterLevel? = nil

    var seatHeaterUnknown: CarServer_Void {
      get {
        if case .seatHeaterUnknown(let v)? = seatHeaterLevel {return v}
        return CarServer_Void()
      }
      set {seatHeaterLevel = .seatHeaterUnknown(newValue)}
    }

    var seatHeaterOff: CarServer_Void {
      get {
        if case .seatHeaterOff(let v)? = seatHeaterLevel {return v}
        return CarServer_Void()
      }
      set {seatHeaterLevel = .seatHeaterOff(newValue)}
    }

    var seatHeaterLow: CarServer_Void {
      get {
        if case .seatHeaterLow(let v)? = seatHeaterLevel {return v}
        return CarServer_Void()
      }
      set {seatHeaterLevel = .seatHeaterLow(newValue)}
    }

    var seatHeaterMed: CarServer_Void {
      get {
        if case .seatHeaterMed(let v)? = seatHeaterLevel {return v}
        return CarServer_Void()
      }
      set {seatHeaterLevel = .seatHeaterMed(newValue)}
    }

    var seatHeaterHigh: CarServer_Void {
      get {
        if case .seatHeaterHigh(let v)? = seatHeaterLevel {return v}
        return CarServer_Void()
      }
      set {seatHeaterLevel = .seatHeaterHigh(newValue)}
    }

    var seatPosition: CarServer_HvacSeatHeaterActions.HvacSeatHeaterAction.OneOf_SeatPosition? = nil

    var carSeatUnknown: CarServer_Void {
      get {
        if case .carSeatUnknown(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatUnknown(newValue)}
    }

    var carSeatFrontLeft: CarServer_Void {
      get {
        if case .carSeatFrontLeft(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatFrontLeft(newValue)}
    }

    var carSeatFrontRight: CarServer_Void {
      get {
        if case .carSeatFrontRight(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatFrontRight(newValue)}
    }

    var carSeatRearLeft: CarServer_Void {
      get {
        if case .carSeatRearLeft(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatRearLeft(newValue)}
    }

    var carSeatRearLeftBack: CarServer_Void {
      get {
        if case .carSeatRearLeftBack(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatRearLeftBack(newValue)}
    }

    var carSeatRearCenter: CarServer_Void {
      get {
        if case .carSeatRearCenter(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatRearCenter(newValue)}
    }

    var carSeatRearRight: CarServer_Void {
      get {
        if case .carSeatRearRight(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatRearRight(newValue)}
    }

    var carSeatRearRightBack: CarServer_Void {
      get {
        if case .carSeatRearRightBack(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatRearRightBack(newValue)}
    }

    var carSeatThirdRowLeft: CarServer_Void {
      get {
        if case .carSeatThirdRowLeft(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatThirdRowLeft(newValue)}
    }

    var carSeatThirdRowRight: CarServer_Void {
      get {
        if case .carSeatThirdRowRight(let v)? = seatPosition {return v}
        return CarServer_Void()
      }
      set {seatPosition = .carSeatThirdRowRight(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_SeatHeaterLevel: Equatable, Sendable {
      case seatHeaterUnknown(CarServer_Void)
      case seatHeaterOff(CarServer_Void)
      case seatHeaterLow(CarServer_Void)
      case seatHeaterMed(CarServer_Void)
      case seatHeaterHigh(CarServer_Void)

    }

    enum OneOf_SeatPosition: Equatable, Sendable {
      case carSeatUnknown(CarServer_Void)
      case carSeatFrontLeft(CarServer_Void)
      case carSeatFrontRight(CarServer_Void)
      case carSeatRearLeft(CarServer_Void)
      case carSeatRearLeftBack(CarServer_Void)
      case carSeatRearCenter(CarServer_Void)
      case carSeatRearRight(CarServer_Void)
      case carSeatRearRightBack(CarServer_Void)
      case carSeatThirdRowLeft(CarServer_Void)
      case carSeatThirdRowRight(CarServer_Void)

    }

    init() {}
  }

  init() {}
}

struct CarServer_HvacSeatCoolerActions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hvacSeatCoolerAction: [CarServer_HvacSeatCoolerActions.HvacSeatCoolerAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum HvacSeatCoolerLevel_E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case hvacSeatCoolerLevelUnknown // = 0
    case hvacSeatCoolerLevelOff // = 1
    case hvacSeatCoolerLevelLow // = 2
    case hvacSeatCoolerLevelMed // = 3
    case hvacSeatCoolerLevelHigh // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .hvacSeatCoolerLevelUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .hvacSeatCoolerLevelUnknown
      case 1: self = .hvacSeatCoolerLevelOff
      case 2: self = .hvacSeatCoolerLevelLow
      case 3: self = .hvacSeatCoolerLevelMed
      case 4: self = .hvacSeatCoolerLevelHigh
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .hvacSeatCoolerLevelUnknown: return 0
      case .hvacSeatCoolerLevelOff: return 1
      case .hvacSeatCoolerLevelLow: return 2
      case .hvacSeatCoolerLevelMed: return 3
      case .hvacSeatCoolerLevelHigh: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_HvacSeatCoolerActions.HvacSeatCoolerLevel_E] = [
      .hvacSeatCoolerLevelUnknown,
      .hvacSeatCoolerLevelOff,
      .hvacSeatCoolerLevelLow,
      .hvacSeatCoolerLevelMed,
      .hvacSeatCoolerLevelHigh,
    ]

  }

  enum HvacSeatCoolerPosition_E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case hvacSeatCoolerPositionUnknown // = 0
    case hvacSeatCoolerPositionFrontLeft // = 1
    case hvacSeatCoolerPositionFrontRight // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .hvacSeatCoolerPositionUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .hvacSeatCoolerPositionUnknown
      case 1: self = .hvacSeatCoolerPositionFrontLeft
      case 2: self = .hvacSeatCoolerPositionFrontRight
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .hvacSeatCoolerPositionUnknown: return 0
      case .hvacSeatCoolerPositionFrontLeft: return 1
      case .hvacSeatCoolerPositionFrontRight: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_HvacSeatCoolerActions.HvacSeatCoolerPosition_E] = [
      .hvacSeatCoolerPositionUnknown,
      .hvacSeatCoolerPositionFrontLeft,
      .hvacSeatCoolerPositionFrontRight,
    ]

  }

  struct HvacSeatCoolerAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var seatCoolerLevel: CarServer_HvacSeatCoolerActions.HvacSeatCoolerLevel_E = .hvacSeatCoolerLevelUnknown

    var seatPosition: CarServer_HvacSeatCoolerActions.HvacSeatCoolerPosition_E = .hvacSeatCoolerPositionUnknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct CarServer_HvacSetPreconditioningMaxAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var manualOverride: Bool = false

  var manualOverrideMode: [CarServer_HvacSetPreconditioningMaxAction.ManualOverrideMode_E] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ManualOverrideMode_E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case dogMode // = 0
    case soc // = 1
    case doors // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .dogMode
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dogMode
      case 1: self = .soc
      case 2: self = .doors
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .dogMode: return 0
      case .soc: return 1
      case .doors: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_HvacSetPreconditioningMaxAction.ManualOverrideMode_E] = [
      .dogMode,
      .soc,
      .doors,
    ]

  }

  init() {}
}

struct CarServer_HvacSteeringWheelHeaterAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var powerOn: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_HvacTemperatureAdjustmentAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deltaCelsius: Float = 0

  var deltaPercent: Int32 = 0

  var absoluteCelsius: Float = 0

  var level: CarServer_HvacTemperatureAdjustmentAction.Temperature {
    get {return _level ?? CarServer_HvacTemperatureAdjustmentAction.Temperature()}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {self._level = nil}

  var hvacTemperatureZone: [CarServer_HvacTemperatureAdjustmentAction.HvacTemperatureZone] = []

  var driverTempCelsius: Float = 0

  var passengerTempCelsius: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Temperature: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_HvacTemperatureAdjustmentAction.Temperature.OneOf_Type? = nil

    var tempUnknown: CarServer_Void {
      get {
        if case .tempUnknown(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .tempUnknown(newValue)}
    }

    var tempMin: CarServer_Void {
      get {
        if case .tempMin(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .tempMin(newValue)}
    }

    var tempMax: CarServer_Void {
      get {
        if case .tempMax(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .tempMax(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case tempUnknown(CarServer_Void)
      case tempMin(CarServer_Void)
      case tempMax(CarServer_Void)

    }

    init() {}
  }

  struct HvacTemperatureZone: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_HvacTemperatureAdjustmentAction.HvacTemperatureZone.OneOf_Type? = nil

    var tempZoneUnknown: CarServer_Void {
      get {
        if case .tempZoneUnknown(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .tempZoneUnknown(newValue)}
    }

    var tempZoneFrontLeft: CarServer_Void {
      get {
        if case .tempZoneFrontLeft(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .tempZoneFrontLeft(newValue)}
    }

    var tempZoneFrontRight: CarServer_Void {
      get {
        if case .tempZoneFrontRight(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .tempZoneFrontRight(newValue)}
    }

    var tempZoneRear: CarServer_Void {
      get {
        if case .tempZoneRear(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .tempZoneRear(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case tempZoneUnknown(CarServer_Void)
      case tempZoneFrontLeft(CarServer_Void)
      case tempZoneFrontRight(CarServer_Void)
      case tempZoneRear(CarServer_Void)

    }

    init() {}
  }

  init() {}

  fileprivate var _level: CarServer_HvacTemperatureAdjustmentAction.Temperature? = nil
}

struct CarServer_GetNearbyChargingSites: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var includeMetaData: Bool = false

  var radius: Int32 = 0

  var count: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_NearbyChargingSites: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var superchargers: [CarServer_Superchargers] = []

  var congestionSyncTimeUtcSecs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct CarServer_Superchargers: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var amenities: String {
    get {return _storage._amenities}
    set {_uniqueStorage()._amenities = newValue}
  }

  var availableStalls: Int32 {
    get {return _storage._availableStalls}
    set {_uniqueStorage()._availableStalls = newValue}
  }

  var billingInfo: String {
    get {return _storage._billingInfo}
    set {_uniqueStorage()._billingInfo = newValue}
  }

  var billingTime: String {
    get {return _storage._billingTime}
    set {_uniqueStorage()._billingTime = newValue}
  }

  var city: String {
    get {return _storage._city}
    set {_uniqueStorage()._city = newValue}
  }

  var country: String {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  var distanceMiles: Float {
    get {return _storage._distanceMiles}
    set {_uniqueStorage()._distanceMiles = newValue}
  }

  var district: String {
    get {return _storage._district}
    set {_uniqueStorage()._district = newValue}
  }

  var location: CarServer_LatLong {
    get {return _storage._location ?? CarServer_LatLong()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var postalCode: String {
    get {return _storage._postalCode}
    set {_uniqueStorage()._postalCode = newValue}
  }

  var siteClosed: Bool {
    get {return _storage._siteClosed}
    set {_uniqueStorage()._siteClosed = newValue}
  }

  var state: String {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var streetAddress: String {
    get {return _storage._streetAddress}
    set {_uniqueStorage()._streetAddress = newValue}
  }

  var totalStalls: Int32 {
    get {return _storage._totalStalls}
    set {_uniqueStorage()._totalStalls = newValue}
  }

  var withinRange: Bool {
    get {return _storage._withinRange}
    set {_uniqueStorage()._withinRange = newValue}
  }

  var maxPowerKw: Int32 {
    get {return _storage._maxPowerKw}
    set {_uniqueStorage()._maxPowerKw = newValue}
  }

  var outOfOrderStallsNumber: Int32 {
    get {return _storage._outOfOrderStallsNumber}
    set {_uniqueStorage()._outOfOrderStallsNumber = newValue}
  }

  var outOfOrderStallsNames: String {
    get {return _storage._outOfOrderStallsNames}
    set {_uniqueStorage()._outOfOrderStallsNames = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CarServer_MediaPlayAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_MediaUpdateVolume: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaVolume: CarServer_MediaUpdateVolume.OneOf_MediaVolume? = nil

  var volumeDelta: Int32 {
    get {
      if case .volumeDelta(let v)? = mediaVolume {return v}
      return 0
    }
    set {mediaVolume = .volumeDelta(newValue)}
  }

  var volumeAbsoluteFloat: Float {
    get {
      if case .volumeAbsoluteFloat(let v)? = mediaVolume {return v}
      return 0
    }
    set {mediaVolume = .volumeAbsoluteFloat(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_MediaVolume: Equatable, Sendable {
    case volumeDelta(Int32)
    case volumeAbsoluteFloat(Float)

  }

  init() {}
}

struct CarServer_MediaNextFavorite: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_MediaPreviousFavorite: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_MediaNextTrack: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_MediaPreviousTrack: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlCancelSoftwareUpdateAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlFlashLightsAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlHonkHornAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlResetValetPinAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlScheduleSoftwareUpdateAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offsetSec: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlSetSentryModeAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlSetValetModeAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlSunroofOpenCloseAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sunroofLevel: CarServer_VehicleControlSunroofOpenCloseAction.OneOf_SunroofLevel? = nil

  var absoluteLevel: Int32 {
    get {
      if case .absoluteLevel(let v)? = sunroofLevel {return v}
      return 0
    }
    set {sunroofLevel = .absoluteLevel(newValue)}
  }

  var deltaLevel: Int32 {
    get {
      if case .deltaLevel(let v)? = sunroofLevel {return v}
      return 0
    }
    set {sunroofLevel = .deltaLevel(newValue)}
  }

  var action: CarServer_VehicleControlSunroofOpenCloseAction.OneOf_Action? = nil

  var vent: CarServer_Void {
    get {
      if case .vent(let v)? = action {return v}
      return CarServer_Void()
    }
    set {action = .vent(newValue)}
  }

  var close: CarServer_Void {
    get {
      if case .close(let v)? = action {return v}
      return CarServer_Void()
    }
    set {action = .close(newValue)}
  }

  var `open`: CarServer_Void {
    get {
      if case .open(let v)? = action {return v}
      return CarServer_Void()
    }
    set {action = .open(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SunroofLevel: Equatable, Sendable {
    case absoluteLevel(Int32)
    case deltaLevel(Int32)

  }

  enum OneOf_Action: Equatable, Sendable {
    case vent(CarServer_Void)
    case close(CarServer_Void)
    case `open`(CarServer_Void)

  }

  init() {}
}

struct CarServer_VehicleControlTriggerHomelinkAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: CarServer_LatLong {
    get {return _location ?? CarServer_LatLong()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _location: CarServer_LatLong? = nil
}

struct CarServer_VehicleControlWindowAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: CarServer_VehicleControlWindowAction.OneOf_Action? = nil

  var unknown: CarServer_Void {
    get {
      if case .unknown(let v)? = action {return v}
      return CarServer_Void()
    }
    set {action = .unknown(newValue)}
  }

  var vent: CarServer_Void {
    get {
      if case .vent(let v)? = action {return v}
      return CarServer_Void()
    }
    set {action = .vent(newValue)}
  }

  var close: CarServer_Void {
    get {
      if case .close(let v)? = action {return v}
      return CarServer_Void()
    }
    set {action = .close(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Action: Equatable, Sendable {
    case unknown(CarServer_Void)
    case vent(CarServer_Void)
    case close(CarServer_Void)

  }

  init() {}
}

struct CarServer_HvacBioweaponModeAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var manualOverride: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_AutoSeatClimateAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var carseat: [CarServer_AutoSeatClimateAction.CarSeat] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum AutoSeatPosition_E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case autoSeatPositionUnknown // = 0
    case autoSeatPositionFrontLeft // = 1
    case autoSeatPositionFrontRight // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .autoSeatPositionUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .autoSeatPositionUnknown
      case 1: self = .autoSeatPositionFrontLeft
      case 2: self = .autoSeatPositionFrontRight
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .autoSeatPositionUnknown: return 0
      case .autoSeatPositionFrontLeft: return 1
      case .autoSeatPositionFrontRight: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_AutoSeatClimateAction.AutoSeatPosition_E] = [
      .autoSeatPositionUnknown,
      .autoSeatPositionFrontLeft,
      .autoSeatPositionFrontRight,
    ]

  }

  struct CarSeat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var on: Bool = false

    var seatPosition: CarServer_AutoSeatClimateAction.AutoSeatPosition_E = .autoSeatPositionUnknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct CarServer_Ping: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pingID: Int32 = 0

  var localTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _localTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_localTimestamp = newValue}
  }
  /// Returns true if `localTimestamp` has been explicitly set.
  var hasLocalTimestamp: Bool {return self._localTimestamp != nil}
  /// Clears the value of `localTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearLocalTimestamp() {self._localTimestamp = nil}

  var lastRemoteTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastRemoteTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastRemoteTimestamp = newValue}
  }
  /// Returns true if `lastRemoteTimestamp` has been explicitly set.
  var hasLastRemoteTimestamp: Bool {return self._lastRemoteTimestamp != nil}
  /// Clears the value of `lastRemoteTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearLastRemoteTimestamp() {self._lastRemoteTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _localTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastRemoteTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct CarServer_ScheduledChargingAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var chargingTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_ScheduledDepartureAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var departureTime: Int32 = 0

  var preconditioningTimes: CarServer_PreconditioningTimes {
    get {return _preconditioningTimes ?? CarServer_PreconditioningTimes()}
    set {_preconditioningTimes = newValue}
  }
  /// Returns true if `preconditioningTimes` has been explicitly set.
  var hasPreconditioningTimes: Bool {return self._preconditioningTimes != nil}
  /// Clears the value of `preconditioningTimes`. Subsequent reads from it will return its default value.
  mutating func clearPreconditioningTimes() {self._preconditioningTimes = nil}

  var offPeakChargingTimes: CarServer_OffPeakChargingTimes {
    get {return _offPeakChargingTimes ?? CarServer_OffPeakChargingTimes()}
    set {_offPeakChargingTimes = newValue}
  }
  /// Returns true if `offPeakChargingTimes` has been explicitly set.
  var hasOffPeakChargingTimes: Bool {return self._offPeakChargingTimes != nil}
  /// Clears the value of `offPeakChargingTimes`. Subsequent reads from it will return its default value.
  mutating func clearOffPeakChargingTimes() {self._offPeakChargingTimes = nil}

  var offPeakHoursEndTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _preconditioningTimes: CarServer_PreconditioningTimes? = nil
  fileprivate var _offPeakChargingTimes: CarServer_OffPeakChargingTimes? = nil
}

struct CarServer_HvacClimateKeeperAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var climateKeeperAction: CarServer_HvacClimateKeeperAction.ClimateKeeperAction_E = .climateKeeperActionOff

  var manualOverride: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ClimateKeeperAction_E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case climateKeeperActionOff // = 0
    case climateKeeperActionOn // = 1
    case climateKeeperActionDog // = 2
    case climateKeeperActionCamp // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .climateKeeperActionOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .climateKeeperActionOff
      case 1: self = .climateKeeperActionOn
      case 2: self = .climateKeeperActionDog
      case 3: self = .climateKeeperActionCamp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .climateKeeperActionOff: return 0
      case .climateKeeperActionOn: return 1
      case .climateKeeperActionDog: return 2
      case .climateKeeperActionCamp: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_HvacClimateKeeperAction.ClimateKeeperAction_E] = [
      .climateKeeperActionOff,
      .climateKeeperActionOn,
      .climateKeeperActionDog,
      .climateKeeperActionCamp,
    ]

  }

  init() {}
}

struct CarServer_SetChargingAmpsAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargingAmps: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_RemoveChargeScheduleAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// datetime in epoch time
  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_BatchRemoveChargeSchedulesAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var home: Bool = false

  var work: Bool = false

  /// Delete non-home and non-work charge schedules
  var other: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_BatchRemovePreconditionSchedulesAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var home: Bool = false

  var work: Bool = false

  /// Delete non-home and non-work precondition schedules
  var other: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_RemovePreconditionScheduleAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// datetime in epoch time
  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_SetCabinOverheatProtectionAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var fanOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_SetVehicleNameAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_ChargePortDoorClose: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_ChargePortDoorOpen: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_SetCopTempAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var copActivationTemp: CarServer_ClimateState.CopActivationTemp = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlSetPinToDriveAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CarServer_VehicleControlResetPinToDriveAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CarServer"

extension CarServer_OperationStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATIONSTATUS_OK"),
    1: .same(proto: "OPERATIONSTATUS_ERROR"),
  ]
}

extension CarServer_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Action"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "vehicleAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: CarServer_VehicleAction?
        var hadOneofValue = false
        if let current = self.actionMsg {
          hadOneofValue = true
          if case .vehicleAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionMsg = .vehicleAction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .vehicleAction(let v)? = self.actionMsg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_Action, rhs: CarServer_Action) -> Bool {
    if lhs.actionMsg != rhs.actionMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getVehicleData"),
    5: .same(proto: "chargingSetLimitAction"),
    6: .same(proto: "chargingStartStopAction"),
    7: .same(proto: "drivingClearSpeedLimitPinAction"),
    8: .same(proto: "drivingSetSpeedLimitAction"),
    9: .same(proto: "drivingSpeedLimitAction"),
    10: .same(proto: "hvacAutoAction"),
    12: .same(proto: "hvacSetPreconditioningMaxAction"),
    13: .same(proto: "hvacSteeringWheelHeaterAction"),
    14: .same(proto: "hvacTemperatureAdjustmentAction"),
    15: .same(proto: "mediaPlayAction"),
    16: .same(proto: "mediaUpdateVolume"),
    17: .same(proto: "mediaNextFavorite"),
    18: .same(proto: "mediaPreviousFavorite"),
    19: .same(proto: "mediaNextTrack"),
    20: .same(proto: "mediaPreviousTrack"),
    23: .same(proto: "getNearbyChargingSites"),
    25: .same(proto: "vehicleControlCancelSoftwareUpdateAction"),
    26: .same(proto: "vehicleControlFlashLightsAction"),
    27: .same(proto: "vehicleControlHonkHornAction"),
    28: .same(proto: "vehicleControlResetValetPinAction"),
    29: .same(proto: "vehicleControlScheduleSoftwareUpdateAction"),
    30: .same(proto: "vehicleControlSetSentryModeAction"),
    31: .same(proto: "vehicleControlSetValetModeAction"),
    32: .same(proto: "vehicleControlSunroofOpenCloseAction"),
    33: .same(proto: "vehicleControlTriggerHomelinkAction"),
    34: .same(proto: "vehicleControlWindowAction"),
    35: .same(proto: "hvacBioweaponModeAction"),
    36: .same(proto: "hvacSeatHeaterActions"),
    41: .same(proto: "scheduledChargingAction"),
    42: .same(proto: "scheduledDepartureAction"),
    43: .same(proto: "setChargingAmpsAction"),
    44: .same(proto: "hvacClimateKeeperAction"),
    46: .same(proto: "ping"),
    48: .same(proto: "autoSeatClimateAction"),
    49: .same(proto: "hvacSeatCoolerActions"),
    50: .same(proto: "setCabinOverheatProtectionAction"),
    54: .same(proto: "setVehicleNameAction"),
    61: .same(proto: "chargePortDoorClose"),
    62: .same(proto: "chargePortDoorOpen"),
    65: .same(proto: "guestModeAction"),
    66: .same(proto: "setCopTempAction"),
    72: .same(proto: "eraseUserDataAction"),
    77: .same(proto: "vehicleControlSetPinToDriveAction"),
    78: .same(proto: "vehicleControlResetPinToDriveAction"),
    97: .same(proto: "addChargeScheduleAction"),
    98: .same(proto: "removeChargeScheduleAction"),
    99: .same(proto: "addPreconditionScheduleAction"),
    100: .same(proto: "removePreconditionScheduleAction"),
    107: .same(proto: "batchRemovePreconditionSchedulesAction"),
    108: .same(proto: "batchRemoveChargeSchedulesAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_GetVehicleData?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .getVehicleData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .getVehicleData(v)
        }
      }()
      case 5: try {
        var v: CarServer_ChargingSetLimitAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .chargingSetLimitAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .chargingSetLimitAction(v)
        }
      }()
      case 6: try {
        var v: CarServer_ChargingStartStopAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .chargingStartStopAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .chargingStartStopAction(v)
        }
      }()
      case 7: try {
        var v: CarServer_DrivingClearSpeedLimitPinAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .drivingClearSpeedLimitPinAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .drivingClearSpeedLimitPinAction(v)
        }
      }()
      case 8: try {
        var v: CarServer_DrivingSetSpeedLimitAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .drivingSetSpeedLimitAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .drivingSetSpeedLimitAction(v)
        }
      }()
      case 9: try {
        var v: CarServer_DrivingSpeedLimitAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .drivingSpeedLimitAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .drivingSpeedLimitAction(v)
        }
      }()
      case 10: try {
        var v: CarServer_HvacAutoAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacAutoAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacAutoAction(v)
        }
      }()
      case 12: try {
        var v: CarServer_HvacSetPreconditioningMaxAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacSetPreconditioningMaxAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacSetPreconditioningMaxAction(v)
        }
      }()
      case 13: try {
        var v: CarServer_HvacSteeringWheelHeaterAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacSteeringWheelHeaterAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacSteeringWheelHeaterAction(v)
        }
      }()
      case 14: try {
        var v: CarServer_HvacTemperatureAdjustmentAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacTemperatureAdjustmentAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacTemperatureAdjustmentAction(v)
        }
      }()
      case 15: try {
        var v: CarServer_MediaPlayAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaPlayAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaPlayAction(v)
        }
      }()
      case 16: try {
        var v: CarServer_MediaUpdateVolume?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaUpdateVolume(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaUpdateVolume(v)
        }
      }()
      case 17: try {
        var v: CarServer_MediaNextFavorite?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaNextFavorite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaNextFavorite(v)
        }
      }()
      case 18: try {
        var v: CarServer_MediaPreviousFavorite?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaPreviousFavorite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaPreviousFavorite(v)
        }
      }()
      case 19: try {
        var v: CarServer_MediaNextTrack?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaNextTrack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaNextTrack(v)
        }
      }()
      case 20: try {
        var v: CarServer_MediaPreviousTrack?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaPreviousTrack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaPreviousTrack(v)
        }
      }()
      case 23: try {
        var v: CarServer_GetNearbyChargingSites?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .getNearbyChargingSites(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .getNearbyChargingSites(v)
        }
      }()
      case 25: try {
        var v: CarServer_VehicleControlCancelSoftwareUpdateAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlCancelSoftwareUpdateAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlCancelSoftwareUpdateAction(v)
        }
      }()
      case 26: try {
        var v: CarServer_VehicleControlFlashLightsAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlFlashLightsAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlFlashLightsAction(v)
        }
      }()
      case 27: try {
        var v: CarServer_VehicleControlHonkHornAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlHonkHornAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlHonkHornAction(v)
        }
      }()
      case 28: try {
        var v: CarServer_VehicleControlResetValetPinAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlResetValetPinAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlResetValetPinAction(v)
        }
      }()
      case 29: try {
        var v: CarServer_VehicleControlScheduleSoftwareUpdateAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlScheduleSoftwareUpdateAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlScheduleSoftwareUpdateAction(v)
        }
      }()
      case 30: try {
        var v: CarServer_VehicleControlSetSentryModeAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlSetSentryModeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlSetSentryModeAction(v)
        }
      }()
      case 31: try {
        var v: CarServer_VehicleControlSetValetModeAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlSetValetModeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlSetValetModeAction(v)
        }
      }()
      case 32: try {
        var v: CarServer_VehicleControlSunroofOpenCloseAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlSunroofOpenCloseAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlSunroofOpenCloseAction(v)
        }
      }()
      case 33: try {
        var v: CarServer_VehicleControlTriggerHomelinkAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlTriggerHomelinkAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlTriggerHomelinkAction(v)
        }
      }()
      case 34: try {
        var v: CarServer_VehicleControlWindowAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlWindowAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlWindowAction(v)
        }
      }()
      case 35: try {
        var v: CarServer_HvacBioweaponModeAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacBioweaponModeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacBioweaponModeAction(v)
        }
      }()
      case 36: try {
        var v: CarServer_HvacSeatHeaterActions?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacSeatHeaterActions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacSeatHeaterActions(v)
        }
      }()
      case 41: try {
        var v: CarServer_ScheduledChargingAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .scheduledChargingAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .scheduledChargingAction(v)
        }
      }()
      case 42: try {
        var v: CarServer_ScheduledDepartureAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .scheduledDepartureAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .scheduledDepartureAction(v)
        }
      }()
      case 43: try {
        var v: CarServer_SetChargingAmpsAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .setChargingAmpsAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .setChargingAmpsAction(v)
        }
      }()
      case 44: try {
        var v: CarServer_HvacClimateKeeperAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacClimateKeeperAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacClimateKeeperAction(v)
        }
      }()
      case 46: try {
        var v: CarServer_Ping?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .ping(v)
        }
      }()
      case 48: try {
        var v: CarServer_AutoSeatClimateAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .autoSeatClimateAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .autoSeatClimateAction(v)
        }
      }()
      case 49: try {
        var v: CarServer_HvacSeatCoolerActions?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacSeatCoolerActions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacSeatCoolerActions(v)
        }
      }()
      case 50: try {
        var v: CarServer_SetCabinOverheatProtectionAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .setCabinOverheatProtectionAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .setCabinOverheatProtectionAction(v)
        }
      }()
      case 54: try {
        var v: CarServer_SetVehicleNameAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .setVehicleNameAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .setVehicleNameAction(v)
        }
      }()
      case 61: try {
        var v: CarServer_ChargePortDoorClose?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .chargePortDoorClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .chargePortDoorClose(v)
        }
      }()
      case 62: try {
        var v: CarServer_ChargePortDoorOpen?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .chargePortDoorOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .chargePortDoorOpen(v)
        }
      }()
      case 65: try {
        var v: CarServer_VehicleState.GuestMode?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .guestModeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .guestModeAction(v)
        }
      }()
      case 66: try {
        var v: CarServer_SetCopTempAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .setCopTempAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .setCopTempAction(v)
        }
      }()
      case 72: try {
        var v: CarServer_EraseUserDataAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .eraseUserDataAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .eraseUserDataAction(v)
        }
      }()
      case 77: try {
        var v: CarServer_VehicleControlSetPinToDriveAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlSetPinToDriveAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlSetPinToDriveAction(v)
        }
      }()
      case 78: try {
        var v: CarServer_VehicleControlResetPinToDriveAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlResetPinToDriveAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlResetPinToDriveAction(v)
        }
      }()
      case 97: try {
        var v: CarServer_ChargeSchedule?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .addChargeScheduleAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .addChargeScheduleAction(v)
        }
      }()
      case 98: try {
        var v: CarServer_RemoveChargeScheduleAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .removeChargeScheduleAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .removeChargeScheduleAction(v)
        }
      }()
      case 99: try {
        var v: CarServer_PreconditionSchedule?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .addPreconditionScheduleAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .addPreconditionScheduleAction(v)
        }
      }()
      case 100: try {
        var v: CarServer_RemovePreconditionScheduleAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .removePreconditionScheduleAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .removePreconditionScheduleAction(v)
        }
      }()
      case 107: try {
        var v: CarServer_BatchRemovePreconditionSchedulesAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .batchRemovePreconditionSchedulesAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .batchRemovePreconditionSchedulesAction(v)
        }
      }()
      case 108: try {
        var v: CarServer_BatchRemoveChargeSchedulesAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .batchRemoveChargeSchedulesAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .batchRemoveChargeSchedulesAction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.vehicleActionMsg {
    case .getVehicleData?: try {
      guard case .getVehicleData(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .chargingSetLimitAction?: try {
      guard case .chargingSetLimitAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .chargingStartStopAction?: try {
      guard case .chargingStartStopAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .drivingClearSpeedLimitPinAction?: try {
      guard case .drivingClearSpeedLimitPinAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .drivingSetSpeedLimitAction?: try {
      guard case .drivingSetSpeedLimitAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .drivingSpeedLimitAction?: try {
      guard case .drivingSpeedLimitAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .hvacAutoAction?: try {
      guard case .hvacAutoAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .hvacSetPreconditioningMaxAction?: try {
      guard case .hvacSetPreconditioningMaxAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .hvacSteeringWheelHeaterAction?: try {
      guard case .hvacSteeringWheelHeaterAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .hvacTemperatureAdjustmentAction?: try {
      guard case .hvacTemperatureAdjustmentAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .mediaPlayAction?: try {
      guard case .mediaPlayAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .mediaUpdateVolume?: try {
      guard case .mediaUpdateVolume(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .mediaNextFavorite?: try {
      guard case .mediaNextFavorite(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .mediaPreviousFavorite?: try {
      guard case .mediaPreviousFavorite(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .mediaNextTrack?: try {
      guard case .mediaNextTrack(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .mediaPreviousTrack?: try {
      guard case .mediaPreviousTrack(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .getNearbyChargingSites?: try {
      guard case .getNearbyChargingSites(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .vehicleControlCancelSoftwareUpdateAction?: try {
      guard case .vehicleControlCancelSoftwareUpdateAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .vehicleControlFlashLightsAction?: try {
      guard case .vehicleControlFlashLightsAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .vehicleControlHonkHornAction?: try {
      guard case .vehicleControlHonkHornAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .vehicleControlResetValetPinAction?: try {
      guard case .vehicleControlResetValetPinAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .vehicleControlScheduleSoftwareUpdateAction?: try {
      guard case .vehicleControlScheduleSoftwareUpdateAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .vehicleControlSetSentryModeAction?: try {
      guard case .vehicleControlSetSentryModeAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .vehicleControlSetValetModeAction?: try {
      guard case .vehicleControlSetValetModeAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .vehicleControlSunroofOpenCloseAction?: try {
      guard case .vehicleControlSunroofOpenCloseAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .vehicleControlTriggerHomelinkAction?: try {
      guard case .vehicleControlTriggerHomelinkAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .vehicleControlWindowAction?: try {
      guard case .vehicleControlWindowAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .hvacBioweaponModeAction?: try {
      guard case .hvacBioweaponModeAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .hvacSeatHeaterActions?: try {
      guard case .hvacSeatHeaterActions(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .scheduledChargingAction?: try {
      guard case .scheduledChargingAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .scheduledDepartureAction?: try {
      guard case .scheduledDepartureAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .setChargingAmpsAction?: try {
      guard case .setChargingAmpsAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .hvacClimateKeeperAction?: try {
      guard case .hvacClimateKeeperAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .autoSeatClimateAction?: try {
      guard case .autoSeatClimateAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .hvacSeatCoolerActions?: try {
      guard case .hvacSeatCoolerActions(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .setCabinOverheatProtectionAction?: try {
      guard case .setCabinOverheatProtectionAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .setVehicleNameAction?: try {
      guard case .setVehicleNameAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .chargePortDoorClose?: try {
      guard case .chargePortDoorClose(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .chargePortDoorOpen?: try {
      guard case .chargePortDoorOpen(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
    }()
    case .guestModeAction?: try {
      guard case .guestModeAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
    }()
    case .setCopTempAction?: try {
      guard case .setCopTempAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
    }()
    case .eraseUserDataAction?: try {
      guard case .eraseUserDataAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
    }()
    case .vehicleControlSetPinToDriveAction?: try {
      guard case .vehicleControlSetPinToDriveAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
    }()
    case .vehicleControlResetPinToDriveAction?: try {
      guard case .vehicleControlResetPinToDriveAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
    }()
    case .addChargeScheduleAction?: try {
      guard case .addChargeScheduleAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
    }()
    case .removeChargeScheduleAction?: try {
      guard case .removeChargeScheduleAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }()
    case .addPreconditionScheduleAction?: try {
      guard case .addPreconditionScheduleAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }()
    case .removePreconditionScheduleAction?: try {
      guard case .removePreconditionScheduleAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .batchRemovePreconditionSchedulesAction?: try {
      guard case .batchRemovePreconditionSchedulesAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .batchRemoveChargeSchedulesAction?: try {
      guard case .batchRemoveChargeSchedulesAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleAction, rhs: CarServer_VehicleAction) -> Bool {
    if lhs.vehicleActionMsg != rhs.vehicleActionMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetVehicleData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetVehicleData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "getChargeState"),
    3: .same(proto: "getClimateState"),
    4: .same(proto: "getDriveState"),
    8: .same(proto: "getClosuresState"),
    10: .same(proto: "getChargeScheduleState"),
    11: .same(proto: "getPreconditioningScheduleState"),
    14: .same(proto: "getTirePressureState"),
    15: .same(proto: "getMediaState"),
    16: .same(proto: "getMediaDetailState"),
    17: .same(proto: "getSoftwareUpdateState"),
    19: .same(proto: "getParentalControlsState"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._getChargeState) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._getClimateState) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._getDriveState) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._getClosuresState) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._getChargeScheduleState) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._getPreconditioningScheduleState) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._getTirePressureState) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._getMediaState) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._getMediaDetailState) }()
      case 17: try { try decoder.decodeSingularMessageField(value: &self._getSoftwareUpdateState) }()
      case 19: try { try decoder.decodeSingularMessageField(value: &self._getParentalControlsState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._getChargeState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._getClimateState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._getDriveState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._getClosuresState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._getChargeScheduleState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._getPreconditioningScheduleState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._getTirePressureState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._getMediaState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._getMediaDetailState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try { if let v = self._getSoftwareUpdateState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    } }()
    try { if let v = self._getParentalControlsState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetVehicleData, rhs: CarServer_GetVehicleData) -> Bool {
    if lhs._getChargeState != rhs._getChargeState {return false}
    if lhs._getClimateState != rhs._getClimateState {return false}
    if lhs._getDriveState != rhs._getDriveState {return false}
    if lhs._getClosuresState != rhs._getClosuresState {return false}
    if lhs._getChargeScheduleState != rhs._getChargeScheduleState {return false}
    if lhs._getPreconditioningScheduleState != rhs._getPreconditioningScheduleState {return false}
    if lhs._getTirePressureState != rhs._getTirePressureState {return false}
    if lhs._getMediaState != rhs._getMediaState {return false}
    if lhs._getMediaDetailState != rhs._getMediaDetailState {return false}
    if lhs._getSoftwareUpdateState != rhs._getSoftwareUpdateState {return false}
    if lhs._getParentalControlsState != rhs._getParentalControlsState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetTirePressureState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTirePressureState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetTirePressureState, rhs: CarServer_GetTirePressureState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetMediaState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMediaState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetMediaState, rhs: CarServer_GetMediaState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetMediaDetailState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMediaDetailState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetMediaDetailState, rhs: CarServer_GetMediaDetailState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetSoftwareUpdateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSoftwareUpdateState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetSoftwareUpdateState, rhs: CarServer_GetSoftwareUpdateState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetChargeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChargeState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetChargeState, rhs: CarServer_GetChargeState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetClimateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetClimateState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetClimateState, rhs: CarServer_GetClimateState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetDriveState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDriveState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetDriveState, rhs: CarServer_GetDriveState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetClosuresState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetClosuresState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetClosuresState, rhs: CarServer_GetClosuresState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetChargeScheduleState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChargeScheduleState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetChargeScheduleState, rhs: CarServer_GetChargeScheduleState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetPreconditioningScheduleState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPreconditioningScheduleState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetPreconditioningScheduleState, rhs: CarServer_GetPreconditioningScheduleState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetParentalControlsState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetParentalControlsState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetParentalControlsState, rhs: CarServer_GetParentalControlsState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_EraseUserDataAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EraseUserDataAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_EraseUserDataAction, rhs: CarServer_EraseUserDataAction) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionStatus"),
    2: .same(proto: "vehicleData"),
    3: .same(proto: "getSessionInfoResponse"),
    5: .same(proto: "getNearbyChargingSites"),
    9: .same(proto: "ping"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionStatus) }()
      case 2: try {
        var v: CarServer_VehicleData?
        var hadOneofValue = false
        if let current = self.responseMsg {
          hadOneofValue = true
          if case .vehicleData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseMsg = .vehicleData(v)
        }
      }()
      case 3: try {
        var v: Signatures_SessionInfo?
        var hadOneofValue = false
        if let current = self.responseMsg {
          hadOneofValue = true
          if case .getSessionInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseMsg = .getSessionInfoResponse(v)
        }
      }()
      case 5: try {
        var v: CarServer_NearbyChargingSites?
        var hadOneofValue = false
        if let current = self.responseMsg {
          hadOneofValue = true
          if case .getNearbyChargingSites(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseMsg = .getNearbyChargingSites(v)
        }
      }()
      case 9: try {
        var v: CarServer_Ping?
        var hadOneofValue = false
        if let current = self.responseMsg {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseMsg = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.responseMsg {
    case .vehicleData?: try {
      guard case .vehicleData(let v)? = self.responseMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getSessionInfoResponse?: try {
      guard case .getSessionInfoResponse(let v)? = self.responseMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getNearbyChargingSites?: try {
      guard case .getNearbyChargingSites(let v)? = self.responseMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.responseMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_Response, rhs: CarServer_Response) -> Bool {
    if lhs._actionStatus != rhs._actionStatus {return false}
    if lhs.responseMsg != rhs.responseMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ActionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "result_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resultReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .operationstatusOk {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._resultReason {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ActionStatus, rhs: CarServer_ActionStatus) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._resultReason != rhs._resultReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ResultReason: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResultReason"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "plain_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.reason != nil {try decoder.handleConflictingOneOf()}
          self.reason = .plainText(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .plainText(let v)? = self.reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ResultReason, rhs: CarServer_ResultReason) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_EncryptedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_number"),
    2: .same(proto: "ciphertext"),
    3: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fieldNumber) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ciphertext) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fieldNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.fieldNumber, fieldNumber: 1)
    }
    if !self.ciphertext.isEmpty {
      try visitor.visitSingularBytesField(value: self.ciphertext, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_EncryptedData, rhs: CarServer_EncryptedData) -> Bool {
    if lhs.fieldNumber != rhs.fieldNumber {return false}
    if lhs.ciphertext != rhs.ciphertext {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargingSetLimitAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargingSetLimitAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.percent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.percent != 0 {
      try visitor.visitSingularInt32Field(value: self.percent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargingSetLimitAction, rhs: CarServer_ChargingSetLimitAction) -> Bool {
    if lhs.percent != rhs.percent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargingStartStopAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargingStartStopAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown"),
    2: .same(proto: "start"),
    3: .standard(proto: "start_standard"),
    4: .standard(proto: "start_max_range"),
    5: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .unknown(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .start(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .startStandard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .startStandard(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .startMaxRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .startMaxRange(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.chargingAction {
    case .unknown?: try {
      guard case .unknown(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .start?: try {
      guard case .start(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .startStandard?: try {
      guard case .startStandard(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .startMaxRange?: try {
      guard case .startMaxRange(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargingStartStopAction, rhs: CarServer_ChargingStartStopAction) -> Bool {
    if lhs.chargingAction != rhs.chargingAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_DrivingClearSpeedLimitPinAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrivingClearSpeedLimitPinAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_DrivingClearSpeedLimitPinAction, rhs: CarServer_DrivingClearSpeedLimitPinAction) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_DrivingSetSpeedLimitAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrivingSetSpeedLimitAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_mph"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.limitMph) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limitMph.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.limitMph, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_DrivingSetSpeedLimitAction, rhs: CarServer_DrivingSetSpeedLimitAction) -> Bool {
    if lhs.limitMph != rhs.limitMph {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_DrivingSpeedLimitAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrivingSpeedLimitAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "activate"),
    2: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.activate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activate != false {
      try visitor.visitSingularBoolField(value: self.activate, fieldNumber: 1)
    }
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_DrivingSpeedLimitAction, rhs: CarServer_DrivingSpeedLimitAction) -> Bool {
    if lhs.activate != rhs.activate {return false}
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacAutoAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HvacAutoAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "power_on"),
    2: .standard(proto: "manual_override"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.powerOn) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.manualOverride) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.powerOn != false {
      try visitor.visitSingularBoolField(value: self.powerOn, fieldNumber: 1)
    }
    if self.manualOverride != false {
      try visitor.visitSingularBoolField(value: self.manualOverride, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacAutoAction, rhs: CarServer_HvacAutoAction) -> Bool {
    if lhs.powerOn != rhs.powerOn {return false}
    if lhs.manualOverride != rhs.manualOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacSeatHeaterActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HvacSeatHeaterActions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hvacSeatHeaterAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hvacSeatHeaterAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hvacSeatHeaterAction.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hvacSeatHeaterAction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacSeatHeaterActions, rhs: CarServer_HvacSeatHeaterActions) -> Bool {
    if lhs.hvacSeatHeaterAction != rhs.hvacSeatHeaterAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacSeatHeaterActions.HvacSeatHeaterAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_HvacSeatHeaterActions.protoMessageName + ".HvacSeatHeaterAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "SEAT_HEATER_UNKNOWN"),
    2: .standard(proto: "SEAT_HEATER_OFF"),
    3: .standard(proto: "SEAT_HEATER_LOW"),
    4: .standard(proto: "SEAT_HEATER_MED"),
    5: .standard(proto: "SEAT_HEATER_HIGH"),
    6: .standard(proto: "CAR_SEAT_UNKNOWN"),
    7: .standard(proto: "CAR_SEAT_FRONT_LEFT"),
    8: .standard(proto: "CAR_SEAT_FRONT_RIGHT"),
    9: .standard(proto: "CAR_SEAT_REAR_LEFT"),
    10: .standard(proto: "CAR_SEAT_REAR_LEFT_BACK"),
    11: .standard(proto: "CAR_SEAT_REAR_CENTER"),
    12: .standard(proto: "CAR_SEAT_REAR_RIGHT"),
    13: .standard(proto: "CAR_SEAT_REAR_RIGHT_BACK"),
    14: .standard(proto: "CAR_SEAT_THIRD_ROW_LEFT"),
    15: .standard(proto: "CAR_SEAT_THIRD_ROW_RIGHT"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterUnknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterUnknown(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterOff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterOff(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterLow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterLow(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterMed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterMed(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterHigh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterHigh(v)
        }
      }()
      case 6: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatUnknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatUnknown(v)
        }
      }()
      case 7: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatFrontLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatFrontLeft(v)
        }
      }()
      case 8: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatFrontRight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatFrontRight(v)
        }
      }()
      case 9: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearLeft(v)
        }
      }()
      case 10: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearLeftBack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearLeftBack(v)
        }
      }()
      case 11: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearCenter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearCenter(v)
        }
      }()
      case 12: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearRight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearRight(v)
        }
      }()
      case 13: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearRightBack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearRightBack(v)
        }
      }()
      case 14: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatThirdRowLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatThirdRowLeft(v)
        }
      }()
      case 15: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatThirdRowRight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatThirdRowRight(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.seatHeaterLevel {
    case .seatHeaterUnknown?: try {
      guard case .seatHeaterUnknown(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .seatHeaterOff?: try {
      guard case .seatHeaterOff(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .seatHeaterLow?: try {
      guard case .seatHeaterLow(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .seatHeaterMed?: try {
      guard case .seatHeaterMed(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .seatHeaterHigh?: try {
      guard case .seatHeaterHigh(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    switch self.seatPosition {
    case .carSeatUnknown?: try {
      guard case .carSeatUnknown(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .carSeatFrontLeft?: try {
      guard case .carSeatFrontLeft(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .carSeatFrontRight?: try {
      guard case .carSeatFrontRight(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .carSeatRearLeft?: try {
      guard case .carSeatRearLeft(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .carSeatRearLeftBack?: try {
      guard case .carSeatRearLeftBack(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .carSeatRearCenter?: try {
      guard case .carSeatRearCenter(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .carSeatRearRight?: try {
      guard case .carSeatRearRight(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .carSeatRearRightBack?: try {
      guard case .carSeatRearRightBack(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .carSeatThirdRowLeft?: try {
      guard case .carSeatThirdRowLeft(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .carSeatThirdRowRight?: try {
      guard case .carSeatThirdRowRight(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacSeatHeaterActions.HvacSeatHeaterAction, rhs: CarServer_HvacSeatHeaterActions.HvacSeatHeaterAction) -> Bool {
    if lhs.seatHeaterLevel != rhs.seatHeaterLevel {return false}
    if lhs.seatPosition != rhs.seatPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacSeatCoolerActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HvacSeatCoolerActions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hvacSeatCoolerAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hvacSeatCoolerAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hvacSeatCoolerAction.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hvacSeatCoolerAction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacSeatCoolerActions, rhs: CarServer_HvacSeatCoolerActions) -> Bool {
    if lhs.hvacSeatCoolerAction != rhs.hvacSeatCoolerAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacSeatCoolerActions.HvacSeatCoolerLevel_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HvacSeatCoolerLevel_Unknown"),
    1: .same(proto: "HvacSeatCoolerLevel_Off"),
    2: .same(proto: "HvacSeatCoolerLevel_Low"),
    3: .same(proto: "HvacSeatCoolerLevel_Med"),
    4: .same(proto: "HvacSeatCoolerLevel_High"),
  ]
}

extension CarServer_HvacSeatCoolerActions.HvacSeatCoolerPosition_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HvacSeatCoolerPosition_Unknown"),
    1: .same(proto: "HvacSeatCoolerPosition_FrontLeft"),
    2: .same(proto: "HvacSeatCoolerPosition_FrontRight"),
  ]
}

extension CarServer_HvacSeatCoolerActions.HvacSeatCoolerAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_HvacSeatCoolerActions.protoMessageName + ".HvacSeatCoolerAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "seat_cooler_level"),
    2: .standard(proto: "seat_position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.seatCoolerLevel) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.seatPosition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seatCoolerLevel != .hvacSeatCoolerLevelUnknown {
      try visitor.visitSingularEnumField(value: self.seatCoolerLevel, fieldNumber: 1)
    }
    if self.seatPosition != .hvacSeatCoolerPositionUnknown {
      try visitor.visitSingularEnumField(value: self.seatPosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacSeatCoolerActions.HvacSeatCoolerAction, rhs: CarServer_HvacSeatCoolerActions.HvacSeatCoolerAction) -> Bool {
    if lhs.seatCoolerLevel != rhs.seatCoolerLevel {return false}
    if lhs.seatPosition != rhs.seatPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacSetPreconditioningMaxAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HvacSetPreconditioningMaxAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .standard(proto: "manual_override"),
    3: .standard(proto: "manual_override_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.manualOverride) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.manualOverrideMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if self.manualOverride != false {
      try visitor.visitSingularBoolField(value: self.manualOverride, fieldNumber: 2)
    }
    if !self.manualOverrideMode.isEmpty {
      try visitor.visitPackedEnumField(value: self.manualOverrideMode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacSetPreconditioningMaxAction, rhs: CarServer_HvacSetPreconditioningMaxAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.manualOverride != rhs.manualOverride {return false}
    if lhs.manualOverrideMode != rhs.manualOverrideMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacSetPreconditioningMaxAction.ManualOverrideMode_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DogMode"),
    1: .same(proto: "Soc"),
    2: .same(proto: "Doors"),
  ]
}

extension CarServer_HvacSteeringWheelHeaterAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HvacSteeringWheelHeaterAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "power_on"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.powerOn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.powerOn != false {
      try visitor.visitSingularBoolField(value: self.powerOn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacSteeringWheelHeaterAction, rhs: CarServer_HvacSteeringWheelHeaterAction) -> Bool {
    if lhs.powerOn != rhs.powerOn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacTemperatureAdjustmentAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HvacTemperatureAdjustmentAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delta_celsius"),
    2: .standard(proto: "delta_percent"),
    3: .standard(proto: "absolute_celsius"),
    5: .same(proto: "level"),
    4: .standard(proto: "hvac_temperature_zone"),
    6: .standard(proto: "driver_temp_celsius"),
    7: .standard(proto: "passenger_temp_celsius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.deltaCelsius) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.deltaPercent) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.absoluteCelsius) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.hvacTemperatureZone) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._level) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.driverTempCelsius) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.passengerTempCelsius) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.deltaCelsius.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.deltaCelsius, fieldNumber: 1)
    }
    if self.deltaPercent != 0 {
      try visitor.visitSingularSInt32Field(value: self.deltaPercent, fieldNumber: 2)
    }
    if self.absoluteCelsius.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.absoluteCelsius, fieldNumber: 3)
    }
    if !self.hvacTemperatureZone.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hvacTemperatureZone, fieldNumber: 4)
    }
    try { if let v = self._level {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.driverTempCelsius.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.driverTempCelsius, fieldNumber: 6)
    }
    if self.passengerTempCelsius.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.passengerTempCelsius, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacTemperatureAdjustmentAction, rhs: CarServer_HvacTemperatureAdjustmentAction) -> Bool {
    if lhs.deltaCelsius != rhs.deltaCelsius {return false}
    if lhs.deltaPercent != rhs.deltaPercent {return false}
    if lhs.absoluteCelsius != rhs.absoluteCelsius {return false}
    if lhs._level != rhs._level {return false}
    if lhs.hvacTemperatureZone != rhs.hvacTemperatureZone {return false}
    if lhs.driverTempCelsius != rhs.driverTempCelsius {return false}
    if lhs.passengerTempCelsius != rhs.passengerTempCelsius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacTemperatureAdjustmentAction.Temperature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_HvacTemperatureAdjustmentAction.protoMessageName + ".Temperature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "TEMP_UNKNOWN"),
    2: .standard(proto: "TEMP_MIN"),
    3: .standard(proto: "TEMP_MAX"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempUnknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempUnknown(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempMin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempMin(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempMax(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempMax(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .tempUnknown?: try {
      guard case .tempUnknown(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .tempMin?: try {
      guard case .tempMin(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tempMax?: try {
      guard case .tempMax(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacTemperatureAdjustmentAction.Temperature, rhs: CarServer_HvacTemperatureAdjustmentAction.Temperature) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacTemperatureAdjustmentAction.HvacTemperatureZone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_HvacTemperatureAdjustmentAction.protoMessageName + ".HvacTemperatureZone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "TEMP_ZONE_UNKNOWN"),
    2: .standard(proto: "TEMP_ZONE_FRONT_LEFT"),
    3: .standard(proto: "TEMP_ZONE_FRONT_RIGHT"),
    4: .standard(proto: "TEMP_ZONE_REAR"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempZoneUnknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempZoneUnknown(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempZoneFrontLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempZoneFrontLeft(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempZoneFrontRight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempZoneFrontRight(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempZoneRear(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempZoneRear(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .tempZoneUnknown?: try {
      guard case .tempZoneUnknown(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .tempZoneFrontLeft?: try {
      guard case .tempZoneFrontLeft(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tempZoneFrontRight?: try {
      guard case .tempZoneFrontRight(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .tempZoneRear?: try {
      guard case .tempZoneRear(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacTemperatureAdjustmentAction.HvacTemperatureZone, rhs: CarServer_HvacTemperatureAdjustmentAction.HvacTemperatureZone) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_GetNearbyChargingSites: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetNearbyChargingSites"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "include_meta_data"),
    2: .same(proto: "radius"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeMetaData) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.radius) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeMetaData != false {
      try visitor.visitSingularBoolField(value: self.includeMetaData, fieldNumber: 1)
    }
    if self.radius != 0 {
      try visitor.visitSingularInt32Field(value: self.radius, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_GetNearbyChargingSites, rhs: CarServer_GetNearbyChargingSites) -> Bool {
    if lhs.includeMetaData != rhs.includeMetaData {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_NearbyChargingSites: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NearbyChargingSites"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    3: .same(proto: "superchargers"),
    4: .standard(proto: "congestion_sync_time_utc_secs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.superchargers) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.congestionSyncTimeUtcSecs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.superchargers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.superchargers, fieldNumber: 3)
    }
    if self.congestionSyncTimeUtcSecs != 0 {
      try visitor.visitSingularInt64Field(value: self.congestionSyncTimeUtcSecs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_NearbyChargingSites, rhs: CarServer_NearbyChargingSites) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.superchargers != rhs.superchargers {return false}
    if lhs.congestionSyncTimeUtcSecs != rhs.congestionSyncTimeUtcSecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_Superchargers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Superchargers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "amenities"),
    3: .standard(proto: "available_stalls"),
    4: .standard(proto: "billing_info"),
    5: .standard(proto: "billing_time"),
    6: .same(proto: "city"),
    7: .same(proto: "country"),
    8: .standard(proto: "distance_miles"),
    9: .same(proto: "district"),
    10: .same(proto: "location"),
    11: .same(proto: "name"),
    12: .standard(proto: "postal_code"),
    13: .standard(proto: "site_closed"),
    14: .same(proto: "state"),
    15: .standard(proto: "street_address"),
    16: .standard(proto: "total_stalls"),
    17: .standard(proto: "within_range"),
    18: .standard(proto: "max_power_kw"),
    19: .standard(proto: "out_of_order_stalls_number"),
    20: .standard(proto: "out_of_order_stalls_names"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _amenities: String = String()
    var _availableStalls: Int32 = 0
    var _billingInfo: String = String()
    var _billingTime: String = String()
    var _city: String = String()
    var _country: String = String()
    var _distanceMiles: Float = 0
    var _district: String = String()
    var _location: CarServer_LatLong? = nil
    var _name: String = String()
    var _postalCode: String = String()
    var _siteClosed: Bool = false
    var _state: String = String()
    var _streetAddress: String = String()
    var _totalStalls: Int32 = 0
    var _withinRange: Bool = false
    var _maxPowerKw: Int32 = 0
    var _outOfOrderStallsNumber: Int32 = 0
    var _outOfOrderStallsNames: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _amenities = source._amenities
      _availableStalls = source._availableStalls
      _billingInfo = source._billingInfo
      _billingTime = source._billingTime
      _city = source._city
      _country = source._country
      _distanceMiles = source._distanceMiles
      _district = source._district
      _location = source._location
      _name = source._name
      _postalCode = source._postalCode
      _siteClosed = source._siteClosed
      _state = source._state
      _streetAddress = source._streetAddress
      _totalStalls = source._totalStalls
      _withinRange = source._withinRange
      _maxPowerKw = source._maxPowerKw
      _outOfOrderStallsNumber = source._outOfOrderStallsNumber
      _outOfOrderStallsNames = source._outOfOrderStallsNames
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._amenities) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._availableStalls) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._billingInfo) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._billingTime) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._city) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._country) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._distanceMiles) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._district) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._postalCode) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._siteClosed) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._state) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._streetAddress) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._totalStalls) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._withinRange) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._maxPowerKw) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._outOfOrderStallsNumber) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._outOfOrderStallsNames) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._amenities.isEmpty {
        try visitor.visitSingularStringField(value: _storage._amenities, fieldNumber: 2)
      }
      if _storage._availableStalls != 0 {
        try visitor.visitSingularInt32Field(value: _storage._availableStalls, fieldNumber: 3)
      }
      if !_storage._billingInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._billingInfo, fieldNumber: 4)
      }
      if !_storage._billingTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._billingTime, fieldNumber: 5)
      }
      if !_storage._city.isEmpty {
        try visitor.visitSingularStringField(value: _storage._city, fieldNumber: 6)
      }
      if !_storage._country.isEmpty {
        try visitor.visitSingularStringField(value: _storage._country, fieldNumber: 7)
      }
      if _storage._distanceMiles.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._distanceMiles, fieldNumber: 8)
      }
      if !_storage._district.isEmpty {
        try visitor.visitSingularStringField(value: _storage._district, fieldNumber: 9)
      }
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 11)
      }
      if !_storage._postalCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._postalCode, fieldNumber: 12)
      }
      if _storage._siteClosed != false {
        try visitor.visitSingularBoolField(value: _storage._siteClosed, fieldNumber: 13)
      }
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 14)
      }
      if !_storage._streetAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._streetAddress, fieldNumber: 15)
      }
      if _storage._totalStalls != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalStalls, fieldNumber: 16)
      }
      if _storage._withinRange != false {
        try visitor.visitSingularBoolField(value: _storage._withinRange, fieldNumber: 17)
      }
      if _storage._maxPowerKw != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxPowerKw, fieldNumber: 18)
      }
      if _storage._outOfOrderStallsNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._outOfOrderStallsNumber, fieldNumber: 19)
      }
      if !_storage._outOfOrderStallsNames.isEmpty {
        try visitor.visitSingularStringField(value: _storage._outOfOrderStallsNames, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_Superchargers, rhs: CarServer_Superchargers) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._amenities != rhs_storage._amenities {return false}
        if _storage._availableStalls != rhs_storage._availableStalls {return false}
        if _storage._billingInfo != rhs_storage._billingInfo {return false}
        if _storage._billingTime != rhs_storage._billingTime {return false}
        if _storage._city != rhs_storage._city {return false}
        if _storage._country != rhs_storage._country {return false}
        if _storage._distanceMiles != rhs_storage._distanceMiles {return false}
        if _storage._district != rhs_storage._district {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._postalCode != rhs_storage._postalCode {return false}
        if _storage._siteClosed != rhs_storage._siteClosed {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._streetAddress != rhs_storage._streetAddress {return false}
        if _storage._totalStalls != rhs_storage._totalStalls {return false}
        if _storage._withinRange != rhs_storage._withinRange {return false}
        if _storage._maxPowerKw != rhs_storage._maxPowerKw {return false}
        if _storage._outOfOrderStallsNumber != rhs_storage._outOfOrderStallsNumber {return false}
        if _storage._outOfOrderStallsNames != rhs_storage._outOfOrderStallsNames {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_MediaPlayAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaPlayAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_MediaPlayAction, rhs: CarServer_MediaPlayAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_MediaUpdateVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaUpdateVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "volume_delta"),
    3: .standard(proto: "volume_absolute_float"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.mediaVolume != nil {try decoder.handleConflictingOneOf()}
          self.mediaVolume = .volumeDelta(v)
        }
      }()
      case 3: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.mediaVolume != nil {try decoder.handleConflictingOneOf()}
          self.mediaVolume = .volumeAbsoluteFloat(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.mediaVolume {
    case .volumeDelta?: try {
      guard case .volumeDelta(let v)? = self.mediaVolume else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 1)
    }()
    case .volumeAbsoluteFloat?: try {
      guard case .volumeAbsoluteFloat(let v)? = self.mediaVolume else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_MediaUpdateVolume, rhs: CarServer_MediaUpdateVolume) -> Bool {
    if lhs.mediaVolume != rhs.mediaVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_MediaNextFavorite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaNextFavorite"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_MediaNextFavorite, rhs: CarServer_MediaNextFavorite) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_MediaPreviousFavorite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaPreviousFavorite"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_MediaPreviousFavorite, rhs: CarServer_MediaPreviousFavorite) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_MediaNextTrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaNextTrack"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_MediaNextTrack, rhs: CarServer_MediaNextTrack) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_MediaPreviousTrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaPreviousTrack"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_MediaPreviousTrack, rhs: CarServer_MediaPreviousTrack) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlCancelSoftwareUpdateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlCancelSoftwareUpdateAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlCancelSoftwareUpdateAction, rhs: CarServer_VehicleControlCancelSoftwareUpdateAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlFlashLightsAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlFlashLightsAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlFlashLightsAction, rhs: CarServer_VehicleControlFlashLightsAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlHonkHornAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlHonkHornAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlHonkHornAction, rhs: CarServer_VehicleControlHonkHornAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlResetValetPinAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlResetValetPinAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlResetValetPinAction, rhs: CarServer_VehicleControlResetValetPinAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlScheduleSoftwareUpdateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlScheduleSoftwareUpdateAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offset_sec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.offsetSec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offsetSec != 0 {
      try visitor.visitSingularInt32Field(value: self.offsetSec, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlScheduleSoftwareUpdateAction, rhs: CarServer_VehicleControlScheduleSoftwareUpdateAction) -> Bool {
    if lhs.offsetSec != rhs.offsetSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlSetSentryModeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlSetSentryModeAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlSetSentryModeAction, rhs: CarServer_VehicleControlSetSentryModeAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlSetValetModeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlSetValetModeAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlSetValetModeAction, rhs: CarServer_VehicleControlSetValetModeAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlSunroofOpenCloseAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlSunroofOpenCloseAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "absolute_level"),
    2: .standard(proto: "delta_level"),
    3: .same(proto: "vent"),
    4: .same(proto: "close"),
    5: .same(proto: "open"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.sunroofLevel != nil {try decoder.handleConflictingOneOf()}
          self.sunroofLevel = .absoluteLevel(v)
        }
      }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.sunroofLevel != nil {try decoder.handleConflictingOneOf()}
          self.sunroofLevel = .deltaLevel(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .vent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .vent(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .close(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .close(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .open(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .open(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.sunroofLevel {
    case .absoluteLevel?: try {
      guard case .absoluteLevel(let v)? = self.sunroofLevel else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .deltaLevel?: try {
      guard case .deltaLevel(let v)? = self.sunroofLevel else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.action {
    case .vent?: try {
      guard case .vent(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .close?: try {
      guard case .close(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .open?: try {
      guard case .open(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlSunroofOpenCloseAction, rhs: CarServer_VehicleControlSunroofOpenCloseAction) -> Bool {
    if lhs.sunroofLevel != rhs.sunroofLevel {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlTriggerHomelinkAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlTriggerHomelinkAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlTriggerHomelinkAction, rhs: CarServer_VehicleControlTriggerHomelinkAction) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlWindowAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlWindowAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "unknown"),
    3: .same(proto: "vent"),
    4: .same(proto: "close"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .unknown(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .vent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .vent(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .close(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .close(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .unknown?: try {
      guard case .unknown(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .vent?: try {
      guard case .vent(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .close?: try {
      guard case .close(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlWindowAction, rhs: CarServer_VehicleControlWindowAction) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacBioweaponModeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HvacBioweaponModeAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .standard(proto: "manual_override"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.manualOverride) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if self.manualOverride != false {
      try visitor.visitSingularBoolField(value: self.manualOverride, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacBioweaponModeAction, rhs: CarServer_HvacBioweaponModeAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.manualOverride != rhs.manualOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_AutoSeatClimateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutoSeatClimateAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "carseat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.carseat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.carseat.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.carseat, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_AutoSeatClimateAction, rhs: CarServer_AutoSeatClimateAction) -> Bool {
    if lhs.carseat != rhs.carseat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_AutoSeatClimateAction.AutoSeatPosition_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AutoSeatPosition_Unknown"),
    1: .same(proto: "AutoSeatPosition_FrontLeft"),
    2: .same(proto: "AutoSeatPosition_FrontRight"),
  ]
}

extension CarServer_AutoSeatClimateAction.CarSeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_AutoSeatClimateAction.protoMessageName + ".CarSeat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .standard(proto: "seat_position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.seatPosition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if self.seatPosition != .autoSeatPositionUnknown {
      try visitor.visitSingularEnumField(value: self.seatPosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_AutoSeatClimateAction.CarSeat, rhs: CarServer_AutoSeatClimateAction.CarSeat) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.seatPosition != rhs.seatPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ping_id"),
    2: .standard(proto: "local_timestamp"),
    3: .standard(proto: "last_remote_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pingID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._localTimestamp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastRemoteTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pingID != 0 {
      try visitor.visitSingularInt32Field(value: self.pingID, fieldNumber: 1)
    }
    try { if let v = self._localTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastRemoteTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_Ping, rhs: CarServer_Ping) -> Bool {
    if lhs.pingID != rhs.pingID {return false}
    if lhs._localTimestamp != rhs._localTimestamp {return false}
    if lhs._lastRemoteTimestamp != rhs._lastRemoteTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ScheduledChargingAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScheduledChargingAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "charging_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.chargingTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.chargingTime != 0 {
      try visitor.visitSingularInt32Field(value: self.chargingTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ScheduledChargingAction, rhs: CarServer_ScheduledChargingAction) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.chargingTime != rhs.chargingTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ScheduledDepartureAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScheduledDepartureAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "departure_time"),
    3: .standard(proto: "preconditioning_times"),
    4: .standard(proto: "off_peak_charging_times"),
    5: .standard(proto: "off_peak_hours_end_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.departureTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._preconditioningTimes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._offPeakChargingTimes) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.offPeakHoursEndTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.departureTime != 0 {
      try visitor.visitSingularInt32Field(value: self.departureTime, fieldNumber: 2)
    }
    try { if let v = self._preconditioningTimes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._offPeakChargingTimes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.offPeakHoursEndTime != 0 {
      try visitor.visitSingularInt32Field(value: self.offPeakHoursEndTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ScheduledDepartureAction, rhs: CarServer_ScheduledDepartureAction) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.departureTime != rhs.departureTime {return false}
    if lhs._preconditioningTimes != rhs._preconditioningTimes {return false}
    if lhs._offPeakChargingTimes != rhs._offPeakChargingTimes {return false}
    if lhs.offPeakHoursEndTime != rhs.offPeakHoursEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacClimateKeeperAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HvacClimateKeeperAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClimateKeeperAction"),
    2: .standard(proto: "manual_override"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.climateKeeperAction) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.manualOverride) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.climateKeeperAction != .climateKeeperActionOff {
      try visitor.visitSingularEnumField(value: self.climateKeeperAction, fieldNumber: 1)
    }
    if self.manualOverride != false {
      try visitor.visitSingularBoolField(value: self.manualOverride, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_HvacClimateKeeperAction, rhs: CarServer_HvacClimateKeeperAction) -> Bool {
    if lhs.climateKeeperAction != rhs.climateKeeperAction {return false}
    if lhs.manualOverride != rhs.manualOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_HvacClimateKeeperAction.ClimateKeeperAction_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ClimateKeeperAction_Off"),
    1: .same(proto: "ClimateKeeperAction_On"),
    2: .same(proto: "ClimateKeeperAction_Dog"),
    3: .same(proto: "ClimateKeeperAction_Camp"),
  ]
}

extension CarServer_SetChargingAmpsAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetChargingAmpsAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "charging_amps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.chargingAmps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargingAmps != 0 {
      try visitor.visitSingularInt32Field(value: self.chargingAmps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_SetChargingAmpsAction, rhs: CarServer_SetChargingAmpsAction) -> Bool {
    if lhs.chargingAmps != rhs.chargingAmps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_RemoveChargeScheduleAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveChargeScheduleAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_RemoveChargeScheduleAction, rhs: CarServer_RemoveChargeScheduleAction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_BatchRemoveChargeSchedulesAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchRemoveChargeSchedulesAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "home"),
    2: .same(proto: "work"),
    3: .same(proto: "other"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.home) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.work) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.other) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.home != false {
      try visitor.visitSingularBoolField(value: self.home, fieldNumber: 1)
    }
    if self.work != false {
      try visitor.visitSingularBoolField(value: self.work, fieldNumber: 2)
    }
    if self.other != false {
      try visitor.visitSingularBoolField(value: self.other, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_BatchRemoveChargeSchedulesAction, rhs: CarServer_BatchRemoveChargeSchedulesAction) -> Bool {
    if lhs.home != rhs.home {return false}
    if lhs.work != rhs.work {return false}
    if lhs.other != rhs.other {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_BatchRemovePreconditionSchedulesAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchRemovePreconditionSchedulesAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "home"),
    2: .same(proto: "work"),
    3: .same(proto: "other"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.home) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.work) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.other) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.home != false {
      try visitor.visitSingularBoolField(value: self.home, fieldNumber: 1)
    }
    if self.work != false {
      try visitor.visitSingularBoolField(value: self.work, fieldNumber: 2)
    }
    if self.other != false {
      try visitor.visitSingularBoolField(value: self.other, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_BatchRemovePreconditionSchedulesAction, rhs: CarServer_BatchRemovePreconditionSchedulesAction) -> Bool {
    if lhs.home != rhs.home {return false}
    if lhs.work != rhs.work {return false}
    if lhs.other != rhs.other {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_RemovePreconditionScheduleAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemovePreconditionScheduleAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_RemovePreconditionScheduleAction, rhs: CarServer_RemovePreconditionScheduleAction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_SetCabinOverheatProtectionAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetCabinOverheatProtectionAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .standard(proto: "fan_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.fanOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if self.fanOnly != false {
      try visitor.visitSingularBoolField(value: self.fanOnly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_SetCabinOverheatProtectionAction, rhs: CarServer_SetCabinOverheatProtectionAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.fanOnly != rhs.fanOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_SetVehicleNameAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetVehicleNameAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vehicleName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicleName.isEmpty {
      try visitor.visitSingularStringField(value: self.vehicleName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_SetVehicleNameAction, rhs: CarServer_SetVehicleNameAction) -> Bool {
    if lhs.vehicleName != rhs.vehicleName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargePortDoorClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargePortDoorClose"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargePortDoorClose, rhs: CarServer_ChargePortDoorClose) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargePortDoorOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargePortDoorOpen"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargePortDoorOpen, rhs: CarServer_ChargePortDoorOpen) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_SetCopTempAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetCopTempAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "copActivationTemp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.copActivationTemp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.copActivationTemp != .unspecified {
      try visitor.visitSingularEnumField(value: self.copActivationTemp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_SetCopTempAction, rhs: CarServer_SetCopTempAction) -> Bool {
    if lhs.copActivationTemp != rhs.copActivationTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlSetPinToDriveAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlSetPinToDriveAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlSetPinToDriveAction, rhs: CarServer_VehicleControlSetPinToDriveAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleControlResetPinToDriveAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleControlResetPinToDriveAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleControlResetPinToDriveAction, rhs: CarServer_VehicleControlResetPinToDriveAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
