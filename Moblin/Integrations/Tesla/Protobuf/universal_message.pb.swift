// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: universal_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum UniversalMessage_Domain: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case broadcast // = 0
  case vehicleSecurity // = 2
  case infotainment // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .broadcast
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .broadcast
    case 2: self = .vehicleSecurity
    case 3: self = .infotainment
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .broadcast: return 0
    case .vehicleSecurity: return 2
    case .infotainment: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UniversalMessage_Domain] = [
    .broadcast,
    .vehicleSecurity,
    .infotainment,
  ]

}

enum UniversalMessage_OperationStatus_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case operationstatusOk // = 0
  case operationstatusWait // = 1
  case rror // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .operationstatusOk
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .operationstatusOk
    case 1: self = .operationstatusWait
    case 2: self = .rror
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .operationstatusOk: return 0
    case .operationstatusWait: return 1
    case .rror: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UniversalMessage_OperationStatus_E] = [
    .operationstatusOk,
    .operationstatusWait,
    .rror,
  ]

}

enum UniversalMessage_MessageFault_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Request succeeded.
  case rrorNone // = 0

  /// Required vehicle subsystem is busy. Try again.
  case rrorBusy // = 1

  /// Vehicle subsystem did not respond. Try again.
  case rrorTimeout // = 2

  /// Vehicle did not recognize the key used to authorize command. Make sure your key is paired with the vehicle.
  case rrorUnknownKeyID // = 3

  /// Key used to authorize command has been disabled.
  case rrorInactiveKey // = 4

  /// Command signature/MAC is incorrect. Use included session info to update session and try again.
  case rrorInvalidSignature // = 5

  /// Command anti-replay counter has been used before. Use included session info to update session and try again.
  case rrorInvalidTokenOrCounter // = 6

  /// User is not authorized to execute command. This can be because of the role or because of vehicle state.
  case rrorInsufficientPrivileges // = 7

  /// Command was malformed or addressed to an unrecognized vehicle system. May indicate client error or older vehicle firmware.
  case rrorInvalidDomains // = 8

  /// Unrecognized command. May indicate client error or unsupported vehicle firmware.
  case rrorInvalidCommand // = 9

  /// Could not parse command. Indicates client error.
  case rrorDecoding // = 10

  /// Internal vehicle error. Try again. Most commonly encountered when the vehicle has not finished booting.
  case rrorInternal // = 11

  /// Command sent to wrong VIN.
  case rrorWrongPersonalization // = 12

  /// Command was malformed or used a deprecated parameter.
  case rrorBadParameter // = 13

  /// Vehicle's keychain is full. You must delete a key before you can add another.
  case rrorKeychainIsFull // = 14

  /// Session ID mismatch. Use included session info to update session and try again.
  case rrorIncorrectEpoch // = 15

  /// Initialization Value length is incorrect (AES-GCM must use 12-byte IVs). Indicates a client programming error.
  case rrorIvIncorrectLength // = 16

  /// Command expired. Use included session info to determine if clocks have desynchronized and try again.
  case rrorTimeExpired // = 17

  /// Vehicle has not been provisioned with a VIN and may require service.
  case rrorNotProvisionedWithIdentity // = 18

  /// Internal vehicle error.
  case rrorCouldNotHashMetadata // = 19

  /// Vehicle rejected command because its expiration time was too far in the future. This is a security precaution.
  case rrorTimeToLiveTooLong // = 20

  /// The vehicle owner has disabled Mobile access.
  case rrorRemoteAccessDisabled // = 21

  /// The command was authorized with a Service key, but the vehicle has not been configured to permit remote service commands.
  case rrorRemoteServiceAccessDisabled // = 22

  /// The command requires proof of Tesla account credentials but was not sent over a channel that provides this proof. Resend the command using Fleet API.
  case rrorCommandRequiresAccountCredentials // = 23

  /// Client sent a request with a field that exceeds MTU
  case rrorRequestMtuExceeded // = 24

  /// Client's request was received, but response size exceeded MTU
  case rrorResponseMtuExceeded // = 25
  case rrorRepeatedCounter // = 26
  case rrorInvalidKeyHandle // = 27
  case rrorRequiresResponseEncryption // = 28
  case UNRECOGNIZED(Int)

  init() {
    self = .rrorNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rrorNone
    case 1: self = .rrorBusy
    case 2: self = .rrorTimeout
    case 3: self = .rrorUnknownKeyID
    case 4: self = .rrorInactiveKey
    case 5: self = .rrorInvalidSignature
    case 6: self = .rrorInvalidTokenOrCounter
    case 7: self = .rrorInsufficientPrivileges
    case 8: self = .rrorInvalidDomains
    case 9: self = .rrorInvalidCommand
    case 10: self = .rrorDecoding
    case 11: self = .rrorInternal
    case 12: self = .rrorWrongPersonalization
    case 13: self = .rrorBadParameter
    case 14: self = .rrorKeychainIsFull
    case 15: self = .rrorIncorrectEpoch
    case 16: self = .rrorIvIncorrectLength
    case 17: self = .rrorTimeExpired
    case 18: self = .rrorNotProvisionedWithIdentity
    case 19: self = .rrorCouldNotHashMetadata
    case 20: self = .rrorTimeToLiveTooLong
    case 21: self = .rrorRemoteAccessDisabled
    case 22: self = .rrorRemoteServiceAccessDisabled
    case 23: self = .rrorCommandRequiresAccountCredentials
    case 24: self = .rrorRequestMtuExceeded
    case 25: self = .rrorResponseMtuExceeded
    case 26: self = .rrorRepeatedCounter
    case 27: self = .rrorInvalidKeyHandle
    case 28: self = .rrorRequiresResponseEncryption
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rrorNone: return 0
    case .rrorBusy: return 1
    case .rrorTimeout: return 2
    case .rrorUnknownKeyID: return 3
    case .rrorInactiveKey: return 4
    case .rrorInvalidSignature: return 5
    case .rrorInvalidTokenOrCounter: return 6
    case .rrorInsufficientPrivileges: return 7
    case .rrorInvalidDomains: return 8
    case .rrorInvalidCommand: return 9
    case .rrorDecoding: return 10
    case .rrorInternal: return 11
    case .rrorWrongPersonalization: return 12
    case .rrorBadParameter: return 13
    case .rrorKeychainIsFull: return 14
    case .rrorIncorrectEpoch: return 15
    case .rrorIvIncorrectLength: return 16
    case .rrorTimeExpired: return 17
    case .rrorNotProvisionedWithIdentity: return 18
    case .rrorCouldNotHashMetadata: return 19
    case .rrorTimeToLiveTooLong: return 20
    case .rrorRemoteAccessDisabled: return 21
    case .rrorRemoteServiceAccessDisabled: return 22
    case .rrorCommandRequiresAccountCredentials: return 23
    case .rrorRequestMtuExceeded: return 24
    case .rrorResponseMtuExceeded: return 25
    case .rrorRepeatedCounter: return 26
    case .rrorInvalidKeyHandle: return 27
    case .rrorRequiresResponseEncryption: return 28
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UniversalMessage_MessageFault_E] = [
    .rrorNone,
    .rrorBusy,
    .rrorTimeout,
    .rrorUnknownKeyID,
    .rrorInactiveKey,
    .rrorInvalidSignature,
    .rrorInvalidTokenOrCounter,
    .rrorInsufficientPrivileges,
    .rrorInvalidDomains,
    .rrorInvalidCommand,
    .rrorDecoding,
    .rrorInternal,
    .rrorWrongPersonalization,
    .rrorBadParameter,
    .rrorKeychainIsFull,
    .rrorIncorrectEpoch,
    .rrorIvIncorrectLength,
    .rrorTimeExpired,
    .rrorNotProvisionedWithIdentity,
    .rrorCouldNotHashMetadata,
    .rrorTimeToLiveTooLong,
    .rrorRemoteAccessDisabled,
    .rrorRemoteServiceAccessDisabled,
    .rrorCommandRequiresAccountCredentials,
    .rrorRequestMtuExceeded,
    .rrorResponseMtuExceeded,
    .rrorRepeatedCounter,
    .rrorInvalidKeyHandle,
    .rrorRequiresResponseEncryption,
  ]

}

enum UniversalMessage_Flags: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case flagUserCommand // = 0
  case flagEncryptResponse // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .flagUserCommand
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .flagUserCommand
    case 1: self = .flagEncryptResponse
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .flagUserCommand: return 0
    case .flagEncryptResponse: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UniversalMessage_Flags] = [
    .flagUserCommand,
    .flagEncryptResponse,
  ]

}

struct UniversalMessage_Destination: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subDestination: UniversalMessage_Destination.OneOf_SubDestination? = nil

  var domain: UniversalMessage_Domain {
    get {
      if case .domain(let v)? = subDestination {return v}
      return .broadcast
    }
    set {subDestination = .domain(newValue)}
  }

  var routingAddress: Data {
    get {
      if case .routingAddress(let v)? = subDestination {return v}
      return Data()
    }
    set {subDestination = .routingAddress(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubDestination: Equatable, Sendable {
    case domain(UniversalMessage_Domain)
    case routingAddress(Data)

  }

  init() {}
}

struct UniversalMessage_MessageStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operationStatus: UniversalMessage_OperationStatus_E = .operationstatusOk

  var signedMessageFault: UniversalMessage_MessageFault_E = .rrorNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UniversalMessage_SessionInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data = Data()

  var challenge: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UniversalMessage_RoutableMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var toDestination: UniversalMessage_Destination {
    get {return _toDestination ?? UniversalMessage_Destination()}
    set {_toDestination = newValue}
  }
  /// Returns true if `toDestination` has been explicitly set.
  var hasToDestination: Bool {return self._toDestination != nil}
  /// Clears the value of `toDestination`. Subsequent reads from it will return its default value.
  mutating func clearToDestination() {self._toDestination = nil}

  var fromDestination: UniversalMessage_Destination {
    get {return _fromDestination ?? UniversalMessage_Destination()}
    set {_fromDestination = newValue}
  }
  /// Returns true if `fromDestination` has been explicitly set.
  var hasFromDestination: Bool {return self._fromDestination != nil}
  /// Clears the value of `fromDestination`. Subsequent reads from it will return its default value.
  mutating func clearFromDestination() {self._fromDestination = nil}

  var payload: UniversalMessage_RoutableMessage.OneOf_Payload? = nil

  var protobufMessageAsBytes: Data {
    get {
      if case .protobufMessageAsBytes(let v)? = payload {return v}
      return Data()
    }
    set {payload = .protobufMessageAsBytes(newValue)}
  }

  var sessionInfoRequest: UniversalMessage_SessionInfoRequest {
    get {
      if case .sessionInfoRequest(let v)? = payload {return v}
      return UniversalMessage_SessionInfoRequest()
    }
    set {payload = .sessionInfoRequest(newValue)}
  }

  var sessionInfo: Data {
    get {
      if case .sessionInfo(let v)? = payload {return v}
      return Data()
    }
    set {payload = .sessionInfo(newValue)}
  }

  var subSigData: UniversalMessage_RoutableMessage.OneOf_SubSigData? = nil

  var signatureData: Signatures_SignatureData {
    get {
      if case .signatureData(let v)? = subSigData {return v}
      return Signatures_SignatureData()
    }
    set {subSigData = .signatureData(newValue)}
  }

  var signedMessageStatus: UniversalMessage_MessageStatus {
    get {return _signedMessageStatus ?? UniversalMessage_MessageStatus()}
    set {_signedMessageStatus = newValue}
  }
  /// Returns true if `signedMessageStatus` has been explicitly set.
  var hasSignedMessageStatus: Bool {return self._signedMessageStatus != nil}
  /// Clears the value of `signedMessageStatus`. Subsequent reads from it will return its default value.
  mutating func clearSignedMessageStatus() {self._signedMessageStatus = nil}

  var requestUuid: Data = Data()

  var uuid: Data = Data()

  var flags: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    case protobufMessageAsBytes(Data)
    case sessionInfoRequest(UniversalMessage_SessionInfoRequest)
    case sessionInfo(Data)

  }

  enum OneOf_SubSigData: Equatable, Sendable {
    case signatureData(Signatures_SignatureData)

  }

  init() {}

  fileprivate var _toDestination: UniversalMessage_Destination? = nil
  fileprivate var _fromDestination: UniversalMessage_Destination? = nil
  fileprivate var _signedMessageStatus: UniversalMessage_MessageStatus? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "UniversalMessage"

extension UniversalMessage_Domain: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DOMAIN_BROADCAST\0\u{2}\u{2}DOMAIN_VEHICLE_SECURITY\0\u{1}DOMAIN_INFOTAINMENT\0")
}

extension UniversalMessage_OperationStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OPERATIONSTATUS_OK\0\u{1}OPERATIONSTATUS_WAIT\0\u{1}OPERATIONSTATUS_ERROR\0")
}

extension UniversalMessage_MessageFault_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MESSAGEFAULT_ERROR_NONE\0\u{1}MESSAGEFAULT_ERROR_BUSY\0\u{1}MESSAGEFAULT_ERROR_TIMEOUT\0\u{1}MESSAGEFAULT_ERROR_UNKNOWN_KEY_ID\0\u{1}MESSAGEFAULT_ERROR_INACTIVE_KEY\0\u{1}MESSAGEFAULT_ERROR_INVALID_SIGNATURE\0\u{1}MESSAGEFAULT_ERROR_INVALID_TOKEN_OR_COUNTER\0\u{1}MESSAGEFAULT_ERROR_INSUFFICIENT_PRIVILEGES\0\u{1}MESSAGEFAULT_ERROR_INVALID_DOMAINS\0\u{1}MESSAGEFAULT_ERROR_INVALID_COMMAND\0\u{1}MESSAGEFAULT_ERROR_DECODING\0\u{1}MESSAGEFAULT_ERROR_INTERNAL\0\u{1}MESSAGEFAULT_ERROR_WRONG_PERSONALIZATION\0\u{1}MESSAGEFAULT_ERROR_BAD_PARAMETER\0\u{1}MESSAGEFAULT_ERROR_KEYCHAIN_IS_FULL\0\u{1}MESSAGEFAULT_ERROR_INCORRECT_EPOCH\0\u{1}MESSAGEFAULT_ERROR_IV_INCORRECT_LENGTH\0\u{1}MESSAGEFAULT_ERROR_TIME_EXPIRED\0\u{1}MESSAGEFAULT_ERROR_NOT_PROVISIONED_WITH_IDENTITY\0\u{1}MESSAGEFAULT_ERROR_COULD_NOT_HASH_METADATA\0\u{1}MESSAGEFAULT_ERROR_TIME_TO_LIVE_TOO_LONG\0\u{1}MESSAGEFAULT_ERROR_REMOTE_ACCESS_DISABLED\0\u{1}MESSAGEFAULT_ERROR_REMOTE_SERVICE_ACCESS_DISABLED\0\u{1}MESSAGEFAULT_ERROR_COMMAND_REQUIRES_ACCOUNT_CREDENTIALS\0\u{1}MESSAGEFAULT_ERROR_REQUEST_MTU_EXCEEDED\0\u{1}MESSAGEFAULT_ERROR_RESPONSE_MTU_EXCEEDED\0\u{1}MESSAGEFAULT_ERROR_REPEATED_COUNTER\0\u{1}MESSAGEFAULT_ERROR_INVALID_KEY_HANDLE\0\u{1}MESSAGEFAULT_ERROR_REQUIRES_RESPONSE_ENCRYPTION\0")
}

extension UniversalMessage_Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0FLAG_USER_COMMAND\0\u{1}FLAG_ENCRYPT_RESPONSE\0")
}

extension UniversalMessage_Destination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Destination"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}domain\0\u{3}routing_address\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UniversalMessage_Domain?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subDestination != nil {try decoder.handleConflictingOneOf()}
          self.subDestination = .domain(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subDestination != nil {try decoder.handleConflictingOneOf()}
          self.subDestination = .routingAddress(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subDestination {
    case .domain?: try {
      guard case .domain(let v)? = self.subDestination else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .routingAddress?: try {
      guard case .routingAddress(let v)? = self.subDestination else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UniversalMessage_Destination, rhs: UniversalMessage_Destination) -> Bool {
    if lhs.subDestination != rhs.subDestination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UniversalMessage_MessageStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}operation_status\0\u{3}signed_message_fault\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operationStatus) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.signedMessageFault) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operationStatus != .operationstatusOk {
      try visitor.visitSingularEnumField(value: self.operationStatus, fieldNumber: 1)
    }
    if self.signedMessageFault != .rrorNone {
      try visitor.visitSingularEnumField(value: self.signedMessageFault, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UniversalMessage_MessageStatus, rhs: UniversalMessage_MessageStatus) -> Bool {
    if lhs.operationStatus != rhs.operationStatus {return false}
    if lhs.signedMessageFault != rhs.signedMessageFault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UniversalMessage_SessionInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}public_key\0\u{1}challenge\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.challenge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.challenge.isEmpty {
      try visitor.visitSingularBytesField(value: self.challenge, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UniversalMessage_SessionInfoRequest, rhs: UniversalMessage_SessionInfoRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.challenge != rhs.challenge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UniversalMessage_RoutableMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoutableMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{6}to_destination\0\u{3}from_destination\0\u{4}\u{3}protobuf_message_as_bytes\0\u{2}\u{2}signedMessageStatus\0\u{3}signature_data\0\u{3}session_info_request\0\u{3}session_info\0\u{4}#request_uuid\0\u{1}uuid\0\u{1}flags\0\u{c}\u{1}\u{5}\u{c}\u{10}\u{19}\u{c}\u{b}\u{1}")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 6: try { try decoder.decodeSingularMessageField(value: &self._toDestination) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._fromDestination) }()
      case 10: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .protobufMessageAsBytes(v)
        }
      }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._signedMessageStatus) }()
      case 13: try {
        var v: Signatures_SignatureData?
        var hadOneofValue = false
        if let current = self.subSigData {
          hadOneofValue = true
          if case .signatureData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subSigData = .signatureData(v)
        }
      }()
      case 14: try {
        var v: UniversalMessage_SessionInfoRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .sessionInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .sessionInfoRequest(v)
        }
      }()
      case 15: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .sessionInfo(v)
        }
      }()
      case 50: try { try decoder.decodeSingularBytesField(value: &self.requestUuid) }()
      case 51: try { try decoder.decodeSingularBytesField(value: &self.uuid) }()
      case 52: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._toDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._fromDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if case .protobufMessageAsBytes(let v)? = self.payload {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._signedMessageStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if case .signatureData(let v)? = self.subSigData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    switch self.payload {
    case .sessionInfoRequest?: try {
      guard case .sessionInfoRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .sessionInfo?: try {
      guard case .sessionInfo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 15)
    }()
    default: break
    }
    if !self.requestUuid.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestUuid, fieldNumber: 50)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularBytesField(value: self.uuid, fieldNumber: 51)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 52)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UniversalMessage_RoutableMessage, rhs: UniversalMessage_RoutableMessage) -> Bool {
    if lhs._toDestination != rhs._toDestination {return false}
    if lhs._fromDestination != rhs._fromDestination {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.subSigData != rhs.subSigData {return false}
    if lhs._signedMessageStatus != rhs._signedMessageStatus {return false}
    if lhs.requestUuid != rhs.requestUuid {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
