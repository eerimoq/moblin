// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vehicle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum CarServer_MediaSourceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Standard sources
  case none // = 0
  case am // = 1
  case fm // = 2
  case xm // = 3
  case slacker // = 5
  case localFiles // = 6
  case iPod // = 7
  case bluetooth // = 8
  case auxIn // = 9
  case dab // = 10
  case rdio // = 11
  case spotify // = 12
  case usradio // = 13
  case euradio // = 14
  case mediaFile // = 16

  /// Server-side sources
  case tuneIn // = 17
  case stingray // = 18
  case siriusXm // = 19
  case tidal // = 20
  case qqmusic // = 21
  case qqmusic2 // = 22
  case ximalaya // = 23
  case onlineRadio // = 24
  case onlineRadio2 // = 25
  case netEaseMusic // = 26

  /// Entertainment sources
  case browser // = 28
  case theater // = 29
  case game // = 30
  case tutorial // = 31
  case toybox // = 32
  case recentsFavorites // = 33
  case homeApps // = 34
  case search // = 35
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .am
    case 2: self = .fm
    case 3: self = .xm
    case 5: self = .slacker
    case 6: self = .localFiles
    case 7: self = .iPod
    case 8: self = .bluetooth
    case 9: self = .auxIn
    case 10: self = .dab
    case 11: self = .rdio
    case 12: self = .spotify
    case 13: self = .usradio
    case 14: self = .euradio
    case 16: self = .mediaFile
    case 17: self = .tuneIn
    case 18: self = .stingray
    case 19: self = .siriusXm
    case 20: self = .tidal
    case 21: self = .qqmusic
    case 22: self = .qqmusic2
    case 23: self = .ximalaya
    case 24: self = .onlineRadio
    case 25: self = .onlineRadio2
    case 26: self = .netEaseMusic
    case 28: self = .browser
    case 29: self = .theater
    case 30: self = .game
    case 31: self = .tutorial
    case 32: self = .toybox
    case 33: self = .recentsFavorites
    case 34: self = .homeApps
    case 35: self = .search
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .am: return 1
    case .fm: return 2
    case .xm: return 3
    case .slacker: return 5
    case .localFiles: return 6
    case .iPod: return 7
    case .bluetooth: return 8
    case .auxIn: return 9
    case .dab: return 10
    case .rdio: return 11
    case .spotify: return 12
    case .usradio: return 13
    case .euradio: return 14
    case .mediaFile: return 16
    case .tuneIn: return 17
    case .stingray: return 18
    case .siriusXm: return 19
    case .tidal: return 20
    case .qqmusic: return 21
    case .qqmusic2: return 22
    case .ximalaya: return 23
    case .onlineRadio: return 24
    case .onlineRadio2: return 25
    case .netEaseMusic: return 26
    case .browser: return 28
    case .theater: return 29
    case .game: return 30
    case .tutorial: return 31
    case .toybox: return 32
    case .recentsFavorites: return 33
    case .homeApps: return 34
    case .search: return 35
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [CarServer_MediaSourceType] = [
    .none,
    .am,
    .fm,
    .xm,
    .slacker,
    .localFiles,
    .iPod,
    .bluetooth,
    .auxIn,
    .dab,
    .rdio,
    .spotify,
    .usradio,
    .euradio,
    .mediaFile,
    .tuneIn,
    .stingray,
    .siriusXm,
    .tidal,
    .qqmusic,
    .qqmusic2,
    .ximalaya,
    .onlineRadio,
    .onlineRadio2,
    .netEaseMusic,
    .browser,
    .theater,
    .game,
    .tutorial,
    .toybox,
    .recentsFavorites,
    .homeApps,
    .search,
  ]

}

struct CarServer_VehicleData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeState: CarServer_ChargeState {
    get {return _storage._chargeState ?? CarServer_ChargeState()}
    set {_uniqueStorage()._chargeState = newValue}
  }
  /// Returns true if `chargeState` has been explicitly set.
  var hasChargeState: Bool {return _storage._chargeState != nil}
  /// Clears the value of `chargeState`. Subsequent reads from it will return its default value.
  mutating func clearChargeState() {_uniqueStorage()._chargeState = nil}

  var climateState: CarServer_ClimateState {
    get {return _storage._climateState ?? CarServer_ClimateState()}
    set {_uniqueStorage()._climateState = newValue}
  }
  /// Returns true if `climateState` has been explicitly set.
  var hasClimateState: Bool {return _storage._climateState != nil}
  /// Clears the value of `climateState`. Subsequent reads from it will return its default value.
  mutating func clearClimateState() {_uniqueStorage()._climateState = nil}

  var driveState: CarServer_DriveState {
    get {return _storage._driveState ?? CarServer_DriveState()}
    set {_uniqueStorage()._driveState = newValue}
  }
  /// Returns true if `driveState` has been explicitly set.
  var hasDriveState: Bool {return _storage._driveState != nil}
  /// Clears the value of `driveState`. Subsequent reads from it will return its default value.
  mutating func clearDriveState() {_uniqueStorage()._driveState = nil}

  var locationState: CarServer_LocationState {
    get {return _storage._locationState ?? CarServer_LocationState()}
    set {_uniqueStorage()._locationState = newValue}
  }
  /// Returns true if `locationState` has been explicitly set.
  var hasLocationState: Bool {return _storage._locationState != nil}
  /// Clears the value of `locationState`. Subsequent reads from it will return its default value.
  mutating func clearLocationState() {_uniqueStorage()._locationState = nil}

  var closuresState: CarServer_ClosuresState {
    get {return _storage._closuresState ?? CarServer_ClosuresState()}
    set {_uniqueStorage()._closuresState = newValue}
  }
  /// Returns true if `closuresState` has been explicitly set.
  var hasClosuresState: Bool {return _storage._closuresState != nil}
  /// Clears the value of `closuresState`. Subsequent reads from it will return its default value.
  mutating func clearClosuresState() {_uniqueStorage()._closuresState = nil}

  var chargeScheduleState: CarServer_ChargeScheduleState {
    get {return _storage._chargeScheduleState ?? CarServer_ChargeScheduleState()}
    set {_uniqueStorage()._chargeScheduleState = newValue}
  }
  /// Returns true if `chargeScheduleState` has been explicitly set.
  var hasChargeScheduleState: Bool {return _storage._chargeScheduleState != nil}
  /// Clears the value of `chargeScheduleState`. Subsequent reads from it will return its default value.
  mutating func clearChargeScheduleState() {_uniqueStorage()._chargeScheduleState = nil}

  var preconditioningScheduleState: CarServer_PreconditioningScheduleState {
    get {return _storage._preconditioningScheduleState ?? CarServer_PreconditioningScheduleState()}
    set {_uniqueStorage()._preconditioningScheduleState = newValue}
  }
  /// Returns true if `preconditioningScheduleState` has been explicitly set.
  var hasPreconditioningScheduleState: Bool {return _storage._preconditioningScheduleState != nil}
  /// Clears the value of `preconditioningScheduleState`. Subsequent reads from it will return its default value.
  mutating func clearPreconditioningScheduleState() {_uniqueStorage()._preconditioningScheduleState = nil}

  var tirePressureState: CarServer_TirePressureState {
    get {return _storage._tirePressureState ?? CarServer_TirePressureState()}
    set {_uniqueStorage()._tirePressureState = newValue}
  }
  /// Returns true if `tirePressureState` has been explicitly set.
  var hasTirePressureState: Bool {return _storage._tirePressureState != nil}
  /// Clears the value of `tirePressureState`. Subsequent reads from it will return its default value.
  mutating func clearTirePressureState() {_uniqueStorage()._tirePressureState = nil}

  var mediaState: CarServer_MediaState {
    get {return _storage._mediaState ?? CarServer_MediaState()}
    set {_uniqueStorage()._mediaState = newValue}
  }
  /// Returns true if `mediaState` has been explicitly set.
  var hasMediaState: Bool {return _storage._mediaState != nil}
  /// Clears the value of `mediaState`. Subsequent reads from it will return its default value.
  mutating func clearMediaState() {_uniqueStorage()._mediaState = nil}

  var mediaDetailState: CarServer_MediaDetailState {
    get {return _storage._mediaDetailState ?? CarServer_MediaDetailState()}
    set {_uniqueStorage()._mediaDetailState = newValue}
  }
  /// Returns true if `mediaDetailState` has been explicitly set.
  var hasMediaDetailState: Bool {return _storage._mediaDetailState != nil}
  /// Clears the value of `mediaDetailState`. Subsequent reads from it will return its default value.
  mutating func clearMediaDetailState() {_uniqueStorage()._mediaDetailState = nil}

  var softwareUpdateState: CarServer_SoftwareUpdateState {
    get {return _storage._softwareUpdateState ?? CarServer_SoftwareUpdateState()}
    set {_uniqueStorage()._softwareUpdateState = newValue}
  }
  /// Returns true if `softwareUpdateState` has been explicitly set.
  var hasSoftwareUpdateState: Bool {return _storage._softwareUpdateState != nil}
  /// Clears the value of `softwareUpdateState`. Subsequent reads from it will return its default value.
  mutating func clearSoftwareUpdateState() {_uniqueStorage()._softwareUpdateState = nil}

  var parentalControlsState: CarServer_ParentalControlsState {
    get {return _storage._parentalControlsState ?? CarServer_ParentalControlsState()}
    set {_uniqueStorage()._parentalControlsState = newValue}
  }
  /// Returns true if `parentalControlsState` has been explicitly set.
  var hasParentalControlsState: Bool {return _storage._parentalControlsState != nil}
  /// Clears the value of `parentalControlsState`. Subsequent reads from it will return its default value.
  mutating func clearParentalControlsState() {_uniqueStorage()._parentalControlsState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CarServer_ClosuresState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var optionalDoorOpenDriverFront: OneOf_OptionalDoorOpenDriverFront? {
    get {return _storage._optionalDoorOpenDriverFront}
    set {_uniqueStorage()._optionalDoorOpenDriverFront = newValue}
  }

  var doorOpenDriverFront: Bool {
    get {
      if case .doorOpenDriverFront(let v)? = _storage._optionalDoorOpenDriverFront {return v}
      return false
    }
    set {_uniqueStorage()._optionalDoorOpenDriverFront = .doorOpenDriverFront(newValue)}
  }

  var optionalDoorOpenDriverRear: OneOf_OptionalDoorOpenDriverRear? {
    get {return _storage._optionalDoorOpenDriverRear}
    set {_uniqueStorage()._optionalDoorOpenDriverRear = newValue}
  }

  var doorOpenDriverRear: Bool {
    get {
      if case .doorOpenDriverRear(let v)? = _storage._optionalDoorOpenDriverRear {return v}
      return false
    }
    set {_uniqueStorage()._optionalDoorOpenDriverRear = .doorOpenDriverRear(newValue)}
  }

  var optionalDoorOpenPassengerFront: OneOf_OptionalDoorOpenPassengerFront? {
    get {return _storage._optionalDoorOpenPassengerFront}
    set {_uniqueStorage()._optionalDoorOpenPassengerFront = newValue}
  }

  var doorOpenPassengerFront: Bool {
    get {
      if case .doorOpenPassengerFront(let v)? = _storage._optionalDoorOpenPassengerFront {return v}
      return false
    }
    set {_uniqueStorage()._optionalDoorOpenPassengerFront = .doorOpenPassengerFront(newValue)}
  }

  var optionalDoorOpenPassengerRear: OneOf_OptionalDoorOpenPassengerRear? {
    get {return _storage._optionalDoorOpenPassengerRear}
    set {_uniqueStorage()._optionalDoorOpenPassengerRear = newValue}
  }

  var doorOpenPassengerRear: Bool {
    get {
      if case .doorOpenPassengerRear(let v)? = _storage._optionalDoorOpenPassengerRear {return v}
      return false
    }
    set {_uniqueStorage()._optionalDoorOpenPassengerRear = .doorOpenPassengerRear(newValue)}
  }

  var optionalDoorOpenTrunkFront: OneOf_OptionalDoorOpenTrunkFront? {
    get {return _storage._optionalDoorOpenTrunkFront}
    set {_uniqueStorage()._optionalDoorOpenTrunkFront = newValue}
  }

  var doorOpenTrunkFront: Bool {
    get {
      if case .doorOpenTrunkFront(let v)? = _storage._optionalDoorOpenTrunkFront {return v}
      return false
    }
    set {_uniqueStorage()._optionalDoorOpenTrunkFront = .doorOpenTrunkFront(newValue)}
  }

  var optionalDoorOpenTrunkRear: OneOf_OptionalDoorOpenTrunkRear? {
    get {return _storage._optionalDoorOpenTrunkRear}
    set {_uniqueStorage()._optionalDoorOpenTrunkRear = newValue}
  }

  var doorOpenTrunkRear: Bool {
    get {
      if case .doorOpenTrunkRear(let v)? = _storage._optionalDoorOpenTrunkRear {return v}
      return false
    }
    set {_uniqueStorage()._optionalDoorOpenTrunkRear = .doorOpenTrunkRear(newValue)}
  }

  var optionalWindowOpenDriverFront: OneOf_OptionalWindowOpenDriverFront? {
    get {return _storage._optionalWindowOpenDriverFront}
    set {_uniqueStorage()._optionalWindowOpenDriverFront = newValue}
  }

  var windowOpenDriverFront: Bool {
    get {
      if case .windowOpenDriverFront(let v)? = _storage._optionalWindowOpenDriverFront {return v}
      return false
    }
    set {_uniqueStorage()._optionalWindowOpenDriverFront = .windowOpenDriverFront(newValue)}
  }

  var optionalWindowOpenPassengerFront: OneOf_OptionalWindowOpenPassengerFront? {
    get {return _storage._optionalWindowOpenPassengerFront}
    set {_uniqueStorage()._optionalWindowOpenPassengerFront = newValue}
  }

  var windowOpenPassengerFront: Bool {
    get {
      if case .windowOpenPassengerFront(let v)? = _storage._optionalWindowOpenPassengerFront {return v}
      return false
    }
    set {_uniqueStorage()._optionalWindowOpenPassengerFront = .windowOpenPassengerFront(newValue)}
  }

  var optionalWindowOpenDriverRear: OneOf_OptionalWindowOpenDriverRear? {
    get {return _storage._optionalWindowOpenDriverRear}
    set {_uniqueStorage()._optionalWindowOpenDriverRear = newValue}
  }

  var windowOpenDriverRear: Bool {
    get {
      if case .windowOpenDriverRear(let v)? = _storage._optionalWindowOpenDriverRear {return v}
      return false
    }
    set {_uniqueStorage()._optionalWindowOpenDriverRear = .windowOpenDriverRear(newValue)}
  }

  var optionalWindowOpenPassengerRear: OneOf_OptionalWindowOpenPassengerRear? {
    get {return _storage._optionalWindowOpenPassengerRear}
    set {_uniqueStorage()._optionalWindowOpenPassengerRear = newValue}
  }

  var windowOpenPassengerRear: Bool {
    get {
      if case .windowOpenPassengerRear(let v)? = _storage._optionalWindowOpenPassengerRear {return v}
      return false
    }
    set {_uniqueStorage()._optionalWindowOpenPassengerRear = .windowOpenPassengerRear(newValue)}
  }

  /// only set when sunroof installed
  var sunRoofState: CarServer_ClosuresState.SunRoofState {
    get {return _storage._sunRoofState ?? CarServer_ClosuresState.SunRoofState()}
    set {_uniqueStorage()._sunRoofState = newValue}
  }
  /// Returns true if `sunRoofState` has been explicitly set.
  var hasSunRoofState: Bool {return _storage._sunRoofState != nil}
  /// Clears the value of `sunRoofState`. Subsequent reads from it will return its default value.
  mutating func clearSunRoofState() {_uniqueStorage()._sunRoofState = nil}

  var optionalSunRoofPercentOpen: OneOf_OptionalSunRoofPercentOpen? {
    get {return _storage._optionalSunRoofPercentOpen}
    set {_uniqueStorage()._optionalSunRoofPercentOpen = newValue}
  }

  var sunRoofPercentOpen: Int32 {
    get {
      if case .sunRoofPercentOpen(let v)? = _storage._optionalSunRoofPercentOpen {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSunRoofPercentOpen = .sunRoofPercentOpen(newValue)}
  }

  var optionalLocked: OneOf_OptionalLocked? {
    get {return _storage._optionalLocked}
    set {_uniqueStorage()._optionalLocked = newValue}
  }

  var locked: Bool {
    get {
      if case .locked(let v)? = _storage._optionalLocked {return v}
      return false
    }
    set {_uniqueStorage()._optionalLocked = .locked(newValue)}
  }

  var optionalIsUserPresent: OneOf_OptionalIsUserPresent? {
    get {return _storage._optionalIsUserPresent}
    set {_uniqueStorage()._optionalIsUserPresent = newValue}
  }

  var isUserPresent: Bool {
    get {
      if case .isUserPresent(let v)? = _storage._optionalIsUserPresent {return v}
      return false
    }
    set {_uniqueStorage()._optionalIsUserPresent = .isUserPresent(newValue)}
  }

  var centerDisplayState: CarServer_ClosuresState.DisplayState {
    get {return _storage._centerDisplayState ?? CarServer_ClosuresState.DisplayState()}
    set {_uniqueStorage()._centerDisplayState = newValue}
  }
  /// Returns true if `centerDisplayState` has been explicitly set.
  var hasCenterDisplayState: Bool {return _storage._centerDisplayState != nil}
  /// Clears the value of `centerDisplayState`. Subsequent reads from it will return its default value.
  mutating func clearCenterDisplayState() {_uniqueStorage()._centerDisplayState = nil}

  /// `true` when remote start is active.
  var optionalRemoteStart: OneOf_OptionalRemoteStart? {
    get {return _storage._optionalRemoteStart}
    set {_uniqueStorage()._optionalRemoteStart = newValue}
  }

  var remoteStart: Bool {
    get {
      if case .remoteStart(let v)? = _storage._optionalRemoteStart {return v}
      return false
    }
    set {_uniqueStorage()._optionalRemoteStart = .remoteStart(newValue)}
  }

  var optionalValetMode: OneOf_OptionalValetMode? {
    get {return _storage._optionalValetMode}
    set {_uniqueStorage()._optionalValetMode = newValue}
  }

  var valetMode: Bool {
    get {
      if case .valetMode(let v)? = _storage._optionalValetMode {return v}
      return false
    }
    set {_uniqueStorage()._optionalValetMode = .valetMode(newValue)}
  }

  var optionalValetPinNeeded: OneOf_OptionalValetPinNeeded? {
    get {return _storage._optionalValetPinNeeded}
    set {_uniqueStorage()._optionalValetPinNeeded = newValue}
  }

  var valetPinNeeded: Bool {
    get {
      if case .valetPinNeeded(let v)? = _storage._optionalValetPinNeeded {return v}
      return false
    }
    set {_uniqueStorage()._optionalValetPinNeeded = .valetPinNeeded(newValue)}
  }

  /// only set when sentry mode supported
  var sentryModeState: CarServer_ClosuresState.SentryModeState {
    get {return _storage._sentryModeState ?? CarServer_ClosuresState.SentryModeState()}
    set {_uniqueStorage()._sentryModeState = newValue}
  }
  /// Returns true if `sentryModeState` has been explicitly set.
  var hasSentryModeState: Bool {return _storage._sentryModeState != nil}
  /// Clears the value of `sentryModeState`. Subsequent reads from it will return its default value.
  mutating func clearSentryModeState() {_uniqueStorage()._sentryModeState = nil}

  var optionalSentryModeAvailable: OneOf_OptionalSentryModeAvailable? {
    get {return _storage._optionalSentryModeAvailable}
    set {_uniqueStorage()._optionalSentryModeAvailable = newValue}
  }

  var sentryModeAvailable: Bool {
    get {
      if case .sentryModeAvailable(let v)? = _storage._optionalSentryModeAvailable {return v}
      return false
    }
    set {_uniqueStorage()._optionalSentryModeAvailable = .sentryModeAvailable(newValue)}
  }

  /// only set when speed limit mode supported
  var speedLimitMode: CarServer_SpeedLimitMode {
    get {return _storage._speedLimitMode ?? CarServer_SpeedLimitMode()}
    set {_uniqueStorage()._speedLimitMode = newValue}
  }
  /// Returns true if `speedLimitMode` has been explicitly set.
  var hasSpeedLimitMode: Bool {return _storage._speedLimitMode != nil}
  /// Clears the value of `speedLimitMode`. Subsequent reads from it will return its default value.
  mutating func clearSpeedLimitMode() {_uniqueStorage()._speedLimitMode = nil}

  var optionalTonneauState: OneOf_OptionalTonneauState? {
    get {return _storage._optionalTonneauState}
    set {_uniqueStorage()._optionalTonneauState = newValue}
  }

  var tonneauState: VCSEC_ClosureState_E {
    get {
      if case .tonneauState(let v)? = _storage._optionalTonneauState {return v}
      return .closurestateClosed
    }
    set {_uniqueStorage()._optionalTonneauState = .tonneauState(newValue)}
  }

  var optionalTonneauPercentOpen: OneOf_OptionalTonneauPercentOpen? {
    get {return _storage._optionalTonneauPercentOpen}
    set {_uniqueStorage()._optionalTonneauPercentOpen = newValue}
  }

  var tonneauPercentOpen: UInt32 {
    get {
      if case .tonneauPercentOpen(let v)? = _storage._optionalTonneauPercentOpen {return v}
      return 0
    }
    set {_uniqueStorage()._optionalTonneauPercentOpen = .tonneauPercentOpen(newValue)}
  }

  var optionalTonneauInMotion: OneOf_OptionalTonneauInMotion? {
    get {return _storage._optionalTonneauInMotion}
    set {_uniqueStorage()._optionalTonneauInMotion = newValue}
  }

  var tonneauInMotion: Bool {
    get {
      if case .tonneauInMotion(let v)? = _storage._optionalTonneauInMotion {return v}
      return false
    }
    set {_uniqueStorage()._optionalTonneauInMotion = .tonneauInMotion(newValue)}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalDoorOpenDriverFront: Equatable, Sendable {
    case doorOpenDriverFront(Bool)

  }

  enum OneOf_OptionalDoorOpenDriverRear: Equatable, Sendable {
    case doorOpenDriverRear(Bool)

  }

  enum OneOf_OptionalDoorOpenPassengerFront: Equatable, Sendable {
    case doorOpenPassengerFront(Bool)

  }

  enum OneOf_OptionalDoorOpenPassengerRear: Equatable, Sendable {
    case doorOpenPassengerRear(Bool)

  }

  enum OneOf_OptionalDoorOpenTrunkFront: Equatable, Sendable {
    case doorOpenTrunkFront(Bool)

  }

  enum OneOf_OptionalDoorOpenTrunkRear: Equatable, Sendable {
    case doorOpenTrunkRear(Bool)

  }

  enum OneOf_OptionalWindowOpenDriverFront: Equatable, Sendable {
    case windowOpenDriverFront(Bool)

  }

  enum OneOf_OptionalWindowOpenPassengerFront: Equatable, Sendable {
    case windowOpenPassengerFront(Bool)

  }

  enum OneOf_OptionalWindowOpenDriverRear: Equatable, Sendable {
    case windowOpenDriverRear(Bool)

  }

  enum OneOf_OptionalWindowOpenPassengerRear: Equatable, Sendable {
    case windowOpenPassengerRear(Bool)

  }

  enum OneOf_OptionalSunRoofPercentOpen: Equatable, Sendable {
    case sunRoofPercentOpen(Int32)

  }

  enum OneOf_OptionalLocked: Equatable, Sendable {
    case locked(Bool)

  }

  enum OneOf_OptionalIsUserPresent: Equatable, Sendable {
    case isUserPresent(Bool)

  }

  /// `true` when remote start is active.
  enum OneOf_OptionalRemoteStart: Equatable, Sendable {
    case remoteStart(Bool)

  }

  enum OneOf_OptionalValetMode: Equatable, Sendable {
    case valetMode(Bool)

  }

  enum OneOf_OptionalValetPinNeeded: Equatable, Sendable {
    case valetPinNeeded(Bool)

  }

  enum OneOf_OptionalSentryModeAvailable: Equatable, Sendable {
    case sentryModeAvailable(Bool)

  }

  enum OneOf_OptionalTonneauState: Equatable, Sendable {
    case tonneauState(VCSEC_ClosureState_E)

  }

  enum OneOf_OptionalTonneauPercentOpen: Equatable, Sendable {
    case tonneauPercentOpen(UInt32)

  }

  enum OneOf_OptionalTonneauInMotion: Equatable, Sendable {
    case tonneauInMotion(Bool)

  }

  struct SunRoofState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_ClosuresState.SunRoofState.OneOf_Type? = nil

    var unknown: CarServer_Void {
      get {
        if case .unknown(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .unknown(newValue)}
    }

    var calibrating: CarServer_Void {
      get {
        if case .calibrating(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .calibrating(newValue)}
    }

    var closed: CarServer_Void {
      get {
        if case .closed(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .closed(newValue)}
    }

    var `open`: CarServer_Void {
      get {
        if case .open(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .open(newValue)}
    }

    var moving: CarServer_Void {
      get {
        if case .moving(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .moving(newValue)}
    }

    var vent: CarServer_Void {
      get {
        if case .vent(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .vent(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case unknown(CarServer_Void)
      case calibrating(CarServer_Void)
      case closed(CarServer_Void)
      case `open`(CarServer_Void)
      case moving(CarServer_Void)
      case vent(CarServer_Void)

    }

    init() {}
  }

  struct DisplayState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_ClosuresState.DisplayState.OneOf_Type? = nil

    var off: CarServer_Void {
      get {
        if case .off(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .off(newValue)}
    }

    var dim: CarServer_Void {
      get {
        if case .dim(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .dim(newValue)}
    }

    var accessory: CarServer_Void {
      get {
        if case .accessory(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .accessory(newValue)}
    }

    var on: CarServer_Void {
      get {
        if case .on(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .on(newValue)}
    }

    var driving: CarServer_Void {
      get {
        if case .driving(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .driving(newValue)}
    }

    var charging: CarServer_Void {
      get {
        if case .charging(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .charging(newValue)}
    }

    var lock: CarServer_Void {
      get {
        if case .lock(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .lock(newValue)}
    }

    var sentry: CarServer_Void {
      get {
        if case .sentry(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .sentry(newValue)}
    }

    var dog: CarServer_Void {
      get {
        if case .dog(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .dog(newValue)}
    }

    var entertainment: CarServer_Void {
      get {
        if case .entertainment(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .entertainment(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case off(CarServer_Void)
      case dim(CarServer_Void)
      case accessory(CarServer_Void)
      case on(CarServer_Void)
      case driving(CarServer_Void)
      case charging(CarServer_Void)
      case lock(CarServer_Void)
      case sentry(CarServer_Void)
      case dog(CarServer_Void)
      case entertainment(CarServer_Void)

    }

    init() {}
  }

  struct SentryModeState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_ClosuresState.SentryModeState.OneOf_Type? = nil

    var off: CarServer_Void {
      get {
        if case .off(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .off(newValue)}
    }

    var idle: CarServer_Void {
      get {
        if case .idle(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .idle(newValue)}
    }

    var armed: CarServer_Void {
      get {
        if case .armed(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .armed(newValue)}
    }

    var aware: CarServer_Void {
      get {
        if case .aware(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .aware(newValue)}
    }

    var panic: CarServer_Void {
      get {
        if case .panic(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .panic(newValue)}
    }

    var quiet: CarServer_Void {
      get {
        if case .quiet(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .quiet(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case off(CarServer_Void)
      case idle(CarServer_Void)
      case armed(CarServer_Void)
      case aware(CarServer_Void)
      case panic(CarServer_Void)
      case quiet(CarServer_Void)

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CarServer_ChargeScheduleState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeSchedules: [CarServer_ChargeSchedule] {
    get {return _storage._chargeSchedules}
    set {_uniqueStorage()._chargeSchedules = newValue}
  }

  var optionalChargeScheduleWindow: OneOf_OptionalChargeScheduleWindow? {
    get {return _storage._optionalChargeScheduleWindow}
    set {_uniqueStorage()._optionalChargeScheduleWindow = newValue}
  }

  var chargeScheduleWindow: CarServer_ChargeSchedule {
    get {
      if case .chargeScheduleWindow(let v)? = _storage._optionalChargeScheduleWindow {return v}
      return CarServer_ChargeSchedule()
    }
    set {_uniqueStorage()._optionalChargeScheduleWindow = .chargeScheduleWindow(newValue)}
  }

  var optionalChargeBuffer: OneOf_OptionalChargeBuffer? {
    get {return _storage._optionalChargeBuffer}
    set {_uniqueStorage()._optionalChargeBuffer = newValue}
  }

  var chargeBuffer: Int32 {
    get {
      if case .chargeBuffer(let v)? = _storage._optionalChargeBuffer {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeBuffer = .chargeBuffer(newValue)}
  }

  var optionalMaxNumChargeSchedules: OneOf_OptionalMaxNumChargeSchedules? {
    get {return _storage._optionalMaxNumChargeSchedules}
    set {_uniqueStorage()._optionalMaxNumChargeSchedules = newValue}
  }

  var maxNumChargeSchedules: UInt32 {
    get {
      if case .maxNumChargeSchedules(let v)? = _storage._optionalMaxNumChargeSchedules {return v}
      return 0
    }
    set {_uniqueStorage()._optionalMaxNumChargeSchedules = .maxNumChargeSchedules(newValue)}
  }

  var optionalNextSchedule: OneOf_OptionalNextSchedule? {
    get {return _storage._optionalNextSchedule}
    set {_uniqueStorage()._optionalNextSchedule = newValue}
  }

  var nextSchedule: Bool {
    get {
      if case .nextSchedule(let v)? = _storage._optionalNextSchedule {return v}
      return false
    }
    set {_uniqueStorage()._optionalNextSchedule = .nextSchedule(newValue)}
  }

  var optionalShowScheduleCompleteState: OneOf_OptionalShowScheduleCompleteState? {
    get {return _storage._optionalShowScheduleCompleteState}
    set {_uniqueStorage()._optionalShowScheduleCompleteState = newValue}
  }

  var showScheduleCompleteState: Bool {
    get {
      if case .showScheduleCompleteState(let v)? = _storage._optionalShowScheduleCompleteState {return v}
      return false
    }
    set {_uniqueStorage()._optionalShowScheduleCompleteState = .showScheduleCompleteState(newValue)}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalChargeScheduleWindow: Equatable, Sendable {
    case chargeScheduleWindow(CarServer_ChargeSchedule)

  }

  enum OneOf_OptionalChargeBuffer: Equatable, Sendable {
    case chargeBuffer(Int32)

  }

  enum OneOf_OptionalMaxNumChargeSchedules: Equatable, Sendable {
    case maxNumChargeSchedules(UInt32)

  }

  enum OneOf_OptionalNextSchedule: Equatable, Sendable {
    case nextSchedule(Bool)

  }

  enum OneOf_OptionalShowScheduleCompleteState: Equatable, Sendable {
    case showScheduleCompleteState(Bool)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CarServer_PreconditioningScheduleState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var preconditionSchedules: [CarServer_PreconditionSchedule] = []

  var optionalPreconditioningScheduleWindow: CarServer_PreconditioningScheduleState.OneOf_OptionalPreconditioningScheduleWindow? = nil

  var preconditioningScheduleWindow: CarServer_PreconditionSchedule {
    get {
      if case .preconditioningScheduleWindow(let v)? = optionalPreconditioningScheduleWindow {return v}
      return CarServer_PreconditionSchedule()
    }
    set {optionalPreconditioningScheduleWindow = .preconditioningScheduleWindow(newValue)}
  }

  var optionalMaxNumPreconditionSchedules: CarServer_PreconditioningScheduleState.OneOf_OptionalMaxNumPreconditionSchedules? = nil

  var maxNumPreconditionSchedules: UInt32 {
    get {
      if case .maxNumPreconditionSchedules(let v)? = optionalMaxNumPreconditionSchedules {return v}
      return 0
    }
    set {optionalMaxNumPreconditionSchedules = .maxNumPreconditionSchedules(newValue)}
  }

  var optionalNextSchedule: CarServer_PreconditioningScheduleState.OneOf_OptionalNextSchedule? = nil

  var nextSchedule: Bool {
    get {
      if case .nextSchedule(let v)? = optionalNextSchedule {return v}
      return false
    }
    set {optionalNextSchedule = .nextSchedule(newValue)}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalPreconditioningScheduleWindow: Equatable, Sendable {
    case preconditioningScheduleWindow(CarServer_PreconditionSchedule)

  }

  enum OneOf_OptionalMaxNumPreconditionSchedules: Equatable, Sendable {
    case maxNumPreconditionSchedules(UInt32)

  }

  enum OneOf_OptionalNextSchedule: Equatable, Sendable {
    case nextSchedule(Bool)

  }

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct CarServer_SpeedLimitMode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var optionalActive: CarServer_SpeedLimitMode.OneOf_OptionalActive? = nil

  var active: Bool {
    get {
      if case .active(let v)? = optionalActive {return v}
      return false
    }
    set {optionalActive = .active(newValue)}
  }

  var optionalPinCodeSet: CarServer_SpeedLimitMode.OneOf_OptionalPinCodeSet? = nil

  var pinCodeSet: Bool {
    get {
      if case .pinCodeSet(let v)? = optionalPinCodeSet {return v}
      return false
    }
    set {optionalPinCodeSet = .pinCodeSet(newValue)}
  }

  var optionalMaxLimitMph: CarServer_SpeedLimitMode.OneOf_OptionalMaxLimitMph? = nil

  var maxLimitMph: Float {
    get {
      if case .maxLimitMph(let v)? = optionalMaxLimitMph {return v}
      return 0
    }
    set {optionalMaxLimitMph = .maxLimitMph(newValue)}
  }

  var optionalMinLimitMph: CarServer_SpeedLimitMode.OneOf_OptionalMinLimitMph? = nil

  var minLimitMph: Float {
    get {
      if case .minLimitMph(let v)? = optionalMinLimitMph {return v}
      return 0
    }
    set {optionalMinLimitMph = .minLimitMph(newValue)}
  }

  var optionalCurrentLimitMph: CarServer_SpeedLimitMode.OneOf_OptionalCurrentLimitMph? = nil

  var currentLimitMph: Float {
    get {
      if case .currentLimitMph(let v)? = optionalCurrentLimitMph {return v}
      return 0
    }
    set {optionalCurrentLimitMph = .currentLimitMph(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalActive: Equatable, Sendable {
    case active(Bool)

  }

  enum OneOf_OptionalPinCodeSet: Equatable, Sendable {
    case pinCodeSet(Bool)

  }

  enum OneOf_OptionalMaxLimitMph: Equatable, Sendable {
    case maxLimitMph(Float)

  }

  enum OneOf_OptionalMinLimitMph: Equatable, Sendable {
    case minLimitMph(Float)

  }

  enum OneOf_OptionalCurrentLimitMph: Equatable, Sendable {
    case currentLimitMph(Float)

  }

  init() {}
}

struct CarServer_ParentalControlsSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var optionalSpeedLimitEnabled: CarServer_ParentalControlsSettings.OneOf_OptionalSpeedLimitEnabled? = nil

  var speedLimitEnabled: Bool {
    get {
      if case .speedLimitEnabled(let v)? = optionalSpeedLimitEnabled {return v}
      return false
    }
    set {optionalSpeedLimitEnabled = .speedLimitEnabled(newValue)}
  }

  var optionalMaxLimitMph: CarServer_ParentalControlsSettings.OneOf_OptionalMaxLimitMph? = nil

  var maxLimitMph: Float {
    get {
      if case .maxLimitMph(let v)? = optionalMaxLimitMph {return v}
      return 0
    }
    set {optionalMaxLimitMph = .maxLimitMph(newValue)}
  }

  var optionalMinLimitMph: CarServer_ParentalControlsSettings.OneOf_OptionalMinLimitMph? = nil

  var minLimitMph: Float {
    get {
      if case .minLimitMph(let v)? = optionalMinLimitMph {return v}
      return 0
    }
    set {optionalMinLimitMph = .minLimitMph(newValue)}
  }

  var optionalCurrentLimitMph: CarServer_ParentalControlsSettings.OneOf_OptionalCurrentLimitMph? = nil

  var currentLimitMph: Float {
    get {
      if case .currentLimitMph(let v)? = optionalCurrentLimitMph {return v}
      return 0
    }
    set {optionalCurrentLimitMph = .currentLimitMph(newValue)}
  }

  var optionalChillAccelerationEnabled: CarServer_ParentalControlsSettings.OneOf_OptionalChillAccelerationEnabled? = nil

  var chillAccelerationEnabled: Bool {
    get {
      if case .chillAccelerationEnabled(let v)? = optionalChillAccelerationEnabled {return v}
      return false
    }
    set {optionalChillAccelerationEnabled = .chillAccelerationEnabled(newValue)}
  }

  var optionalRequireSafetySettingsEnabled: CarServer_ParentalControlsSettings.OneOf_OptionalRequireSafetySettingsEnabled? = nil

  var requireSafetySettingsEnabled: Bool {
    get {
      if case .requireSafetySettingsEnabled(let v)? = optionalRequireSafetySettingsEnabled {return v}
      return false
    }
    set {optionalRequireSafetySettingsEnabled = .requireSafetySettingsEnabled(newValue)}
  }

  var optionalCurfewEnabled: CarServer_ParentalControlsSettings.OneOf_OptionalCurfewEnabled? = nil

  var curfewEnabled: Bool {
    get {
      if case .curfewEnabled(let v)? = optionalCurfewEnabled {return v}
      return false
    }
    set {optionalCurfewEnabled = .curfewEnabled(newValue)}
  }

  var optionalCurfewStartTime: CarServer_ParentalControlsSettings.OneOf_OptionalCurfewStartTime? = nil

  var curfewStartTime: Int32 {
    get {
      if case .curfewStartTime(let v)? = optionalCurfewStartTime {return v}
      return 0
    }
    set {optionalCurfewStartTime = .curfewStartTime(newValue)}
  }

  var optionalCurfewEndTime: CarServer_ParentalControlsSettings.OneOf_OptionalCurfewEndTime? = nil

  var curfewEndTime: Int32 {
    get {
      if case .curfewEndTime(let v)? = optionalCurfewEndTime {return v}
      return 0
    }
    set {optionalCurfewEndTime = .curfewEndTime(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalSpeedLimitEnabled: Equatable, Sendable {
    case speedLimitEnabled(Bool)

  }

  enum OneOf_OptionalMaxLimitMph: Equatable, Sendable {
    case maxLimitMph(Float)

  }

  enum OneOf_OptionalMinLimitMph: Equatable, Sendable {
    case minLimitMph(Float)

  }

  enum OneOf_OptionalCurrentLimitMph: Equatable, Sendable {
    case currentLimitMph(Float)

  }

  enum OneOf_OptionalChillAccelerationEnabled: Equatable, Sendable {
    case chillAccelerationEnabled(Bool)

  }

  enum OneOf_OptionalRequireSafetySettingsEnabled: Equatable, Sendable {
    case requireSafetySettingsEnabled(Bool)

  }

  enum OneOf_OptionalCurfewEnabled: Equatable, Sendable {
    case curfewEnabled(Bool)

  }

  enum OneOf_OptionalCurfewStartTime: Equatable, Sendable {
    case curfewStartTime(Int32)

  }

  enum OneOf_OptionalCurfewEndTime: Equatable, Sendable {
    case curfewEndTime(Int32)

  }

  init() {}
}

struct CarServer_ParentalControlsState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var optionalParentalControlsActive: CarServer_ParentalControlsState.OneOf_OptionalParentalControlsActive? = nil

  var parentalControlsActive: Bool {
    get {
      if case .parentalControlsActive(let v)? = optionalParentalControlsActive {return v}
      return false
    }
    set {optionalParentalControlsActive = .parentalControlsActive(newValue)}
  }

  var optionalParentalControlsPinSet: CarServer_ParentalControlsState.OneOf_OptionalParentalControlsPinSet? = nil

  var parentalControlsPinSet: Bool {
    get {
      if case .parentalControlsPinSet(let v)? = optionalParentalControlsPinSet {return v}
      return false
    }
    set {optionalParentalControlsPinSet = .parentalControlsPinSet(newValue)}
  }

  var parentalControlsSettings: CarServer_ParentalControlsSettings {
    get {return _parentalControlsSettings ?? CarServer_ParentalControlsSettings()}
    set {_parentalControlsSettings = newValue}
  }
  /// Returns true if `parentalControlsSettings` has been explicitly set.
  var hasParentalControlsSettings: Bool {return self._parentalControlsSettings != nil}
  /// Clears the value of `parentalControlsSettings`. Subsequent reads from it will return its default value.
  mutating func clearParentalControlsSettings() {self._parentalControlsSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalParentalControlsActive: Equatable, Sendable {
    case parentalControlsActive(Bool)

  }

  enum OneOf_OptionalParentalControlsPinSet: Equatable, Sendable {
    case parentalControlsPinSet(Bool)

  }

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _parentalControlsSettings: CarServer_ParentalControlsSettings? = nil
}

struct CarServer_SoftwareUpdateState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: CarServer_SoftwareUpdateState.SoftwareUpdateStatus {
    get {return _status ?? CarServer_SoftwareUpdateState.SoftwareUpdateStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var optionalScheduledTimeMs: CarServer_SoftwareUpdateState.OneOf_OptionalScheduledTimeMs? = nil

  var scheduledTimeMs: UInt64 {
    get {
      if case .scheduledTimeMs(let v)? = optionalScheduledTimeMs {return v}
      return 0
    }
    set {optionalScheduledTimeMs = .scheduledTimeMs(newValue)}
  }

  var optionalWarningTimeRemainingMs: CarServer_SoftwareUpdateState.OneOf_OptionalWarningTimeRemainingMs? = nil

  var warningTimeRemainingMs: UInt64 {
    get {
      if case .warningTimeRemainingMs(let v)? = optionalWarningTimeRemainingMs {return v}
      return 0
    }
    set {optionalWarningTimeRemainingMs = .warningTimeRemainingMs(newValue)}
  }

  var optionalExpectedDurationSec: CarServer_SoftwareUpdateState.OneOf_OptionalExpectedDurationSec? = nil

  var expectedDurationSec: UInt32 {
    get {
      if case .expectedDurationSec(let v)? = optionalExpectedDurationSec {return v}
      return 0
    }
    set {optionalExpectedDurationSec = .expectedDurationSec(newValue)}
  }

  var optionalDownloadPerc: CarServer_SoftwareUpdateState.OneOf_OptionalDownloadPerc? = nil

  var downloadPerc: UInt32 {
    get {
      if case .downloadPerc(let v)? = optionalDownloadPerc {return v}
      return 0
    }
    set {optionalDownloadPerc = .downloadPerc(newValue)}
  }

  var optionalInstallPerc: CarServer_SoftwareUpdateState.OneOf_OptionalInstallPerc? = nil

  var installPerc: UInt32 {
    get {
      if case .installPerc(let v)? = optionalInstallPerc {return v}
      return 0
    }
    set {optionalInstallPerc = .installPerc(newValue)}
  }

  var optionalVersion: CarServer_SoftwareUpdateState.OneOf_OptionalVersion? = nil

  var version: String {
    get {
      if case .version(let v)? = optionalVersion {return v}
      return String()
    }
    set {optionalVersion = .version(newValue)}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalScheduledTimeMs: Equatable, Sendable {
    case scheduledTimeMs(UInt64)

  }

  enum OneOf_OptionalWarningTimeRemainingMs: Equatable, Sendable {
    case warningTimeRemainingMs(UInt64)

  }

  enum OneOf_OptionalExpectedDurationSec: Equatable, Sendable {
    case expectedDurationSec(UInt32)

  }

  enum OneOf_OptionalDownloadPerc: Equatable, Sendable {
    case downloadPerc(UInt32)

  }

  enum OneOf_OptionalInstallPerc: Equatable, Sendable {
    case installPerc(UInt32)

  }

  enum OneOf_OptionalVersion: Equatable, Sendable {
    case version(String)

  }

  struct SoftwareUpdateStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_SoftwareUpdateState.SoftwareUpdateStatus.OneOf_Type? = nil

    var unknown: CarServer_Void {
      get {
        if case .unknown(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .unknown(newValue)}
    }

    var installing: CarServer_Void {
      get {
        if case .installing(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .installing(newValue)}
    }

    var scheduled: CarServer_Void {
      get {
        if case .scheduled(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .scheduled(newValue)}
    }

    var available: CarServer_Void {
      get {
        if case .available(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .available(newValue)}
    }

    var downloadingWifiWait: CarServer_Void {
      get {
        if case .downloadingWifiWait(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .downloadingWifiWait(newValue)}
    }

    var downloading: CarServer_Void {
      get {
        if case .downloading(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .downloading(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case unknown(CarServer_Void)
      case installing(CarServer_Void)
      case scheduled(CarServer_Void)
      case available(CarServer_Void)
      case downloadingWifiWait(CarServer_Void)
      case downloading(CarServer_Void)

    }

    init() {}
  }

  init() {}

  fileprivate var _status: CarServer_SoftwareUpdateState.SoftwareUpdateStatus? = nil
  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct CarServer_DriveState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shiftState: CarServer_ShiftState {
    get {return _shiftState ?? CarServer_ShiftState()}
    set {_shiftState = newValue}
  }
  /// Returns true if `shiftState` has been explicitly set.
  var hasShiftState: Bool {return self._shiftState != nil}
  /// Clears the value of `shiftState`. Subsequent reads from it will return its default value.
  mutating func clearShiftState() {self._shiftState = nil}

  var optionalSpeed: CarServer_DriveState.OneOf_OptionalSpeed? = nil

  var speed: UInt32 {
    get {
      if case .speed(let v)? = optionalSpeed {return v}
      return 0
    }
    set {optionalSpeed = .speed(newValue)}
  }

  var optionalPower: CarServer_DriveState.OneOf_OptionalPower? = nil

  var power: Int32 {
    get {
      if case .power(let v)? = optionalPower {return v}
      return 0
    }
    set {optionalPower = .power(newValue)}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var optionalOdometerInHundredthsOfAMile: CarServer_DriveState.OneOf_OptionalOdometerInHundredthsOfAMile? = nil

  var odometerInHundredthsOfAMile: Int32 {
    get {
      if case .odometerInHundredthsOfAMile(let v)? = optionalOdometerInHundredthsOfAMile {return v}
      return 0
    }
    set {optionalOdometerInHundredthsOfAMile = .odometerInHundredthsOfAMile(newValue)}
  }

  var optionalSpeedFloat: CarServer_DriveState.OneOf_OptionalSpeedFloat? = nil

  var speedFloat: Float {
    get {
      if case .speedFloat(let v)? = optionalSpeedFloat {return v}
      return 0
    }
    set {optionalSpeedFloat = .speedFloat(newValue)}
  }

  var optionalActiveRouteDestination: CarServer_DriveState.OneOf_OptionalActiveRouteDestination? = nil

  var activeRouteDestination: String {
    get {
      if case .activeRouteDestination(let v)? = optionalActiveRouteDestination {return v}
      return String()
    }
    set {optionalActiveRouteDestination = .activeRouteDestination(newValue)}
  }

  var optionalActiveRouteMinutesToArrival: CarServer_DriveState.OneOf_OptionalActiveRouteMinutesToArrival? = nil

  var activeRouteMinutesToArrival: Float {
    get {
      if case .activeRouteMinutesToArrival(let v)? = optionalActiveRouteMinutesToArrival {return v}
      return 0
    }
    set {optionalActiveRouteMinutesToArrival = .activeRouteMinutesToArrival(newValue)}
  }

  var optionalActiveRouteMilesToArrival: CarServer_DriveState.OneOf_OptionalActiveRouteMilesToArrival? = nil

  var activeRouteMilesToArrival: Float {
    get {
      if case .activeRouteMilesToArrival(let v)? = optionalActiveRouteMilesToArrival {return v}
      return 0
    }
    set {optionalActiveRouteMilesToArrival = .activeRouteMilesToArrival(newValue)}
  }

  var optionalActiveRouteTrafficMinutesDelay: CarServer_DriveState.OneOf_OptionalActiveRouteTrafficMinutesDelay? = nil

  var activeRouteTrafficMinutesDelay: Float {
    get {
      if case .activeRouteTrafficMinutesDelay(let v)? = optionalActiveRouteTrafficMinutesDelay {return v}
      return 0
    }
    set {optionalActiveRouteTrafficMinutesDelay = .activeRouteTrafficMinutesDelay(newValue)}
  }

  var optionalActiveRouteEnergyAtArrival: CarServer_DriveState.OneOf_OptionalActiveRouteEnergyAtArrival? = nil

  var activeRouteEnergyAtArrival: Float {
    get {
      if case .activeRouteEnergyAtArrival(let v)? = optionalActiveRouteEnergyAtArrival {return v}
      return 0
    }
    set {optionalActiveRouteEnergyAtArrival = .activeRouteEnergyAtArrival(newValue)}
  }

  var optionalLastRouteUpdate: CarServer_DriveState.OneOf_OptionalLastRouteUpdate? = nil

  var lastRouteUpdate: UInt32 {
    get {
      if case .lastRouteUpdate(let v)? = optionalLastRouteUpdate {return v}
      return 0
    }
    set {optionalLastRouteUpdate = .lastRouteUpdate(newValue)}
  }

  var lastTrafficUpdate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastTrafficUpdate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastTrafficUpdate = newValue}
  }
  /// Returns true if `lastTrafficUpdate` has been explicitly set.
  var hasLastTrafficUpdate: Bool {return self._lastTrafficUpdate != nil}
  /// Clears the value of `lastTrafficUpdate`. Subsequent reads from it will return its default value.
  mutating func clearLastTrafficUpdate() {self._lastTrafficUpdate = nil}

  var activeRouteCoordinates: CarServer_LatLong {
    get {return _activeRouteCoordinates ?? CarServer_LatLong()}
    set {_activeRouteCoordinates = newValue}
  }
  /// Returns true if `activeRouteCoordinates` has been explicitly set.
  var hasActiveRouteCoordinates: Bool {return self._activeRouteCoordinates != nil}
  /// Clears the value of `activeRouteCoordinates`. Subsequent reads from it will return its default value.
  mutating func clearActiveRouteCoordinates() {self._activeRouteCoordinates = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalSpeed: Equatable, Sendable {
    case speed(UInt32)

  }

  enum OneOf_OptionalPower: Equatable, Sendable {
    case power(Int32)

  }

  enum OneOf_OptionalOdometerInHundredthsOfAMile: Equatable, Sendable {
    case odometerInHundredthsOfAMile(Int32)

  }

  enum OneOf_OptionalSpeedFloat: Equatable, Sendable {
    case speedFloat(Float)

  }

  enum OneOf_OptionalActiveRouteDestination: Equatable, Sendable {
    case activeRouteDestination(String)

  }

  enum OneOf_OptionalActiveRouteMinutesToArrival: Equatable, Sendable {
    case activeRouteMinutesToArrival(Float)

  }

  enum OneOf_OptionalActiveRouteMilesToArrival: Equatable, Sendable {
    case activeRouteMilesToArrival(Float)

  }

  enum OneOf_OptionalActiveRouteTrafficMinutesDelay: Equatable, Sendable {
    case activeRouteTrafficMinutesDelay(Float)

  }

  enum OneOf_OptionalActiveRouteEnergyAtArrival: Equatable, Sendable {
    case activeRouteEnergyAtArrival(Float)

  }

  enum OneOf_OptionalLastRouteUpdate: Equatable, Sendable {
    case lastRouteUpdate(UInt32)

  }

  init() {}

  fileprivate var _shiftState: CarServer_ShiftState? = nil
  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastTrafficUpdate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _activeRouteCoordinates: CarServer_LatLong? = nil
}

struct CarServer_ChargeState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargingState: CarServer_ChargeState.ChargingState {
    get {return _storage._chargingState ?? CarServer_ChargeState.ChargingState()}
    set {_uniqueStorage()._chargingState = newValue}
  }
  /// Returns true if `chargingState` has been explicitly set.
  var hasChargingState: Bool {return _storage._chargingState != nil}
  /// Clears the value of `chargingState`. Subsequent reads from it will return its default value.
  mutating func clearChargingState() {_uniqueStorage()._chargingState = nil}

  var fastChargerType: CarServer_ChargeState.ChargerType {
    get {return _storage._fastChargerType ?? CarServer_ChargeState.ChargerType()}
    set {_uniqueStorage()._fastChargerType = newValue}
  }
  /// Returns true if `fastChargerType` has been explicitly set.
  var hasFastChargerType: Bool {return _storage._fastChargerType != nil}
  /// Clears the value of `fastChargerType`. Subsequent reads from it will return its default value.
  mutating func clearFastChargerType() {_uniqueStorage()._fastChargerType = nil}

  var fastChargerBrand: CarServer_ChargeState.ChargerBrand {
    get {return _storage._fastChargerBrand ?? CarServer_ChargeState.ChargerBrand()}
    set {_uniqueStorage()._fastChargerBrand = newValue}
  }
  /// Returns true if `fastChargerBrand` has been explicitly set.
  var hasFastChargerBrand: Bool {return _storage._fastChargerBrand != nil}
  /// Clears the value of `fastChargerBrand`. Subsequent reads from it will return its default value.
  mutating func clearFastChargerBrand() {_uniqueStorage()._fastChargerBrand = nil}

  var optionalChargeLimitSoc: OneOf_OptionalChargeLimitSoc? {
    get {return _storage._optionalChargeLimitSoc}
    set {_uniqueStorage()._optionalChargeLimitSoc = newValue}
  }

  var chargeLimitSoc: Int32 {
    get {
      if case .chargeLimitSoc(let v)? = _storage._optionalChargeLimitSoc {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeLimitSoc = .chargeLimitSoc(newValue)}
  }

  var optionalChargeLimitSocStd: OneOf_OptionalChargeLimitSocStd? {
    get {return _storage._optionalChargeLimitSocStd}
    set {_uniqueStorage()._optionalChargeLimitSocStd = newValue}
  }

  var chargeLimitSocStd: Int32 {
    get {
      if case .chargeLimitSocStd(let v)? = _storage._optionalChargeLimitSocStd {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeLimitSocStd = .chargeLimitSocStd(newValue)}
  }

  var optionalChargeLimitSocMin: OneOf_OptionalChargeLimitSocMin? {
    get {return _storage._optionalChargeLimitSocMin}
    set {_uniqueStorage()._optionalChargeLimitSocMin = newValue}
  }

  var chargeLimitSocMin: Int32 {
    get {
      if case .chargeLimitSocMin(let v)? = _storage._optionalChargeLimitSocMin {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeLimitSocMin = .chargeLimitSocMin(newValue)}
  }

  var optionalChargeLimitSocMax: OneOf_OptionalChargeLimitSocMax? {
    get {return _storage._optionalChargeLimitSocMax}
    set {_uniqueStorage()._optionalChargeLimitSocMax = newValue}
  }

  var chargeLimitSocMax: Int32 {
    get {
      if case .chargeLimitSocMax(let v)? = _storage._optionalChargeLimitSocMax {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeLimitSocMax = .chargeLimitSocMax(newValue)}
  }

  var optionalMaxRangeChargeCounter: OneOf_OptionalMaxRangeChargeCounter? {
    get {return _storage._optionalMaxRangeChargeCounter}
    set {_uniqueStorage()._optionalMaxRangeChargeCounter = newValue}
  }

  var maxRangeChargeCounter: Int32 {
    get {
      if case .maxRangeChargeCounter(let v)? = _storage._optionalMaxRangeChargeCounter {return v}
      return 0
    }
    set {_uniqueStorage()._optionalMaxRangeChargeCounter = .maxRangeChargeCounter(newValue)}
  }

  var optionalFastChargerPresent: OneOf_OptionalFastChargerPresent? {
    get {return _storage._optionalFastChargerPresent}
    set {_uniqueStorage()._optionalFastChargerPresent = newValue}
  }

  var fastChargerPresent: Bool {
    get {
      if case .fastChargerPresent(let v)? = _storage._optionalFastChargerPresent {return v}
      return false
    }
    set {_uniqueStorage()._optionalFastChargerPresent = .fastChargerPresent(newValue)}
  }

  /// 2 decimals
  var optionalBatteryRange: OneOf_OptionalBatteryRange? {
    get {return _storage._optionalBatteryRange}
    set {_uniqueStorage()._optionalBatteryRange = newValue}
  }

  var batteryRange: Float {
    get {
      if case .batteryRange(let v)? = _storage._optionalBatteryRange {return v}
      return 0
    }
    set {_uniqueStorage()._optionalBatteryRange = .batteryRange(newValue)}
  }

  var optionalEstBatteryRange: OneOf_OptionalEstBatteryRange? {
    get {return _storage._optionalEstBatteryRange}
    set {_uniqueStorage()._optionalEstBatteryRange = newValue}
  }

  var estBatteryRange: Float {
    get {
      if case .estBatteryRange(let v)? = _storage._optionalEstBatteryRange {return v}
      return 0
    }
    set {_uniqueStorage()._optionalEstBatteryRange = .estBatteryRange(newValue)}
  }

  var optionalIdealBatteryRange: OneOf_OptionalIdealBatteryRange? {
    get {return _storage._optionalIdealBatteryRange}
    set {_uniqueStorage()._optionalIdealBatteryRange = newValue}
  }

  var idealBatteryRange: Float {
    get {
      if case .idealBatteryRange(let v)? = _storage._optionalIdealBatteryRange {return v}
      return 0
    }
    set {_uniqueStorage()._optionalIdealBatteryRange = .idealBatteryRange(newValue)}
  }

  var optionalBatteryLevel: OneOf_OptionalBatteryLevel? {
    get {return _storage._optionalBatteryLevel}
    set {_uniqueStorage()._optionalBatteryLevel = newValue}
  }

  var batteryLevel: Int32 {
    get {
      if case .batteryLevel(let v)? = _storage._optionalBatteryLevel {return v}
      return 0
    }
    set {_uniqueStorage()._optionalBatteryLevel = .batteryLevel(newValue)}
  }

  var optionalUsableBatteryLevel: OneOf_OptionalUsableBatteryLevel? {
    get {return _storage._optionalUsableBatteryLevel}
    set {_uniqueStorage()._optionalUsableBatteryLevel = newValue}
  }

  var usableBatteryLevel: Int32 {
    get {
      if case .usableBatteryLevel(let v)? = _storage._optionalUsableBatteryLevel {return v}
      return 0
    }
    set {_uniqueStorage()._optionalUsableBatteryLevel = .usableBatteryLevel(newValue)}
  }

  /// 1 decimal
  var optionalChargeEnergyAdded: OneOf_OptionalChargeEnergyAdded? {
    get {return _storage._optionalChargeEnergyAdded}
    set {_uniqueStorage()._optionalChargeEnergyAdded = newValue}
  }

  var chargeEnergyAdded: Float {
    get {
      if case .chargeEnergyAdded(let v)? = _storage._optionalChargeEnergyAdded {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeEnergyAdded = .chargeEnergyAdded(newValue)}
  }

  var optionalChargeMilesAddedRated: OneOf_OptionalChargeMilesAddedRated? {
    get {return _storage._optionalChargeMilesAddedRated}
    set {_uniqueStorage()._optionalChargeMilesAddedRated = newValue}
  }

  var chargeMilesAddedRated: Float {
    get {
      if case .chargeMilesAddedRated(let v)? = _storage._optionalChargeMilesAddedRated {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeMilesAddedRated = .chargeMilesAddedRated(newValue)}
  }

  var optionalChargeMilesAddedIdeal: OneOf_OptionalChargeMilesAddedIdeal? {
    get {return _storage._optionalChargeMilesAddedIdeal}
    set {_uniqueStorage()._optionalChargeMilesAddedIdeal = newValue}
  }

  var chargeMilesAddedIdeal: Float {
    get {
      if case .chargeMilesAddedIdeal(let v)? = _storage._optionalChargeMilesAddedIdeal {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeMilesAddedIdeal = .chargeMilesAddedIdeal(newValue)}
  }

  var optionalChargerVoltage: OneOf_OptionalChargerVoltage? {
    get {return _storage._optionalChargerVoltage}
    set {_uniqueStorage()._optionalChargerVoltage = newValue}
  }

  var chargerVoltage: Int32 {
    get {
      if case .chargerVoltage(let v)? = _storage._optionalChargerVoltage {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargerVoltage = .chargerVoltage(newValue)}
  }

  var optionalChargerPilotCurrent: OneOf_OptionalChargerPilotCurrent? {
    get {return _storage._optionalChargerPilotCurrent}
    set {_uniqueStorage()._optionalChargerPilotCurrent = newValue}
  }

  var chargerPilotCurrent: Int32 {
    get {
      if case .chargerPilotCurrent(let v)? = _storage._optionalChargerPilotCurrent {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargerPilotCurrent = .chargerPilotCurrent(newValue)}
  }

  var optionalChargerActualCurrent: OneOf_OptionalChargerActualCurrent? {
    get {return _storage._optionalChargerActualCurrent}
    set {_uniqueStorage()._optionalChargerActualCurrent = newValue}
  }

  var chargerActualCurrent: Int32 {
    get {
      if case .chargerActualCurrent(let v)? = _storage._optionalChargerActualCurrent {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargerActualCurrent = .chargerActualCurrent(newValue)}
  }

  var optionalChargerPower: OneOf_OptionalChargerPower? {
    get {return _storage._optionalChargerPower}
    set {_uniqueStorage()._optionalChargerPower = newValue}
  }

  var chargerPower: Int32 {
    get {
      if case .chargerPower(let v)? = _storage._optionalChargerPower {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargerPower = .chargerPower(newValue)}
  }

  var optionalMinutesToFullCharge: OneOf_OptionalMinutesToFullCharge? {
    get {return _storage._optionalMinutesToFullCharge}
    set {_uniqueStorage()._optionalMinutesToFullCharge = newValue}
  }

  var minutesToFullCharge: Int32 {
    get {
      if case .minutesToFullCharge(let v)? = _storage._optionalMinutesToFullCharge {return v}
      return 0
    }
    set {_uniqueStorage()._optionalMinutesToFullCharge = .minutesToFullCharge(newValue)}
  }

  var optionalMinutesToChargeLimit: OneOf_OptionalMinutesToChargeLimit? {
    get {return _storage._optionalMinutesToChargeLimit}
    set {_uniqueStorage()._optionalMinutesToChargeLimit = newValue}
  }

  var minutesToChargeLimit: Int32 {
    get {
      if case .minutesToChargeLimit(let v)? = _storage._optionalMinutesToChargeLimit {return v}
      return 0
    }
    set {_uniqueStorage()._optionalMinutesToChargeLimit = .minutesToChargeLimit(newValue)}
  }

  var optionalTripCharging: OneOf_OptionalTripCharging? {
    get {return _storage._optionalTripCharging}
    set {_uniqueStorage()._optionalTripCharging = newValue}
  }

  var tripCharging: Bool {
    get {
      if case .tripCharging(let v)? = _storage._optionalTripCharging {return v}
      return false
    }
    set {_uniqueStorage()._optionalTripCharging = .tripCharging(newValue)}
  }

  var optionalChargeRateMph: OneOf_OptionalChargeRateMph? {
    get {return _storage._optionalChargeRateMph}
    set {_uniqueStorage()._optionalChargeRateMph = newValue}
  }

  var chargeRateMph: Int32 {
    get {
      if case .chargeRateMph(let v)? = _storage._optionalChargeRateMph {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeRateMph = .chargeRateMph(newValue)}
  }

  var optionalChargePortDoorOpen: OneOf_OptionalChargePortDoorOpen? {
    get {return _storage._optionalChargePortDoorOpen}
    set {_uniqueStorage()._optionalChargePortDoorOpen = newValue}
  }

  var chargePortDoorOpen: Bool {
    get {
      if case .chargePortDoorOpen(let v)? = _storage._optionalChargePortDoorOpen {return v}
      return false
    }
    set {_uniqueStorage()._optionalChargePortDoorOpen = .chargePortDoorOpen(newValue)}
  }

  var connChargeCable: CarServer_ChargeState.CableType {
    get {return _storage._connChargeCable ?? CarServer_ChargeState.CableType()}
    set {_uniqueStorage()._connChargeCable = newValue}
  }
  /// Returns true if `connChargeCable` has been explicitly set.
  var hasConnChargeCable: Bool {return _storage._connChargeCable != nil}
  /// Clears the value of `connChargeCable`. Subsequent reads from it will return its default value.
  mutating func clearConnChargeCable() {_uniqueStorage()._connChargeCable = nil}

  /// seconds / datetime
  var optionalScheduledChargingStartTime: OneOf_OptionalScheduledChargingStartTime? {
    get {return _storage._optionalScheduledChargingStartTime}
    set {_uniqueStorage()._optionalScheduledChargingStartTime = newValue}
  }

  var scheduledChargingStartTime: UInt64 {
    get {
      if case .scheduledChargingStartTime(let v)? = _storage._optionalScheduledChargingStartTime {return v}
      return 0
    }
    set {_uniqueStorage()._optionalScheduledChargingStartTime = .scheduledChargingStartTime(newValue)}
  }

  var optionalScheduledChargingPending: OneOf_OptionalScheduledChargingPending? {
    get {return _storage._optionalScheduledChargingPending}
    set {_uniqueStorage()._optionalScheduledChargingPending = newValue}
  }

  var scheduledChargingPending: Bool {
    get {
      if case .scheduledChargingPending(let v)? = _storage._optionalScheduledChargingPending {return v}
      return false
    }
    set {_uniqueStorage()._optionalScheduledChargingPending = .scheduledChargingPending(newValue)}
  }

  var scheduledDepartureTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._scheduledDepartureTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._scheduledDepartureTime = newValue}
  }
  /// Returns true if `scheduledDepartureTime` has been explicitly set.
  var hasScheduledDepartureTime: Bool {return _storage._scheduledDepartureTime != nil}
  /// Clears the value of `scheduledDepartureTime`. Subsequent reads from it will return its default value.
  mutating func clearScheduledDepartureTime() {_uniqueStorage()._scheduledDepartureTime = nil}

  var optionalUserChargeEnableRequest: OneOf_OptionalUserChargeEnableRequest? {
    get {return _storage._optionalUserChargeEnableRequest}
    set {_uniqueStorage()._optionalUserChargeEnableRequest = newValue}
  }

  var userChargeEnableRequest: Bool {
    get {
      if case .userChargeEnableRequest(let v)? = _storage._optionalUserChargeEnableRequest {return v}
      return false
    }
    set {_uniqueStorage()._optionalUserChargeEnableRequest = .userChargeEnableRequest(newValue)}
  }

  var optionalChargeEnableRequest: OneOf_OptionalChargeEnableRequest? {
    get {return _storage._optionalChargeEnableRequest}
    set {_uniqueStorage()._optionalChargeEnableRequest = newValue}
  }

  var chargeEnableRequest: Bool {
    get {
      if case .chargeEnableRequest(let v)? = _storage._optionalChargeEnableRequest {return v}
      return false
    }
    set {_uniqueStorage()._optionalChargeEnableRequest = .chargeEnableRequest(newValue)}
  }

  var optionalChargerPhases: OneOf_OptionalChargerPhases? {
    get {return _storage._optionalChargerPhases}
    set {_uniqueStorage()._optionalChargerPhases = newValue}
  }

  var chargerPhases: Int32 {
    get {
      if case .chargerPhases(let v)? = _storage._optionalChargerPhases {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargerPhases = .chargerPhases(newValue)}
  }

  var chargePortLatch: CarServer_ChargePortLatchState {
    get {return _storage._chargePortLatch ?? CarServer_ChargePortLatchState()}
    set {_uniqueStorage()._chargePortLatch = newValue}
  }
  /// Returns true if `chargePortLatch` has been explicitly set.
  var hasChargePortLatch: Bool {return _storage._chargePortLatch != nil}
  /// Clears the value of `chargePortLatch`. Subsequent reads from it will return its default value.
  mutating func clearChargePortLatch() {_uniqueStorage()._chargePortLatch = nil}

  var optionalChargePortColdWeatherMode: OneOf_OptionalChargePortColdWeatherMode? {
    get {return _storage._optionalChargePortColdWeatherMode}
    set {_uniqueStorage()._optionalChargePortColdWeatherMode = newValue}
  }

  var chargePortColdWeatherMode: Bool {
    get {
      if case .chargePortColdWeatherMode(let v)? = _storage._optionalChargePortColdWeatherMode {return v}
      return false
    }
    set {_uniqueStorage()._optionalChargePortColdWeatherMode = .chargePortColdWeatherMode(newValue)}
  }

  var optionalChargeCurrentRequest: OneOf_OptionalChargeCurrentRequest? {
    get {return _storage._optionalChargeCurrentRequest}
    set {_uniqueStorage()._optionalChargeCurrentRequest = newValue}
  }

  var chargeCurrentRequest: Int32 {
    get {
      if case .chargeCurrentRequest(let v)? = _storage._optionalChargeCurrentRequest {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeCurrentRequest = .chargeCurrentRequest(newValue)}
  }

  var optionalChargeCurrentRequestMax: OneOf_OptionalChargeCurrentRequestMax? {
    get {return _storage._optionalChargeCurrentRequestMax}
    set {_uniqueStorage()._optionalChargeCurrentRequestMax = newValue}
  }

  var chargeCurrentRequestMax: Int32 {
    get {
      if case .chargeCurrentRequestMax(let v)? = _storage._optionalChargeCurrentRequestMax {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeCurrentRequestMax = .chargeCurrentRequestMax(newValue)}
  }

  var optionalManagedChargingActive: OneOf_OptionalManagedChargingActive? {
    get {return _storage._optionalManagedChargingActive}
    set {_uniqueStorage()._optionalManagedChargingActive = newValue}
  }

  var managedChargingActive: Bool {
    get {
      if case .managedChargingActive(let v)? = _storage._optionalManagedChargingActive {return v}
      return false
    }
    set {_uniqueStorage()._optionalManagedChargingActive = .managedChargingActive(newValue)}
  }

  var optionalManagedChargingUserCanceled: OneOf_OptionalManagedChargingUserCanceled? {
    get {return _storage._optionalManagedChargingUserCanceled}
    set {_uniqueStorage()._optionalManagedChargingUserCanceled = newValue}
  }

  var managedChargingUserCanceled: Bool {
    get {
      if case .managedChargingUserCanceled(let v)? = _storage._optionalManagedChargingUserCanceled {return v}
      return false
    }
    set {_uniqueStorage()._optionalManagedChargingUserCanceled = .managedChargingUserCanceled(newValue)}
  }

  var optionalManagedChargingStartTime: OneOf_OptionalManagedChargingStartTime? {
    get {return _storage._optionalManagedChargingStartTime}
    set {_uniqueStorage()._optionalManagedChargingStartTime = newValue}
  }

  var managedChargingStartTime: UInt64 {
    get {
      if case .managedChargingStartTime(let v)? = _storage._optionalManagedChargingStartTime {return v}
      return 0
    }
    set {_uniqueStorage()._optionalManagedChargingStartTime = .managedChargingStartTime(newValue)}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var preconditioningTimes: CarServer_PreconditioningTimes {
    get {return _storage._preconditioningTimes ?? CarServer_PreconditioningTimes()}
    set {_uniqueStorage()._preconditioningTimes = newValue}
  }
  /// Returns true if `preconditioningTimes` has been explicitly set.
  var hasPreconditioningTimes: Bool {return _storage._preconditioningTimes != nil}
  /// Clears the value of `preconditioningTimes`. Subsequent reads from it will return its default value.
  mutating func clearPreconditioningTimes() {_uniqueStorage()._preconditioningTimes = nil}

  var offPeakChargingTimes: CarServer_OffPeakChargingTimes {
    get {return _storage._offPeakChargingTimes ?? CarServer_OffPeakChargingTimes()}
    set {_uniqueStorage()._offPeakChargingTimes = newValue}
  }
  /// Returns true if `offPeakChargingTimes` has been explicitly set.
  var hasOffPeakChargingTimes: Bool {return _storage._offPeakChargingTimes != nil}
  /// Clears the value of `offPeakChargingTimes`. Subsequent reads from it will return its default value.
  mutating func clearOffPeakChargingTimes() {_uniqueStorage()._offPeakChargingTimes = nil}

  var optionalOffPeakHoursEndTime: OneOf_OptionalOffPeakHoursEndTime? {
    get {return _storage._optionalOffPeakHoursEndTime}
    set {_uniqueStorage()._optionalOffPeakHoursEndTime = newValue}
  }

  var offPeakHoursEndTime: UInt32 {
    get {
      if case .offPeakHoursEndTime(let v)? = _storage._optionalOffPeakHoursEndTime {return v}
      return 0
    }
    set {_uniqueStorage()._optionalOffPeakHoursEndTime = .offPeakHoursEndTime(newValue)}
  }

  var optionalScheduledChargingMode: OneOf_OptionalScheduledChargingMode? {
    get {return _storage._optionalScheduledChargingMode}
    set {_uniqueStorage()._optionalScheduledChargingMode = newValue}
  }

  var scheduledChargingMode: CarServer_ChargeState.ScheduledChargingMode {
    get {
      if case .scheduledChargingMode(let v)? = _storage._optionalScheduledChargingMode {return v}
      return .off
    }
    set {_uniqueStorage()._optionalScheduledChargingMode = .scheduledChargingMode(newValue)}
  }

  var optionalChargingAmps: OneOf_OptionalChargingAmps? {
    get {return _storage._optionalChargingAmps}
    set {_uniqueStorage()._optionalChargingAmps = newValue}
  }

  var chargingAmps: Int32 {
    get {
      if case .chargingAmps(let v)? = _storage._optionalChargingAmps {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargingAmps = .chargingAmps(newValue)}
  }

  var optionalScheduledChargingStartTimeMinutes: OneOf_OptionalScheduledChargingStartTimeMinutes? {
    get {return _storage._optionalScheduledChargingStartTimeMinutes}
    set {_uniqueStorage()._optionalScheduledChargingStartTimeMinutes = newValue}
  }

  var scheduledChargingStartTimeMinutes: UInt32 {
    get {
      if case .scheduledChargingStartTimeMinutes(let v)? = _storage._optionalScheduledChargingStartTimeMinutes {return v}
      return 0
    }
    set {_uniqueStorage()._optionalScheduledChargingStartTimeMinutes = .scheduledChargingStartTimeMinutes(newValue)}
  }

  var optionalScheduledDepartureTimeMinutes: OneOf_OptionalScheduledDepartureTimeMinutes? {
    get {return _storage._optionalScheduledDepartureTimeMinutes}
    set {_uniqueStorage()._optionalScheduledDepartureTimeMinutes = newValue}
  }

  var scheduledDepartureTimeMinutes: UInt32 {
    get {
      if case .scheduledDepartureTimeMinutes(let v)? = _storage._optionalScheduledDepartureTimeMinutes {return v}
      return 0
    }
    set {_uniqueStorage()._optionalScheduledDepartureTimeMinutes = .scheduledDepartureTimeMinutes(newValue)}
  }

  var optionalPreconditioningEnabled: OneOf_OptionalPreconditioningEnabled? {
    get {return _storage._optionalPreconditioningEnabled}
    set {_uniqueStorage()._optionalPreconditioningEnabled = newValue}
  }

  var preconditioningEnabled: Bool {
    get {
      if case .preconditioningEnabled(let v)? = _storage._optionalPreconditioningEnabled {return v}
      return false
    }
    set {_uniqueStorage()._optionalPreconditioningEnabled = .preconditioningEnabled(newValue)}
  }

  var optionalScheduledChargingStartTimeApp: OneOf_OptionalScheduledChargingStartTimeApp? {
    get {return _storage._optionalScheduledChargingStartTimeApp}
    set {_uniqueStorage()._optionalScheduledChargingStartTimeApp = newValue}
  }

  var scheduledChargingStartTimeApp: Int32 {
    get {
      if case .scheduledChargingStartTimeApp(let v)? = _storage._optionalScheduledChargingStartTimeApp {return v}
      return 0
    }
    set {_uniqueStorage()._optionalScheduledChargingStartTimeApp = .scheduledChargingStartTimeApp(newValue)}
  }

  var optionalSuperchargerSessionTripPlanner: OneOf_OptionalSuperchargerSessionTripPlanner? {
    get {return _storage._optionalSuperchargerSessionTripPlanner}
    set {_uniqueStorage()._optionalSuperchargerSessionTripPlanner = newValue}
  }

  var superchargerSessionTripPlanner: Bool {
    get {
      if case .superchargerSessionTripPlanner(let v)? = _storage._optionalSuperchargerSessionTripPlanner {return v}
      return false
    }
    set {_uniqueStorage()._optionalSuperchargerSessionTripPlanner = .superchargerSessionTripPlanner(newValue)}
  }

  var optionalChargePortColor: OneOf_OptionalChargePortColor? {
    get {return _storage._optionalChargePortColor}
    set {_uniqueStorage()._optionalChargePortColor = newValue}
  }

  var chargePortColor: CarServer_ChargeState.ChargePortColor_E {
    get {
      if case .chargePortColor(let v)? = _storage._optionalChargePortColor {return v}
      return .chargePortColorOff
    }
    set {_uniqueStorage()._optionalChargePortColor = .chargePortColor(newValue)}
  }

  var optionalChargeRateMphFloat: OneOf_OptionalChargeRateMphFloat? {
    get {return _storage._optionalChargeRateMphFloat}
    set {_uniqueStorage()._optionalChargeRateMphFloat = newValue}
  }

  var chargeRateMphFloat: Float {
    get {
      if case .chargeRateMphFloat(let v)? = _storage._optionalChargeRateMphFloat {return v}
      return 0
    }
    set {_uniqueStorage()._optionalChargeRateMphFloat = .chargeRateMphFloat(newValue)}
  }

  var optionalChargeLimitReason: OneOf_OptionalChargeLimitReason? {
    get {return _storage._optionalChargeLimitReason}
    set {_uniqueStorage()._optionalChargeLimitReason = newValue}
  }

  var chargeLimitReason: CarServer_ChargeState.ChargeLimitReason {
    get {
      if case .chargeLimitReason(let v)? = _storage._optionalChargeLimitReason {return v}
      return .unknown
    }
    set {_uniqueStorage()._optionalChargeLimitReason = .chargeLimitReason(newValue)}
  }

  var managedChargingState: CarServer_ManagedChargingState {
    get {return _storage._managedChargingState ?? CarServer_ManagedChargingState()}
    set {_uniqueStorage()._managedChargingState = newValue}
  }
  /// Returns true if `managedChargingState` has been explicitly set.
  var hasManagedChargingState: Bool {return _storage._managedChargingState != nil}
  /// Clears the value of `managedChargingState`. Subsequent reads from it will return its default value.
  mutating func clearManagedChargingState() {_uniqueStorage()._managedChargingState = nil}

  var optionalChargeCableUnlatched: OneOf_OptionalChargeCableUnlatched? {
    get {return _storage._optionalChargeCableUnlatched}
    set {_uniqueStorage()._optionalChargeCableUnlatched = newValue}
  }

  var chargeCableUnlatched: Bool {
    get {
      if case .chargeCableUnlatched(let v)? = _storage._optionalChargeCableUnlatched {return v}
      return false
    }
    set {_uniqueStorage()._optionalChargeCableUnlatched = .chargeCableUnlatched(newValue)}
  }

  var optionalOutletState: OneOf_OptionalOutletState? {
    get {return _storage._optionalOutletState}
    set {_uniqueStorage()._optionalOutletState = newValue}
  }

  var outletState: CarServer_ChargeState.OutletState {
    get {
      if case .outletState(let v)? = _storage._optionalOutletState {return v}
      return .off
    }
    set {_uniqueStorage()._optionalOutletState = .outletState(newValue)}
  }

  var optionalPowerFeedState: OneOf_OptionalPowerFeedState? {
    get {return _storage._optionalPowerFeedState}
    set {_uniqueStorage()._optionalPowerFeedState = newValue}
  }

  var powerFeedState: CarServer_ChargeState.PowerFeedState {
    get {
      if case .powerFeedState(let v)? = _storage._optionalPowerFeedState {return v}
      return .off
    }
    set {_uniqueStorage()._optionalPowerFeedState = .powerFeedState(newValue)}
  }

  var optionOutletSocLimit: OneOf_OptionOutletSocLimit? {
    get {return _storage._optionOutletSocLimit}
    set {_uniqueStorage()._optionOutletSocLimit = newValue}
  }

  var outletSocLimit: Int32 {
    get {
      if case .outletSocLimit(let v)? = _storage._optionOutletSocLimit {return v}
      return 0
    }
    set {_uniqueStorage()._optionOutletSocLimit = .outletSocLimit(newValue)}
  }

  var optionPowerFeedSocLimit: OneOf_OptionPowerFeedSocLimit? {
    get {return _storage._optionPowerFeedSocLimit}
    set {_uniqueStorage()._optionPowerFeedSocLimit = newValue}
  }

  var powerFeedSocLimit: Int32 {
    get {
      if case .powerFeedSocLimit(let v)? = _storage._optionPowerFeedSocLimit {return v}
      return 0
    }
    set {_uniqueStorage()._optionPowerFeedSocLimit = .powerFeedSocLimit(newValue)}
  }

  var optionOutletTimeRemaining: OneOf_OptionOutletTimeRemaining? {
    get {return _storage._optionOutletTimeRemaining}
    set {_uniqueStorage()._optionOutletTimeRemaining = newValue}
  }

  var outletTimeRemaining: Int64 {
    get {
      if case .outletTimeRemaining(let v)? = _storage._optionOutletTimeRemaining {return v}
      return 0
    }
    set {_uniqueStorage()._optionOutletTimeRemaining = .outletTimeRemaining(newValue)}
  }

  var optionPowerFeedTimeRemaining: OneOf_OptionPowerFeedTimeRemaining? {
    get {return _storage._optionPowerFeedTimeRemaining}
    set {_uniqueStorage()._optionPowerFeedTimeRemaining = newValue}
  }

  var powerFeedTimeRemaining: Int64 {
    get {
      if case .powerFeedTimeRemaining(let v)? = _storage._optionPowerFeedTimeRemaining {return v}
      return 0
    }
    set {_uniqueStorage()._optionPowerFeedTimeRemaining = .powerFeedTimeRemaining(newValue)}
  }

  var optionalPowershareFeatureAllowed: OneOf_OptionalPowershareFeatureAllowed? {
    get {return _storage._optionalPowershareFeatureAllowed}
    set {_uniqueStorage()._optionalPowershareFeatureAllowed = newValue}
  }

  var powershareFeatureAllowed: Bool {
    get {
      if case .powershareFeatureAllowed(let v)? = _storage._optionalPowershareFeatureAllowed {return v}
      return false
    }
    set {_uniqueStorage()._optionalPowershareFeatureAllowed = .powershareFeatureAllowed(newValue)}
  }

  var optionalPowershareFeatureEnabled: OneOf_OptionalPowershareFeatureEnabled? {
    get {return _storage._optionalPowershareFeatureEnabled}
    set {_uniqueStorage()._optionalPowershareFeatureEnabled = newValue}
  }

  var powershareFeatureEnabled: Bool {
    get {
      if case .powershareFeatureEnabled(let v)? = _storage._optionalPowershareFeatureEnabled {return v}
      return false
    }
    set {_uniqueStorage()._optionalPowershareFeatureEnabled = .powershareFeatureEnabled(newValue)}
  }

  var optionalPowershareRequest: OneOf_OptionalPowershareRequest? {
    get {return _storage._optionalPowershareRequest}
    set {_uniqueStorage()._optionalPowershareRequest = newValue}
  }

  var powershareRequest: Bool {
    get {
      if case .powershareRequest(let v)? = _storage._optionalPowershareRequest {return v}
      return false
    }
    set {_uniqueStorage()._optionalPowershareRequest = .powershareRequest(newValue)}
  }

  var optionalPowershareType: OneOf_OptionalPowershareType? {
    get {return _storage._optionalPowershareType}
    set {_uniqueStorage()._optionalPowershareType = newValue}
  }

  var powershareType: CarServer_ChargeState.PowershareType {
    get {
      if case .powershareType(let v)? = _storage._optionalPowershareType {return v}
      return .none
    }
    set {_uniqueStorage()._optionalPowershareType = .powershareType(newValue)}
  }

  var optionalPowershareStatus: OneOf_OptionalPowershareStatus? {
    get {return _storage._optionalPowershareStatus}
    set {_uniqueStorage()._optionalPowershareStatus = newValue}
  }

  var powershareStatus: CarServer_ChargeState.PowershareStatus {
    get {
      if case .powershareStatus(let v)? = _storage._optionalPowershareStatus {return v}
      return .inactive
    }
    set {_uniqueStorage()._optionalPowershareStatus = .powershareStatus(newValue)}
  }

  var optionalPowershareStopReason: OneOf_OptionalPowershareStopReason? {
    get {return _storage._optionalPowershareStopReason}
    set {_uniqueStorage()._optionalPowershareStopReason = newValue}
  }

  var powershareStopReason: CarServer_ChargeState.PowershareStopReason {
    get {
      if case .powershareStopReason(let v)? = _storage._optionalPowershareStopReason {return v}
      return .none
    }
    set {_uniqueStorage()._optionalPowershareStopReason = .powershareStopReason(newValue)}
  }

  var optionalPowershareInstantaneousLoadKw: OneOf_OptionalPowershareInstantaneousLoadKw? {
    get {return _storage._optionalPowershareInstantaneousLoadKw}
    set {_uniqueStorage()._optionalPowershareInstantaneousLoadKw = newValue}
  }

  var powershareInstantaneousLoadKw: Float {
    get {
      if case .powershareInstantaneousLoadKw(let v)? = _storage._optionalPowershareInstantaneousLoadKw {return v}
      return 0
    }
    set {_uniqueStorage()._optionalPowershareInstantaneousLoadKw = .powershareInstantaneousLoadKw(newValue)}
  }

  var optionalPowershareVehicleEnergyLeftHr: OneOf_OptionalPowershareVehicleEnergyLeftHr? {
    get {return _storage._optionalPowershareVehicleEnergyLeftHr}
    set {_uniqueStorage()._optionalPowershareVehicleEnergyLeftHr = newValue}
  }

  var powershareVehicleEnergyLeftHr: Int32 {
    get {
      if case .powershareVehicleEnergyLeftHr(let v)? = _storage._optionalPowershareVehicleEnergyLeftHr {return v}
      return 0
    }
    set {_uniqueStorage()._optionalPowershareVehicleEnergyLeftHr = .powershareVehicleEnergyLeftHr(newValue)}
  }

  var optionalPowershareSocLimit: OneOf_OptionalPowershareSocLimit? {
    get {return _storage._optionalPowershareSocLimit}
    set {_uniqueStorage()._optionalPowershareSocLimit = newValue}
  }

  var powershareSocLimit: Int32 {
    get {
      if case .powershareSocLimit(let v)? = _storage._optionalPowershareSocLimit {return v}
      return 0
    }
    set {_uniqueStorage()._optionalPowershareSocLimit = .powershareSocLimit(newValue)}
  }

  var optionalOneTimeSocLimit: OneOf_OptionalOneTimeSocLimit? {
    get {return _storage._optionalOneTimeSocLimit}
    set {_uniqueStorage()._optionalOneTimeSocLimit = newValue}
  }

  var oneTimeSocLimit: Int32 {
    get {
      if case .oneTimeSocLimit(let v)? = _storage._optionalOneTimeSocLimit {return v}
      return 0
    }
    set {_uniqueStorage()._optionalOneTimeSocLimit = .oneTimeSocLimit(newValue)}
  }

  var optionalHomeLocation: OneOf_OptionalHomeLocation? {
    get {return _storage._optionalHomeLocation}
    set {_uniqueStorage()._optionalHomeLocation = newValue}
  }

  var homeLocation: CarServer_LatLong {
    get {
      if case .homeLocation(let v)? = _storage._optionalHomeLocation {return v}
      return CarServer_LatLong()
    }
    set {_uniqueStorage()._optionalHomeLocation = .homeLocation(newValue)}
  }

  var optionalWorkLocation: OneOf_OptionalWorkLocation? {
    get {return _storage._optionalWorkLocation}
    set {_uniqueStorage()._optionalWorkLocation = newValue}
  }

  var workLocation: CarServer_LatLong {
    get {
      if case .workLocation(let v)? = _storage._optionalWorkLocation {return v}
      return CarServer_LatLong()
    }
    set {_uniqueStorage()._optionalWorkLocation = .workLocation(newValue)}
  }

  var optionalOutletMaxTimerMinutes: OneOf_OptionalOutletMaxTimerMinutes? {
    get {return _storage._optionalOutletMaxTimerMinutes}
    set {_uniqueStorage()._optionalOutletMaxTimerMinutes = newValue}
  }

  var outletMaxTimerMinutes: Int32 {
    get {
      if case .outletMaxTimerMinutes(let v)? = _storage._optionalOutletMaxTimerMinutes {return v}
      return 0
    }
    set {_uniqueStorage()._optionalOutletMaxTimerMinutes = .outletMaxTimerMinutes(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalChargeLimitSoc: Equatable, Sendable {
    case chargeLimitSoc(Int32)

  }

  enum OneOf_OptionalChargeLimitSocStd: Equatable, Sendable {
    case chargeLimitSocStd(Int32)

  }

  enum OneOf_OptionalChargeLimitSocMin: Equatable, Sendable {
    case chargeLimitSocMin(Int32)

  }

  enum OneOf_OptionalChargeLimitSocMax: Equatable, Sendable {
    case chargeLimitSocMax(Int32)

  }

  enum OneOf_OptionalMaxRangeChargeCounter: Equatable, Sendable {
    case maxRangeChargeCounter(Int32)

  }

  enum OneOf_OptionalFastChargerPresent: Equatable, Sendable {
    case fastChargerPresent(Bool)

  }

  /// 2 decimals
  enum OneOf_OptionalBatteryRange: Equatable, Sendable {
    case batteryRange(Float)

  }

  enum OneOf_OptionalEstBatteryRange: Equatable, Sendable {
    case estBatteryRange(Float)

  }

  enum OneOf_OptionalIdealBatteryRange: Equatable, Sendable {
    case idealBatteryRange(Float)

  }

  enum OneOf_OptionalBatteryLevel: Equatable, Sendable {
    case batteryLevel(Int32)

  }

  enum OneOf_OptionalUsableBatteryLevel: Equatable, Sendable {
    case usableBatteryLevel(Int32)

  }

  /// 1 decimal
  enum OneOf_OptionalChargeEnergyAdded: Equatable, Sendable {
    case chargeEnergyAdded(Float)

  }

  enum OneOf_OptionalChargeMilesAddedRated: Equatable, Sendable {
    case chargeMilesAddedRated(Float)

  }

  enum OneOf_OptionalChargeMilesAddedIdeal: Equatable, Sendable {
    case chargeMilesAddedIdeal(Float)

  }

  enum OneOf_OptionalChargerVoltage: Equatable, Sendable {
    case chargerVoltage(Int32)

  }

  enum OneOf_OptionalChargerPilotCurrent: Equatable, Sendable {
    case chargerPilotCurrent(Int32)

  }

  enum OneOf_OptionalChargerActualCurrent: Equatable, Sendable {
    case chargerActualCurrent(Int32)

  }

  enum OneOf_OptionalChargerPower: Equatable, Sendable {
    case chargerPower(Int32)

  }

  enum OneOf_OptionalMinutesToFullCharge: Equatable, Sendable {
    case minutesToFullCharge(Int32)

  }

  enum OneOf_OptionalMinutesToChargeLimit: Equatable, Sendable {
    case minutesToChargeLimit(Int32)

  }

  enum OneOf_OptionalTripCharging: Equatable, Sendable {
    case tripCharging(Bool)

  }

  enum OneOf_OptionalChargeRateMph: Equatable, Sendable {
    case chargeRateMph(Int32)

  }

  enum OneOf_OptionalChargePortDoorOpen: Equatable, Sendable {
    case chargePortDoorOpen(Bool)

  }

  /// seconds / datetime
  enum OneOf_OptionalScheduledChargingStartTime: Equatable, Sendable {
    case scheduledChargingStartTime(UInt64)

  }

  enum OneOf_OptionalScheduledChargingPending: Equatable, Sendable {
    case scheduledChargingPending(Bool)

  }

  enum OneOf_OptionalUserChargeEnableRequest: Equatable, Sendable {
    case userChargeEnableRequest(Bool)

  }

  enum OneOf_OptionalChargeEnableRequest: Equatable, Sendable {
    case chargeEnableRequest(Bool)

  }

  enum OneOf_OptionalChargerPhases: Equatable, Sendable {
    case chargerPhases(Int32)

  }

  enum OneOf_OptionalChargePortColdWeatherMode: Equatable, Sendable {
    case chargePortColdWeatherMode(Bool)

  }

  enum OneOf_OptionalChargeCurrentRequest: Equatable, Sendable {
    case chargeCurrentRequest(Int32)

  }

  enum OneOf_OptionalChargeCurrentRequestMax: Equatable, Sendable {
    case chargeCurrentRequestMax(Int32)

  }

  enum OneOf_OptionalManagedChargingActive: Equatable, Sendable {
    case managedChargingActive(Bool)

  }

  enum OneOf_OptionalManagedChargingUserCanceled: Equatable, Sendable {
    case managedChargingUserCanceled(Bool)

  }

  enum OneOf_OptionalManagedChargingStartTime: Equatable, Sendable {
    case managedChargingStartTime(UInt64)

  }

  enum OneOf_OptionalOffPeakHoursEndTime: Equatable, Sendable {
    case offPeakHoursEndTime(UInt32)

  }

  enum OneOf_OptionalScheduledChargingMode: Equatable, Sendable {
    case scheduledChargingMode(CarServer_ChargeState.ScheduledChargingMode)

  }

  enum OneOf_OptionalChargingAmps: Equatable, Sendable {
    case chargingAmps(Int32)

  }

  enum OneOf_OptionalScheduledChargingStartTimeMinutes: Equatable, Sendable {
    case scheduledChargingStartTimeMinutes(UInt32)

  }

  enum OneOf_OptionalScheduledDepartureTimeMinutes: Equatable, Sendable {
    case scheduledDepartureTimeMinutes(UInt32)

  }

  enum OneOf_OptionalPreconditioningEnabled: Equatable, Sendable {
    case preconditioningEnabled(Bool)

  }

  enum OneOf_OptionalScheduledChargingStartTimeApp: Equatable, Sendable {
    case scheduledChargingStartTimeApp(Int32)

  }

  enum OneOf_OptionalSuperchargerSessionTripPlanner: Equatable, Sendable {
    case superchargerSessionTripPlanner(Bool)

  }

  enum OneOf_OptionalChargePortColor: Equatable, Sendable {
    case chargePortColor(CarServer_ChargeState.ChargePortColor_E)

  }

  enum OneOf_OptionalChargeRateMphFloat: Equatable, Sendable {
    case chargeRateMphFloat(Float)

  }

  enum OneOf_OptionalChargeLimitReason: Equatable, Sendable {
    case chargeLimitReason(CarServer_ChargeState.ChargeLimitReason)

  }

  enum OneOf_OptionalChargeCableUnlatched: Equatable, Sendable {
    case chargeCableUnlatched(Bool)

  }

  enum OneOf_OptionalOutletState: Equatable, Sendable {
    case outletState(CarServer_ChargeState.OutletState)

  }

  enum OneOf_OptionalPowerFeedState: Equatable, Sendable {
    case powerFeedState(CarServer_ChargeState.PowerFeedState)

  }

  enum OneOf_OptionOutletSocLimit: Equatable, Sendable {
    case outletSocLimit(Int32)

  }

  enum OneOf_OptionPowerFeedSocLimit: Equatable, Sendable {
    case powerFeedSocLimit(Int32)

  }

  enum OneOf_OptionOutletTimeRemaining: Equatable, Sendable {
    case outletTimeRemaining(Int64)

  }

  enum OneOf_OptionPowerFeedTimeRemaining: Equatable, Sendable {
    case powerFeedTimeRemaining(Int64)

  }

  enum OneOf_OptionalPowershareFeatureAllowed: Equatable, Sendable {
    case powershareFeatureAllowed(Bool)

  }

  enum OneOf_OptionalPowershareFeatureEnabled: Equatable, Sendable {
    case powershareFeatureEnabled(Bool)

  }

  enum OneOf_OptionalPowershareRequest: Equatable, Sendable {
    case powershareRequest(Bool)

  }

  enum OneOf_OptionalPowershareType: Equatable, Sendable {
    case powershareType(CarServer_ChargeState.PowershareType)

  }

  enum OneOf_OptionalPowershareStatus: Equatable, Sendable {
    case powershareStatus(CarServer_ChargeState.PowershareStatus)

  }

  enum OneOf_OptionalPowershareStopReason: Equatable, Sendable {
    case powershareStopReason(CarServer_ChargeState.PowershareStopReason)

  }

  enum OneOf_OptionalPowershareInstantaneousLoadKw: Equatable, Sendable {
    case powershareInstantaneousLoadKw(Float)

  }

  enum OneOf_OptionalPowershareVehicleEnergyLeftHr: Equatable, Sendable {
    case powershareVehicleEnergyLeftHr(Int32)

  }

  enum OneOf_OptionalPowershareSocLimit: Equatable, Sendable {
    case powershareSocLimit(Int32)

  }

  enum OneOf_OptionalOneTimeSocLimit: Equatable, Sendable {
    case oneTimeSocLimit(Int32)

  }

  enum OneOf_OptionalHomeLocation: Equatable, Sendable {
    case homeLocation(CarServer_LatLong)

  }

  enum OneOf_OptionalWorkLocation: Equatable, Sendable {
    case workLocation(CarServer_LatLong)

  }

  enum OneOf_OptionalOutletMaxTimerMinutes: Equatable, Sendable {
    case outletMaxTimerMinutes(Int32)

  }

  enum ScheduledChargingMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case off // = 0
    case startAt // = 1
    case departBy // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .off
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .off
      case 1: self = .startAt
      case 2: self = .departBy
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .off: return 0
      case .startAt: return 1
      case .departBy: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ChargeState.ScheduledChargingMode] = [
      .off,
      .startAt,
      .departBy,
    ]

  }

  enum ChargePortColor_E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case chargePortColorOff // = 0
    case chargePortColorRed // = 1
    case chargePortColorGreen // = 2
    case chargePortColorBlue // = 3
    case chargePortColorWhite // = 4
    case chargePortColorFlashingGreen // = 5
    case chargePortColorFlashingAmber // = 6
    case chargePortColorAmber // = 7
    case chargePortColorRave // = 8
    case chargePortColorDebug // = 9
    case chargePortColorFlashingBlue // = 10
    case UNRECOGNIZED(Int)

    init() {
      self = .chargePortColorOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chargePortColorOff
      case 1: self = .chargePortColorRed
      case 2: self = .chargePortColorGreen
      case 3: self = .chargePortColorBlue
      case 4: self = .chargePortColorWhite
      case 5: self = .chargePortColorFlashingGreen
      case 6: self = .chargePortColorFlashingAmber
      case 7: self = .chargePortColorAmber
      case 8: self = .chargePortColorRave
      case 9: self = .chargePortColorDebug
      case 10: self = .chargePortColorFlashingBlue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .chargePortColorOff: return 0
      case .chargePortColorRed: return 1
      case .chargePortColorGreen: return 2
      case .chargePortColorBlue: return 3
      case .chargePortColorWhite: return 4
      case .chargePortColorFlashingGreen: return 5
      case .chargePortColorFlashingAmber: return 6
      case .chargePortColorAmber: return 7
      case .chargePortColorRave: return 8
      case .chargePortColorDebug: return 9
      case .chargePortColorFlashingBlue: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ChargeState.ChargePortColor_E] = [
      .chargePortColorOff,
      .chargePortColorRed,
      .chargePortColorGreen,
      .chargePortColorBlue,
      .chargePortColorWhite,
      .chargePortColorFlashingGreen,
      .chargePortColorFlashingAmber,
      .chargePortColorAmber,
      .chargePortColorRave,
      .chargePortColorDebug,
      .chargePortColorFlashingBlue,
    ]

  }

  enum ChargeLimitReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case none // = 1
    case evse // = 2
    case battTempLow // = 3
    case highSoc // = 4
    case cabin // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .evse
      case 3: self = .battTempLow
      case 4: self = .highSoc
      case 5: self = .cabin
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .evse: return 2
      case .battTempLow: return 3
      case .highSoc: return 4
      case .cabin: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ChargeState.ChargeLimitReason] = [
      .unknown,
      .none,
      .evse,
      .battTempLow,
      .highSoc,
      .cabin,
    ]

  }

  enum OutletState: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case off // = 0
    case cabinAndBed // = 1
    case cabin // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .off
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .off
      case 1: self = .cabinAndBed
      case 2: self = .cabin
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .off: return 0
      case .cabinAndBed: return 1
      case .cabin: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ChargeState.OutletState] = [
      .off,
      .cabinAndBed,
      .cabin,
    ]

  }

  enum PowerFeedState: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case off // = 0
    case cabinAndBed // = 1
    case cabin // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .off
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .off
      case 1: self = .cabinAndBed
      case 2: self = .cabin
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .off: return 0
      case .cabinAndBed: return 1
      case .cabin: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ChargeState.PowerFeedState] = [
      .off,
      .cabinAndBed,
      .cabin,
    ]

  }

  enum PowershareStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// disconnected or connected, but don't know if powershare capable
    case inactive // = 0

    /// initializing
    case init_ // = 1

    /// actively powersharing
    case active // = 2

    /// powersharing has stopped - either standby or faulted or blocked; look at stopReason
    case stopped // = 3

    /// powersharing is handshaking
    case handshaking // = 4

    /// powersharing is active, but reconnecting soon
    case activeReconnectingSoon // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .inactive
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .inactive
      case 1: self = .init_
      case 2: self = .active
      case 3: self = .stopped
      case 4: self = .handshaking
      case 5: self = .activeReconnectingSoon
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .inactive: return 0
      case .init_: return 1
      case .active: return 2
      case .stopped: return 3
      case .handshaking: return 4
      case .activeReconnectingSoon: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ChargeState.PowershareStatus] = [
      .inactive,
      .init_,
      .active,
      .stopped,
      .handshaking,
      .activeReconnectingSoon,
    ]

  }

  enum PowershareType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case none // = 0
    case load // = 1
    case home // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .load
      case 2: self = .home
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .load: return 1
      case .home: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ChargeState.PowershareType] = [
      .none,
      .load,
      .home,
    ]

  }

  enum PowershareStopReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case none // = 0
    case soctooLow // = 1
    case retry // = 2
    case fault // = 3
    case user // = 4
    case reconnecting // = 5
    case authentication // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .soctooLow
      case 2: self = .retry
      case 3: self = .fault
      case 4: self = .user
      case 5: self = .reconnecting
      case 6: self = .authentication
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .soctooLow: return 1
      case .retry: return 2
      case .fault: return 3
      case .user: return 4
      case .reconnecting: return 5
      case .authentication: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ChargeState.PowershareStopReason] = [
      .none,
      .soctooLow,
      .retry,
      .fault,
      .user,
      .reconnecting,
      .authentication,
    ]

  }

  struct CableType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_ChargeState.CableType.OneOf_Type? = nil

    var sna: CarServer_Void {
      get {
        if case .sna(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .sna(newValue)}
    }

    var iec: CarServer_Void {
      get {
        if case .iec(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .iec(newValue)}
    }

    var sae: CarServer_Void {
      get {
        if case .sae(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .sae(newValue)}
    }

    var gbAc: CarServer_Void {
      get {
        if case .gbAc(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .gbAc(newValue)}
    }

    var gbDc: CarServer_Void {
      get {
        if case .gbDc(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .gbDc(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case sna(CarServer_Void)
      case iec(CarServer_Void)
      case sae(CarServer_Void)
      case gbAc(CarServer_Void)
      case gbDc(CarServer_Void)

    }

    init() {}
  }

  struct ChargerType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_ChargeState.ChargerType.OneOf_Type? = nil

    var sna: CarServer_Void {
      get {
        if case .sna(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .sna(newValue)}
    }

    var supercharger: CarServer_Void {
      get {
        if case .supercharger(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .supercharger(newValue)}
    }

    var chademo: CarServer_Void {
      get {
        if case .chademo(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .chademo(newValue)}
    }

    var gb: CarServer_Void {
      get {
        if case .gb(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .gb(newValue)}
    }

    var acsingleWireCan: CarServer_Void {
      get {
        if case .acsingleWireCan(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .acsingleWireCan(newValue)}
    }

    var combo: CarServer_Void {
      get {
        if case .combo(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .combo(newValue)}
    }

    var mcsingleWireCan: CarServer_Void {
      get {
        if case .mcsingleWireCan(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .mcsingleWireCan(newValue)}
    }

    var other: CarServer_Void {
      get {
        if case .other(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .other(newValue)}
    }

    var tesla: CarServer_Void {
      get {
        if case .tesla(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .tesla(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case sna(CarServer_Void)
      case supercharger(CarServer_Void)
      case chademo(CarServer_Void)
      case gb(CarServer_Void)
      case acsingleWireCan(CarServer_Void)
      case combo(CarServer_Void)
      case mcsingleWireCan(CarServer_Void)
      case other(CarServer_Void)
      case tesla(CarServer_Void)

    }

    init() {}
  }

  struct ChargingState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_ChargeState.ChargingState.OneOf_Type? = nil

    var unknown: CarServer_Void {
      get {
        if case .unknown(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .unknown(newValue)}
    }

    var disconnected: CarServer_Void {
      get {
        if case .disconnected(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .disconnected(newValue)}
    }

    var noPower: CarServer_Void {
      get {
        if case .noPower(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .noPower(newValue)}
    }

    var starting: CarServer_Void {
      get {
        if case .starting(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .starting(newValue)}
    }

    var charging: CarServer_Void {
      get {
        if case .charging(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .charging(newValue)}
    }

    var complete: CarServer_Void {
      get {
        if case .complete(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .complete(newValue)}
    }

    var stopped: CarServer_Void {
      get {
        if case .stopped(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .stopped(newValue)}
    }

    var calibrating: CarServer_Void {
      get {
        if case .calibrating(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .calibrating(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case unknown(CarServer_Void)
      case disconnected(CarServer_Void)
      case noPower(CarServer_Void)
      case starting(CarServer_Void)
      case charging(CarServer_Void)
      case complete(CarServer_Void)
      case stopped(CarServer_Void)
      case calibrating(CarServer_Void)

    }

    init() {}
  }

  struct ChargerBrand: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_ChargeState.ChargerBrand.OneOf_Type? = nil

    var tesla: CarServer_Void {
      get {
        if case .tesla(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .tesla(newValue)}
    }

    var sna: CarServer_Void {
      get {
        if case .sna(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .sna(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case tesla(CarServer_Void)
      case sna(CarServer_Void)

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CarServer_ManagedChargingState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeOnSolarState: CarServer_ChargeOnSolarState {
    get {return _chargeOnSolarState ?? CarServer_ChargeOnSolarState()}
    set {_chargeOnSolarState = newValue}
  }
  /// Returns true if `chargeOnSolarState` has been explicitly set.
  var hasChargeOnSolarState: Bool {return self._chargeOnSolarState != nil}
  /// Clears the value of `chargeOnSolarState`. Subsequent reads from it will return its default value.
  mutating func clearChargeOnSolarState() {self._chargeOnSolarState = nil}

  var optionalChargeOnSolarGatewayDin: CarServer_ManagedChargingState.OneOf_OptionalChargeOnSolarGatewayDin? = nil

  var chargeOnSolarGatewayDin: String {
    get {
      if case .chargeOnSolarGatewayDin(let v)? = optionalChargeOnSolarGatewayDin {return v}
      return String()
    }
    set {optionalChargeOnSolarGatewayDin = .chargeOnSolarGatewayDin(newValue)}
  }

  var optionalTeslaElectricAssetID: CarServer_ManagedChargingState.OneOf_OptionalTeslaElectricAssetID? = nil

  var teslaElectricAssetID: String {
    get {
      if case .teslaElectricAssetID(let v)? = optionalTeslaElectricAssetID {return v}
      return String()
    }
    set {optionalTeslaElectricAssetID = .teslaElectricAssetID(newValue)}
  }

  var optionalMinutesToLowerLimit: CarServer_ManagedChargingState.OneOf_OptionalMinutesToLowerLimit? = nil

  var minutesToLowerLimit: Int32 {
    get {
      if case .minutesToLowerLimit(let v)? = optionalMinutesToLowerLimit {return v}
      return 0
    }
    set {optionalMinutesToLowerLimit = .minutesToLowerLimit(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalChargeOnSolarGatewayDin: Equatable, Sendable {
    case chargeOnSolarGatewayDin(String)

  }

  enum OneOf_OptionalTeslaElectricAssetID: Equatable, Sendable {
    case teslaElectricAssetID(String)

  }

  enum OneOf_OptionalMinutesToLowerLimit: Equatable, Sendable {
    case minutesToLowerLimit(Int32)

  }

  init() {}

  fileprivate var _chargeOnSolarState: CarServer_ChargeOnSolarState? = nil
}

struct CarServer_ChargeOnSolarState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The state of the charge on solar managed charging feature.
  var state: CarServer_ChargeOnSolarState.OneOf_State? = nil

  /// Conditions do not support the Charge on Solar feature. For example, the vehicle may not be located at
  /// a managed charging site.
  var notAllowed: CarServer_ChargeOnSolarStateNotAllowed {
    get {
      if case .notAllowed(let v)? = state {return v}
      return CarServer_ChargeOnSolarStateNotAllowed()
    }
    set {state = .notAllowed(newValue)}
  }

  /// The vehicle is receiving no charge recommended commands from the site controller.
  var noChargeRecommended: CarServer_ChargeOnSolarStateNoChargeRecommended {
    get {
      if case .noChargeRecommended(let v)? = state {return v}
      return CarServer_ChargeOnSolarStateNoChargeRecommended()
    }
    set {state = .noChargeRecommended(newValue)}
  }

  /// The vehicle is actively following charge on solar recommended charge power.
  var chargingOnExcessSolar: CarServer_ChargeOnSolarStateChargingOnExcessSolar {
    get {
      if case .chargingOnExcessSolar(let v)? = state {return v}
      return CarServer_ChargeOnSolarStateChargingOnExcessSolar()
    }
    set {state = .chargingOnExcessSolar(newValue)}
  }

  /// The vehicle is charging at full power on any source.
  var chargingOnAnything: CarServer_ChargeOnSolarStateChargingOnAnything {
    get {
      if case .chargingOnAnything(let v)? = state {return v}
      return CarServer_ChargeOnSolarStateChargingOnAnything()
    }
    set {state = .chargingOnAnything(newValue)}
  }

  /// The user disabled the charge on solar feature.
  var userDisabled: CarServer_ChargeOnSolarStateUserDisabled {
    get {
      if case .userDisabled(let v)? = state {return v}
      return CarServer_ChargeOnSolarStateUserDisabled()
    }
    set {state = .userDisabled(newValue)}
  }

  /// The vehicle just entered a valid state for Charge on Solar and is waiting for an initial
  /// response from the site controller. It will wait in this state for a configured amount of time before entering
  /// the ChargeOnSolarError state if it does not receive a successful response from the site controller.
  var waitingForServer: CarServer_ChargeOnSolarStateWaitingForServer {
    get {
      if case .waitingForServer(let v)? = state {return v}
      return CarServer_ChargeOnSolarStateWaitingForServer()
    }
    set {state = .waitingForServer(newValue)}
  }

  /// The managed charging service has received a sustained number of error responses and the
  /// ChargingManager is no longer following the charge on solar power set points.
  var error: CarServer_ChargeOnSolarStateError {
    get {
      if case .error(let v)? = state {return v}
      return CarServer_ChargeOnSolarStateError()
    }
    set {state = .error(newValue)}
  }

  /// The user pressed the Stop Charging button during a Charge on Solar session.
  var userStopped: CarServer_ChargeOnSolarStateUserStopped {
    get {
      if case .userStopped(let v)? = state {return v}
      return CarServer_ChargeOnSolarStateUserStopped()
    }
    set {state = .userStopped(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The state of the charge on solar managed charging feature.
  enum OneOf_State: Equatable, Sendable {
    /// Conditions do not support the Charge on Solar feature. For example, the vehicle may not be located at
    /// a managed charging site.
    case notAllowed(CarServer_ChargeOnSolarStateNotAllowed)
    /// The vehicle is receiving no charge recommended commands from the site controller.
    case noChargeRecommended(CarServer_ChargeOnSolarStateNoChargeRecommended)
    /// The vehicle is actively following charge on solar recommended charge power.
    case chargingOnExcessSolar(CarServer_ChargeOnSolarStateChargingOnExcessSolar)
    /// The vehicle is charging at full power on any source.
    case chargingOnAnything(CarServer_ChargeOnSolarStateChargingOnAnything)
    /// The user disabled the charge on solar feature.
    case userDisabled(CarServer_ChargeOnSolarStateUserDisabled)
    /// The vehicle just entered a valid state for Charge on Solar and is waiting for an initial
    /// response from the site controller. It will wait in this state for a configured amount of time before entering
    /// the ChargeOnSolarError state if it does not receive a successful response from the site controller.
    case waitingForServer(CarServer_ChargeOnSolarStateWaitingForServer)
    /// The managed charging service has received a sustained number of error responses and the
    /// ChargingManager is no longer following the charge on solar power set points.
    case error(CarServer_ChargeOnSolarStateError)
    /// The user pressed the Stop Charging button during a Charge on Solar session.
    case userStopped(CarServer_ChargeOnSolarStateUserStopped)

  }

  init() {}
}

/// Conditions do not support the Charge on Solar feature. For example, the vehicle may not be located at
/// a managed charging site.
struct CarServer_ChargeOnSolarStateNotAllowed: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Charge on solar is enabled and the vehicle SOC is above the lower limit, however the
/// vehicle is not charging off solar for one or more reasons.
/// We return the highest priority reason to the mobile app.
struct CarServer_ChargeOnSolarStateNoChargeRecommended: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: ManagedCharging_ChargeOnSolarNoChargeReason = .invalid

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Charge on solar is enabled and the conditions allow for charging on solar.
/// The SOC may be above or below the lower left charging limit.
struct CarServer_ChargeOnSolarStateChargingOnExcessSolar: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The vehicle is charging at full power on any source.
struct CarServer_ChargeOnSolarStateChargingOnAnything: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The user disabled the charge on solar feature.
struct CarServer_ChargeOnSolarStateUserDisabled: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The vehicle just entered a valid state for Charge on Solar and is waiting for an initial
/// response from the site controller. It will wait in this state for 15min before entering
/// the ChargeOnSolarError state if it does not receive a successful response from the site controller.
struct CarServer_ChargeOnSolarStateWaitingForServer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The managed charging service has received a sustained number of error responses and the
/// ChargingManager is no longer following the charge on solar power set points.
struct CarServer_ChargeOnSolarStateError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The user pressed the Stop Charging button during a Charge on Solar session.
struct CarServer_ChargeOnSolarStateUserStopped: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LocationState contains information about the vehicle's location. Typically
/// clients will want to use native coordinates, which use either WGS
/// (international) or GCJ (Chinese) coordinate systems depending on the
/// vehicle's region. If the native fields are not provided, WGS clients should
/// fall back to the plain latitude/longitude fields, and GCJ clients should
/// fall back to corrected fields.
///
/// The geo fields contain raw WGS GPS coordinates. They are usually less
/// accurate. However, they should be used if there is a large discrepancy
/// between the raw and estimated location, as determined by the
/// "estimated to raw distance" field. This scenario most frequently arises when
/// the vehicle has recently been transported or towed.
struct CarServer_LocationState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var optionalLatitude: OneOf_OptionalLatitude? {
    get {return _storage._optionalLatitude}
    set {_uniqueStorage()._optionalLatitude = newValue}
  }

  var latitude: Float {
    get {
      if case .latitude(let v)? = _storage._optionalLatitude {return v}
      return 0
    }
    set {_uniqueStorage()._optionalLatitude = .latitude(newValue)}
  }

  var optionalLongitude: OneOf_OptionalLongitude? {
    get {return _storage._optionalLongitude}
    set {_uniqueStorage()._optionalLongitude = newValue}
  }

  var longitude: Float {
    get {
      if case .longitude(let v)? = _storage._optionalLongitude {return v}
      return 0
    }
    set {_uniqueStorage()._optionalLongitude = .longitude(newValue)}
  }

  var optionalHeading: OneOf_OptionalHeading? {
    get {return _storage._optionalHeading}
    set {_uniqueStorage()._optionalHeading = newValue}
  }

  var heading: UInt32 {
    get {
      if case .heading(let v)? = _storage._optionalHeading {return v}
      return 0
    }
    set {_uniqueStorage()._optionalHeading = .heading(newValue)}
  }

  var optionalGpsAsOf: OneOf_OptionalGpsAsOf? {
    get {return _storage._optionalGpsAsOf}
    set {_uniqueStorage()._optionalGpsAsOf = newValue}
  }

  var gpsAsOf: UInt64 {
    get {
      if case .gpsAsOf(let v)? = _storage._optionalGpsAsOf {return v}
      return 0
    }
    set {_uniqueStorage()._optionalGpsAsOf = .gpsAsOf(newValue)}
  }

  var optionalNativeLocationSupported: OneOf_OptionalNativeLocationSupported? {
    get {return _storage._optionalNativeLocationSupported}
    set {_uniqueStorage()._optionalNativeLocationSupported = newValue}
  }

  var nativeLocationSupported: Bool {
    get {
      if case .nativeLocationSupported(let v)? = _storage._optionalNativeLocationSupported {return v}
      return false
    }
    set {_uniqueStorage()._optionalNativeLocationSupported = .nativeLocationSupported(newValue)}
  }

  var optionalNativeLatitude: OneOf_OptionalNativeLatitude? {
    get {return _storage._optionalNativeLatitude}
    set {_uniqueStorage()._optionalNativeLatitude = newValue}
  }

  var nativeLatitude: Float {
    get {
      if case .nativeLatitude(let v)? = _storage._optionalNativeLatitude {return v}
      return 0
    }
    set {_uniqueStorage()._optionalNativeLatitude = .nativeLatitude(newValue)}
  }

  var optionalNativeLongitude: OneOf_OptionalNativeLongitude? {
    get {return _storage._optionalNativeLongitude}
    set {_uniqueStorage()._optionalNativeLongitude = newValue}
  }

  var nativeLongitude: Float {
    get {
      if case .nativeLongitude(let v)? = _storage._optionalNativeLongitude {return v}
      return 0
    }
    set {_uniqueStorage()._optionalNativeLongitude = .nativeLongitude(newValue)}
  }

  var nativeType: CarServer_LocationState.GPSCoordinateType {
    get {return _storage._nativeType ?? CarServer_LocationState.GPSCoordinateType()}
    set {_uniqueStorage()._nativeType = newValue}
  }
  /// Returns true if `nativeType` has been explicitly set.
  var hasNativeType: Bool {return _storage._nativeType != nil}
  /// Clears the value of `nativeType`. Subsequent reads from it will return its default value.
  mutating func clearNativeType() {_uniqueStorage()._nativeType = nil}

  var optionalCorrectedLatitude: OneOf_OptionalCorrectedLatitude? {
    get {return _storage._optionalCorrectedLatitude}
    set {_uniqueStorage()._optionalCorrectedLatitude = newValue}
  }

  var correctedLatitude: Float {
    get {
      if case .correctedLatitude(let v)? = _storage._optionalCorrectedLatitude {return v}
      return 0
    }
    set {_uniqueStorage()._optionalCorrectedLatitude = .correctedLatitude(newValue)}
  }

  var optionalCorrectedLongitude: OneOf_OptionalCorrectedLongitude? {
    get {return _storage._optionalCorrectedLongitude}
    set {_uniqueStorage()._optionalCorrectedLongitude = newValue}
  }

  var correctedLongitude: Float {
    get {
      if case .correctedLongitude(let v)? = _storage._optionalCorrectedLongitude {return v}
      return 0
    }
    set {_uniqueStorage()._optionalCorrectedLongitude = .correctedLongitude(newValue)}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var optionalHomelinkNearby: OneOf_OptionalHomelinkNearby? {
    get {return _storage._optionalHomelinkNearby}
    set {_uniqueStorage()._optionalHomelinkNearby = newValue}
  }

  var homelinkNearby: Bool {
    get {
      if case .homelinkNearby(let v)? = _storage._optionalHomelinkNearby {return v}
      return false
    }
    set {_uniqueStorage()._optionalHomelinkNearby = .homelinkNearby(newValue)}
  }

  var optionalLocationName: OneOf_OptionalLocationName? {
    get {return _storage._optionalLocationName}
    set {_uniqueStorage()._optionalLocationName = newValue}
  }

  var locationName: String {
    get {
      if case .locationName(let v)? = _storage._optionalLocationName {return v}
      return String()
    }
    set {_uniqueStorage()._optionalLocationName = .locationName(newValue)}
  }

  var optionalGeoLatitude: OneOf_OptionalGeoLatitude? {
    get {return _storage._optionalGeoLatitude}
    set {_uniqueStorage()._optionalGeoLatitude = newValue}
  }

  var geoLatitude: Float {
    get {
      if case .geoLatitude(let v)? = _storage._optionalGeoLatitude {return v}
      return 0
    }
    set {_uniqueStorage()._optionalGeoLatitude = .geoLatitude(newValue)}
  }

  var optionalGeoLongitude: OneOf_OptionalGeoLongitude? {
    get {return _storage._optionalGeoLongitude}
    set {_uniqueStorage()._optionalGeoLongitude = newValue}
  }

  var geoLongitude: Float {
    get {
      if case .geoLongitude(let v)? = _storage._optionalGeoLongitude {return v}
      return 0
    }
    set {_uniqueStorage()._optionalGeoLongitude = .geoLongitude(newValue)}
  }

  var optionalGeoHeading: OneOf_OptionalGeoHeading? {
    get {return _storage._optionalGeoHeading}
    set {_uniqueStorage()._optionalGeoHeading = newValue}
  }

  var geoHeading: Float {
    get {
      if case .geoHeading(let v)? = _storage._optionalGeoHeading {return v}
      return 0
    }
    set {_uniqueStorage()._optionalGeoHeading = .geoHeading(newValue)}
  }

  var optionalGeoElevation: OneOf_OptionalGeoElevation? {
    get {return _storage._optionalGeoElevation}
    set {_uniqueStorage()._optionalGeoElevation = newValue}
  }

  var geoElevation: Float {
    get {
      if case .geoElevation(let v)? = _storage._optionalGeoElevation {return v}
      return 0
    }
    set {_uniqueStorage()._optionalGeoElevation = .geoElevation(newValue)}
  }

  var optionalGeoAccuracy: OneOf_OptionalGeoAccuracy? {
    get {return _storage._optionalGeoAccuracy}
    set {_uniqueStorage()._optionalGeoAccuracy = newValue}
  }

  var geoAccuracy: Float {
    get {
      if case .geoAccuracy(let v)? = _storage._optionalGeoAccuracy {return v}
      return 0
    }
    set {_uniqueStorage()._optionalGeoAccuracy = .geoAccuracy(newValue)}
  }

  var optionalEstimatedGpsValid: OneOf_OptionalEstimatedGpsValid? {
    get {return _storage._optionalEstimatedGpsValid}
    set {_uniqueStorage()._optionalEstimatedGpsValid = newValue}
  }

  var estimatedGpsValid: Bool {
    get {
      if case .estimatedGpsValid(let v)? = _storage._optionalEstimatedGpsValid {return v}
      return false
    }
    set {_uniqueStorage()._optionalEstimatedGpsValid = .estimatedGpsValid(newValue)}
  }

  var optionalEstimatedToRawDistance: OneOf_OptionalEstimatedToRawDistance? {
    get {return _storage._optionalEstimatedToRawDistance}
    set {_uniqueStorage()._optionalEstimatedToRawDistance = newValue}
  }

  var estimatedToRawDistance: Float {
    get {
      if case .estimatedToRawDistance(let v)? = _storage._optionalEstimatedToRawDistance {return v}
      return 0
    }
    set {_uniqueStorage()._optionalEstimatedToRawDistance = .estimatedToRawDistance(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalLatitude: Equatable, Sendable {
    case latitude(Float)

  }

  enum OneOf_OptionalLongitude: Equatable, Sendable {
    case longitude(Float)

  }

  enum OneOf_OptionalHeading: Equatable, Sendable {
    case heading(UInt32)

  }

  enum OneOf_OptionalGpsAsOf: Equatable, Sendable {
    case gpsAsOf(UInt64)

  }

  enum OneOf_OptionalNativeLocationSupported: Equatable, Sendable {
    case nativeLocationSupported(Bool)

  }

  enum OneOf_OptionalNativeLatitude: Equatable, Sendable {
    case nativeLatitude(Float)

  }

  enum OneOf_OptionalNativeLongitude: Equatable, Sendable {
    case nativeLongitude(Float)

  }

  enum OneOf_OptionalCorrectedLatitude: Equatable, Sendable {
    case correctedLatitude(Float)

  }

  enum OneOf_OptionalCorrectedLongitude: Equatable, Sendable {
    case correctedLongitude(Float)

  }

  enum OneOf_OptionalHomelinkNearby: Equatable, Sendable {
    case homelinkNearby(Bool)

  }

  enum OneOf_OptionalLocationName: Equatable, Sendable {
    case locationName(String)

  }

  enum OneOf_OptionalGeoLatitude: Equatable, Sendable {
    case geoLatitude(Float)

  }

  enum OneOf_OptionalGeoLongitude: Equatable, Sendable {
    case geoLongitude(Float)

  }

  enum OneOf_OptionalGeoHeading: Equatable, Sendable {
    case geoHeading(Float)

  }

  enum OneOf_OptionalGeoElevation: Equatable, Sendable {
    case geoElevation(Float)

  }

  enum OneOf_OptionalGeoAccuracy: Equatable, Sendable {
    case geoAccuracy(Float)

  }

  enum OneOf_OptionalEstimatedGpsValid: Equatable, Sendable {
    case estimatedGpsValid(Bool)

  }

  enum OneOf_OptionalEstimatedToRawDistance: Equatable, Sendable {
    case estimatedToRawDistance(Float)

  }

  struct GPSCoordinateType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_LocationState.GPSCoordinateType.OneOf_Type? = nil

    var gcj: CarServer_Void {
      get {
        if case .gcj(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .gcj(newValue)}
    }

    var wgs: CarServer_Void {
      get {
        if case .wgs(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .wgs(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case gcj(CarServer_Void)
      case wgs(CarServer_Void)

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CarServer_VehicleState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var guestMode: CarServer_VehicleState.GuestMode {
    get {return _guestMode ?? CarServer_VehicleState.GuestMode()}
    set {_guestMode = newValue}
  }
  /// Returns true if `guestMode` has been explicitly set.
  var hasGuestMode: Bool {return self._guestMode != nil}
  /// Clears the value of `guestMode`. Subsequent reads from it will return its default value.
  mutating func clearGuestMode() {self._guestMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GuestMode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guestModeActive: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _guestMode: CarServer_VehicleState.GuestMode? = nil
}

struct CarServer_ClimateState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var optionalInsideTempCelsius: OneOf_OptionalInsideTempCelsius? {
    get {return _storage._optionalInsideTempCelsius}
    set {_uniqueStorage()._optionalInsideTempCelsius = newValue}
  }

  var insideTempCelsius: Float {
    get {
      if case .insideTempCelsius(let v)? = _storage._optionalInsideTempCelsius {return v}
      return 0
    }
    set {_uniqueStorage()._optionalInsideTempCelsius = .insideTempCelsius(newValue)}
  }

  var optionalOutsideTempCelsius: OneOf_OptionalOutsideTempCelsius? {
    get {return _storage._optionalOutsideTempCelsius}
    set {_uniqueStorage()._optionalOutsideTempCelsius = newValue}
  }

  var outsideTempCelsius: Float {
    get {
      if case .outsideTempCelsius(let v)? = _storage._optionalOutsideTempCelsius {return v}
      return 0
    }
    set {_uniqueStorage()._optionalOutsideTempCelsius = .outsideTempCelsius(newValue)}
  }

  var optionalDriverTempSetting: OneOf_OptionalDriverTempSetting? {
    get {return _storage._optionalDriverTempSetting}
    set {_uniqueStorage()._optionalDriverTempSetting = newValue}
  }

  var driverTempSetting: Float {
    get {
      if case .driverTempSetting(let v)? = _storage._optionalDriverTempSetting {return v}
      return 0
    }
    set {_uniqueStorage()._optionalDriverTempSetting = .driverTempSetting(newValue)}
  }

  var optionalPassengerTempSetting: OneOf_OptionalPassengerTempSetting? {
    get {return _storage._optionalPassengerTempSetting}
    set {_uniqueStorage()._optionalPassengerTempSetting = newValue}
  }

  var passengerTempSetting: Float {
    get {
      if case .passengerTempSetting(let v)? = _storage._optionalPassengerTempSetting {return v}
      return 0
    }
    set {_uniqueStorage()._optionalPassengerTempSetting = .passengerTempSetting(newValue)}
  }

  var optionalLeftTempDirection: OneOf_OptionalLeftTempDirection? {
    get {return _storage._optionalLeftTempDirection}
    set {_uniqueStorage()._optionalLeftTempDirection = newValue}
  }

  var leftTempDirection: Int32 {
    get {
      if case .leftTempDirection(let v)? = _storage._optionalLeftTempDirection {return v}
      return 0
    }
    set {_uniqueStorage()._optionalLeftTempDirection = .leftTempDirection(newValue)}
  }

  var optionalRightTempDirection: OneOf_OptionalRightTempDirection? {
    get {return _storage._optionalRightTempDirection}
    set {_uniqueStorage()._optionalRightTempDirection = newValue}
  }

  var rightTempDirection: Int32 {
    get {
      if case .rightTempDirection(let v)? = _storage._optionalRightTempDirection {return v}
      return 0
    }
    set {_uniqueStorage()._optionalRightTempDirection = .rightTempDirection(newValue)}
  }

  var optionalIsFrontDefrosterOn: OneOf_OptionalIsFrontDefrosterOn? {
    get {return _storage._optionalIsFrontDefrosterOn}
    set {_uniqueStorage()._optionalIsFrontDefrosterOn = newValue}
  }

  var isFrontDefrosterOn: Bool {
    get {
      if case .isFrontDefrosterOn(let v)? = _storage._optionalIsFrontDefrosterOn {return v}
      return false
    }
    set {_uniqueStorage()._optionalIsFrontDefrosterOn = .isFrontDefrosterOn(newValue)}
  }

  var optionalIsRearDefrosterOn: OneOf_OptionalIsRearDefrosterOn? {
    get {return _storage._optionalIsRearDefrosterOn}
    set {_uniqueStorage()._optionalIsRearDefrosterOn = newValue}
  }

  var isRearDefrosterOn: Bool {
    get {
      if case .isRearDefrosterOn(let v)? = _storage._optionalIsRearDefrosterOn {return v}
      return false
    }
    set {_uniqueStorage()._optionalIsRearDefrosterOn = .isRearDefrosterOn(newValue)}
  }

  var optionalFanStatus: OneOf_OptionalFanStatus? {
    get {return _storage._optionalFanStatus}
    set {_uniqueStorage()._optionalFanStatus = newValue}
  }

  var fanStatus: Int32 {
    get {
      if case .fanStatus(let v)? = _storage._optionalFanStatus {return v}
      return 0
    }
    set {_uniqueStorage()._optionalFanStatus = .fanStatus(newValue)}
  }

  var optionalIsClimateOn: OneOf_OptionalIsClimateOn? {
    get {return _storage._optionalIsClimateOn}
    set {_uniqueStorage()._optionalIsClimateOn = newValue}
  }

  var isClimateOn: Bool {
    get {
      if case .isClimateOn(let v)? = _storage._optionalIsClimateOn {return v}
      return false
    }
    set {_uniqueStorage()._optionalIsClimateOn = .isClimateOn(newValue)}
  }

  var optionalMinAvailTempCelsius: OneOf_OptionalMinAvailTempCelsius? {
    get {return _storage._optionalMinAvailTempCelsius}
    set {_uniqueStorage()._optionalMinAvailTempCelsius = newValue}
  }

  var minAvailTempCelsius: Float {
    get {
      if case .minAvailTempCelsius(let v)? = _storage._optionalMinAvailTempCelsius {return v}
      return 0
    }
    set {_uniqueStorage()._optionalMinAvailTempCelsius = .minAvailTempCelsius(newValue)}
  }

  var optionalMaxAvailTempCelsius: OneOf_OptionalMaxAvailTempCelsius? {
    get {return _storage._optionalMaxAvailTempCelsius}
    set {_uniqueStorage()._optionalMaxAvailTempCelsius = newValue}
  }

  var maxAvailTempCelsius: Float {
    get {
      if case .maxAvailTempCelsius(let v)? = _storage._optionalMaxAvailTempCelsius {return v}
      return 0
    }
    set {_uniqueStorage()._optionalMaxAvailTempCelsius = .maxAvailTempCelsius(newValue)}
  }

  var optionalSeatHeaterLeft: OneOf_OptionalSeatHeaterLeft? {
    get {return _storage._optionalSeatHeaterLeft}
    set {_uniqueStorage()._optionalSeatHeaterLeft = newValue}
  }

  var seatHeaterLeft: Int32 {
    get {
      if case .seatHeaterLeft(let v)? = _storage._optionalSeatHeaterLeft {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatHeaterLeft = .seatHeaterLeft(newValue)}
  }

  var optionalSeatHeaterRight: OneOf_OptionalSeatHeaterRight? {
    get {return _storage._optionalSeatHeaterRight}
    set {_uniqueStorage()._optionalSeatHeaterRight = newValue}
  }

  var seatHeaterRight: Int32 {
    get {
      if case .seatHeaterRight(let v)? = _storage._optionalSeatHeaterRight {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatHeaterRight = .seatHeaterRight(newValue)}
  }

  var optionalSeatHeaterRearLeft: OneOf_OptionalSeatHeaterRearLeft? {
    get {return _storage._optionalSeatHeaterRearLeft}
    set {_uniqueStorage()._optionalSeatHeaterRearLeft = newValue}
  }

  var seatHeaterRearLeft: Int32 {
    get {
      if case .seatHeaterRearLeft(let v)? = _storage._optionalSeatHeaterRearLeft {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatHeaterRearLeft = .seatHeaterRearLeft(newValue)}
  }

  var optionalSeatHeaterRearRight: OneOf_OptionalSeatHeaterRearRight? {
    get {return _storage._optionalSeatHeaterRearRight}
    set {_uniqueStorage()._optionalSeatHeaterRearRight = newValue}
  }

  var seatHeaterRearRight: Int32 {
    get {
      if case .seatHeaterRearRight(let v)? = _storage._optionalSeatHeaterRearRight {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatHeaterRearRight = .seatHeaterRearRight(newValue)}
  }

  var optionalSeatHeaterRearCenter: OneOf_OptionalSeatHeaterRearCenter? {
    get {return _storage._optionalSeatHeaterRearCenter}
    set {_uniqueStorage()._optionalSeatHeaterRearCenter = newValue}
  }

  var seatHeaterRearCenter: Int32 {
    get {
      if case .seatHeaterRearCenter(let v)? = _storage._optionalSeatHeaterRearCenter {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatHeaterRearCenter = .seatHeaterRearCenter(newValue)}
  }

  var optionalSeatHeaterRearRightBack: OneOf_OptionalSeatHeaterRearRightBack? {
    get {return _storage._optionalSeatHeaterRearRightBack}
    set {_uniqueStorage()._optionalSeatHeaterRearRightBack = newValue}
  }

  var seatHeaterRearRightBack: Int32 {
    get {
      if case .seatHeaterRearRightBack(let v)? = _storage._optionalSeatHeaterRearRightBack {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatHeaterRearRightBack = .seatHeaterRearRightBack(newValue)}
  }

  var optionalSeatHeaterRearLeftBack: OneOf_OptionalSeatHeaterRearLeftBack? {
    get {return _storage._optionalSeatHeaterRearLeftBack}
    set {_uniqueStorage()._optionalSeatHeaterRearLeftBack = newValue}
  }

  var seatHeaterRearLeftBack: Int32 {
    get {
      if case .seatHeaterRearLeftBack(let v)? = _storage._optionalSeatHeaterRearLeftBack {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatHeaterRearLeftBack = .seatHeaterRearLeftBack(newValue)}
  }

  var optionalSeatHeaterThirdRowRight: OneOf_OptionalSeatHeaterThirdRowRight? {
    get {return _storage._optionalSeatHeaterThirdRowRight}
    set {_uniqueStorage()._optionalSeatHeaterThirdRowRight = newValue}
  }

  var seatHeaterThirdRowRight: Int32 {
    get {
      if case .seatHeaterThirdRowRight(let v)? = _storage._optionalSeatHeaterThirdRowRight {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatHeaterThirdRowRight = .seatHeaterThirdRowRight(newValue)}
  }

  var optionalSeatHeaterThirdRowLeft: OneOf_OptionalSeatHeaterThirdRowLeft? {
    get {return _storage._optionalSeatHeaterThirdRowLeft}
    set {_uniqueStorage()._optionalSeatHeaterThirdRowLeft = newValue}
  }

  var seatHeaterThirdRowLeft: Int32 {
    get {
      if case .seatHeaterThirdRowLeft(let v)? = _storage._optionalSeatHeaterThirdRowLeft {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatHeaterThirdRowLeft = .seatHeaterThirdRowLeft(newValue)}
  }

  var optionalBatteryHeater: OneOf_OptionalBatteryHeater? {
    get {return _storage._optionalBatteryHeater}
    set {_uniqueStorage()._optionalBatteryHeater = newValue}
  }

  var batteryHeater: Bool {
    get {
      if case .batteryHeater(let v)? = _storage._optionalBatteryHeater {return v}
      return false
    }
    set {_uniqueStorage()._optionalBatteryHeater = .batteryHeater(newValue)}
  }

  var optionalBatteryHeaterNoPower: OneOf_OptionalBatteryHeaterNoPower? {
    get {return _storage._optionalBatteryHeaterNoPower}
    set {_uniqueStorage()._optionalBatteryHeaterNoPower = newValue}
  }

  var batteryHeaterNoPower: Bool {
    get {
      if case .batteryHeaterNoPower(let v)? = _storage._optionalBatteryHeaterNoPower {return v}
      return false
    }
    set {_uniqueStorage()._optionalBatteryHeaterNoPower = .batteryHeaterNoPower(newValue)}
  }

  var optionalSteeringWheelHeater: OneOf_OptionalSteeringWheelHeater? {
    get {return _storage._optionalSteeringWheelHeater}
    set {_uniqueStorage()._optionalSteeringWheelHeater = newValue}
  }

  var steeringWheelHeater: Bool {
    get {
      if case .steeringWheelHeater(let v)? = _storage._optionalSteeringWheelHeater {return v}
      return false
    }
    set {_uniqueStorage()._optionalSteeringWheelHeater = .steeringWheelHeater(newValue)}
  }

  var optionalWiperBladeHeater: OneOf_OptionalWiperBladeHeater? {
    get {return _storage._optionalWiperBladeHeater}
    set {_uniqueStorage()._optionalWiperBladeHeater = newValue}
  }

  var wiperBladeHeater: Bool {
    get {
      if case .wiperBladeHeater(let v)? = _storage._optionalWiperBladeHeater {return v}
      return false
    }
    set {_uniqueStorage()._optionalWiperBladeHeater = .wiperBladeHeater(newValue)}
  }

  var optionalSideMirrorHeaters: OneOf_OptionalSideMirrorHeaters? {
    get {return _storage._optionalSideMirrorHeaters}
    set {_uniqueStorage()._optionalSideMirrorHeaters = newValue}
  }

  var sideMirrorHeaters: Bool {
    get {
      if case .sideMirrorHeaters(let v)? = _storage._optionalSideMirrorHeaters {return v}
      return false
    }
    set {_uniqueStorage()._optionalSideMirrorHeaters = .sideMirrorHeaters(newValue)}
  }

  var optionalIsPreconditioning: OneOf_OptionalIsPreconditioning? {
    get {return _storage._optionalIsPreconditioning}
    set {_uniqueStorage()._optionalIsPreconditioning = newValue}
  }

  var isPreconditioning: Bool {
    get {
      if case .isPreconditioning(let v)? = _storage._optionalIsPreconditioning {return v}
      return false
    }
    set {_uniqueStorage()._optionalIsPreconditioning = .isPreconditioning(newValue)}
  }

  var optionalRemoteHeaterControlEnabled: OneOf_OptionalRemoteHeaterControlEnabled? {
    get {return _storage._optionalRemoteHeaterControlEnabled}
    set {_uniqueStorage()._optionalRemoteHeaterControlEnabled = newValue}
  }

  var remoteHeaterControlEnabled: Bool {
    get {
      if case .remoteHeaterControlEnabled(let v)? = _storage._optionalRemoteHeaterControlEnabled {return v}
      return false
    }
    set {_uniqueStorage()._optionalRemoteHeaterControlEnabled = .remoteHeaterControlEnabled(newValue)}
  }

  var climateKeeperMode: CarServer_ClimateState.ClimateKeeperMode {
    get {return _storage._climateKeeperMode ?? CarServer_ClimateState.ClimateKeeperMode()}
    set {_uniqueStorage()._climateKeeperMode = newValue}
  }
  /// Returns true if `climateKeeperMode` has been explicitly set.
  var hasClimateKeeperMode: Bool {return _storage._climateKeeperMode != nil}
  /// Clears the value of `climateKeeperMode`. Subsequent reads from it will return its default value.
  mutating func clearClimateKeeperMode() {_uniqueStorage()._climateKeeperMode = nil}

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var optionalBioweaponModeOn: OneOf_OptionalBioweaponModeOn? {
    get {return _storage._optionalBioweaponModeOn}
    set {_uniqueStorage()._optionalBioweaponModeOn = newValue}
  }

  var bioweaponModeOn: Bool {
    get {
      if case .bioweaponModeOn(let v)? = _storage._optionalBioweaponModeOn {return v}
      return false
    }
    set {_uniqueStorage()._optionalBioweaponModeOn = .bioweaponModeOn(newValue)}
  }

  var defrostMode: CarServer_ClimateState.DefrostMode {
    get {return _storage._defrostMode ?? CarServer_ClimateState.DefrostMode()}
    set {_uniqueStorage()._defrostMode = newValue}
  }
  /// Returns true if `defrostMode` has been explicitly set.
  var hasDefrostMode: Bool {return _storage._defrostMode != nil}
  /// Clears the value of `defrostMode`. Subsequent reads from it will return its default value.
  mutating func clearDefrostMode() {_uniqueStorage()._defrostMode = nil}

  var optionalIsAutoConditioningOn: OneOf_OptionalIsAutoConditioningOn? {
    get {return _storage._optionalIsAutoConditioningOn}
    set {_uniqueStorage()._optionalIsAutoConditioningOn = newValue}
  }

  var isAutoConditioningOn: Bool {
    get {
      if case .isAutoConditioningOn(let v)? = _storage._optionalIsAutoConditioningOn {return v}
      return false
    }
    set {_uniqueStorage()._optionalIsAutoConditioningOn = .isAutoConditioningOn(newValue)}
  }

  var optionalAutoSeatClimateLeft: OneOf_OptionalAutoSeatClimateLeft? {
    get {return _storage._optionalAutoSeatClimateLeft}
    set {_uniqueStorage()._optionalAutoSeatClimateLeft = newValue}
  }

  var autoSeatClimateLeft: Bool {
    get {
      if case .autoSeatClimateLeft(let v)? = _storage._optionalAutoSeatClimateLeft {return v}
      return false
    }
    set {_uniqueStorage()._optionalAutoSeatClimateLeft = .autoSeatClimateLeft(newValue)}
  }

  var optionalAutoSeatClimateRight: OneOf_OptionalAutoSeatClimateRight? {
    get {return _storage._optionalAutoSeatClimateRight}
    set {_uniqueStorage()._optionalAutoSeatClimateRight = newValue}
  }

  var autoSeatClimateRight: Bool {
    get {
      if case .autoSeatClimateRight(let v)? = _storage._optionalAutoSeatClimateRight {return v}
      return false
    }
    set {_uniqueStorage()._optionalAutoSeatClimateRight = .autoSeatClimateRight(newValue)}
  }

  var optionalSeatFanFrontLeft: OneOf_OptionalSeatFanFrontLeft? {
    get {return _storage._optionalSeatFanFrontLeft}
    set {_uniqueStorage()._optionalSeatFanFrontLeft = newValue}
  }

  var seatFanFrontLeft: Int32 {
    get {
      if case .seatFanFrontLeft(let v)? = _storage._optionalSeatFanFrontLeft {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatFanFrontLeft = .seatFanFrontLeft(newValue)}
  }

  var optionalSeatFanFrontRight: OneOf_OptionalSeatFanFrontRight? {
    get {return _storage._optionalSeatFanFrontRight}
    set {_uniqueStorage()._optionalSeatFanFrontRight = newValue}
  }

  var seatFanFrontRight: Int32 {
    get {
      if case .seatFanFrontRight(let v)? = _storage._optionalSeatFanFrontRight {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSeatFanFrontRight = .seatFanFrontRight(newValue)}
  }

  var optionalAllowCabinOverheatProtection: OneOf_OptionalAllowCabinOverheatProtection? {
    get {return _storage._optionalAllowCabinOverheatProtection}
    set {_uniqueStorage()._optionalAllowCabinOverheatProtection = newValue}
  }

  var allowCabinOverheatProtection: Bool {
    get {
      if case .allowCabinOverheatProtection(let v)? = _storage._optionalAllowCabinOverheatProtection {return v}
      return false
    }
    set {_uniqueStorage()._optionalAllowCabinOverheatProtection = .allowCabinOverheatProtection(newValue)}
  }

  var optionalSupportsFanOnlyCabinOverheatProtection: OneOf_OptionalSupportsFanOnlyCabinOverheatProtection? {
    get {return _storage._optionalSupportsFanOnlyCabinOverheatProtection}
    set {_uniqueStorage()._optionalSupportsFanOnlyCabinOverheatProtection = newValue}
  }

  var supportsFanOnlyCabinOverheatProtection: Bool {
    get {
      if case .supportsFanOnlyCabinOverheatProtection(let v)? = _storage._optionalSupportsFanOnlyCabinOverheatProtection {return v}
      return false
    }
    set {_uniqueStorage()._optionalSupportsFanOnlyCabinOverheatProtection = .supportsFanOnlyCabinOverheatProtection(newValue)}
  }

  var optionalCabinOverheatProtection: OneOf_OptionalCabinOverheatProtection? {
    get {return _storage._optionalCabinOverheatProtection}
    set {_uniqueStorage()._optionalCabinOverheatProtection = newValue}
  }

  var cabinOverheatProtection: CarServer_ClimateState.CabinOverheatProtection_E {
    get {
      if case .cabinOverheatProtection(let v)? = _storage._optionalCabinOverheatProtection {return v}
      return .cabinOverheatProtectionOff
    }
    set {_uniqueStorage()._optionalCabinOverheatProtection = .cabinOverheatProtection(newValue)}
  }

  var optionalCabinOverheatProtectionActivelyCooling: OneOf_OptionalCabinOverheatProtectionActivelyCooling? {
    get {return _storage._optionalCabinOverheatProtectionActivelyCooling}
    set {_uniqueStorage()._optionalCabinOverheatProtectionActivelyCooling = newValue}
  }

  var cabinOverheatProtectionActivelyCooling: Bool {
    get {
      if case .cabinOverheatProtectionActivelyCooling(let v)? = _storage._optionalCabinOverheatProtectionActivelyCooling {return v}
      return false
    }
    set {_uniqueStorage()._optionalCabinOverheatProtectionActivelyCooling = .cabinOverheatProtectionActivelyCooling(newValue)}
  }

  var optionalCopActivationTemperature: OneOf_OptionalCopActivationTemperature? {
    get {return _storage._optionalCopActivationTemperature}
    set {_uniqueStorage()._optionalCopActivationTemperature = newValue}
  }

  var copActivationTemperature: CarServer_ClimateState.CopActivationTemp {
    get {
      if case .copActivationTemperature(let v)? = _storage._optionalCopActivationTemperature {return v}
      return .unspecified
    }
    set {_uniqueStorage()._optionalCopActivationTemperature = .copActivationTemperature(newValue)}
  }

  var optionalAutoSteeringWheelHeat: OneOf_OptionalAutoSteeringWheelHeat? {
    get {return _storage._optionalAutoSteeringWheelHeat}
    set {_uniqueStorage()._optionalAutoSteeringWheelHeat = newValue}
  }

  var autoSteeringWheelHeat: Bool {
    get {
      if case .autoSteeringWheelHeat(let v)? = _storage._optionalAutoSteeringWheelHeat {return v}
      return false
    }
    set {_uniqueStorage()._optionalAutoSteeringWheelHeat = .autoSteeringWheelHeat(newValue)}
  }

  var optionalSteeringWheelHeatLevel: OneOf_OptionalSteeringWheelHeatLevel? {
    get {return _storage._optionalSteeringWheelHeatLevel}
    set {_uniqueStorage()._optionalSteeringWheelHeatLevel = newValue}
  }

  var steeringWheelHeatLevel: CarServer_StwHeatLevel {
    get {
      if case .steeringWheelHeatLevel(let v)? = _storage._optionalSteeringWheelHeatLevel {return v}
      return .unknown
    }
    set {_uniqueStorage()._optionalSteeringWheelHeatLevel = .steeringWheelHeatLevel(newValue)}
  }

  var optionalHvacAutoRequest: OneOf_OptionalHvacAutoRequest? {
    get {return _storage._optionalHvacAutoRequest}
    set {_uniqueStorage()._optionalHvacAutoRequest = newValue}
  }

  var hvacAutoRequest: CarServer_ClimateState.HvacAutoRequest {
    get {
      if case .hvacAutoRequest(let v)? = _storage._optionalHvacAutoRequest {return v}
      return .on
    }
    set {_uniqueStorage()._optionalHvacAutoRequest = .hvacAutoRequest(newValue)}
  }

  var optionalCopNotRunningReason: OneOf_OptionalCopNotRunningReason? {
    get {return _storage._optionalCopNotRunningReason}
    set {_uniqueStorage()._optionalCopNotRunningReason = newValue}
  }

  var copNotRunningReason: CarServer_ClimateState.COPNotRunningReason {
    get {
      if case .copNotRunningReason(let v)? = _storage._optionalCopNotRunningReason {return v}
      return .noReason
    }
    set {_uniqueStorage()._optionalCopNotRunningReason = .copNotRunningReason(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalInsideTempCelsius: Equatable, Sendable {
    case insideTempCelsius(Float)

  }

  enum OneOf_OptionalOutsideTempCelsius: Equatable, Sendable {
    case outsideTempCelsius(Float)

  }

  enum OneOf_OptionalDriverTempSetting: Equatable, Sendable {
    case driverTempSetting(Float)

  }

  enum OneOf_OptionalPassengerTempSetting: Equatable, Sendable {
    case passengerTempSetting(Float)

  }

  enum OneOf_OptionalLeftTempDirection: Equatable, Sendable {
    case leftTempDirection(Int32)

  }

  enum OneOf_OptionalRightTempDirection: Equatable, Sendable {
    case rightTempDirection(Int32)

  }

  enum OneOf_OptionalIsFrontDefrosterOn: Equatable, Sendable {
    case isFrontDefrosterOn(Bool)

  }

  enum OneOf_OptionalIsRearDefrosterOn: Equatable, Sendable {
    case isRearDefrosterOn(Bool)

  }

  enum OneOf_OptionalFanStatus: Equatable, Sendable {
    case fanStatus(Int32)

  }

  enum OneOf_OptionalIsClimateOn: Equatable, Sendable {
    case isClimateOn(Bool)

  }

  enum OneOf_OptionalMinAvailTempCelsius: Equatable, Sendable {
    case minAvailTempCelsius(Float)

  }

  enum OneOf_OptionalMaxAvailTempCelsius: Equatable, Sendable {
    case maxAvailTempCelsius(Float)

  }

  enum OneOf_OptionalSeatHeaterLeft: Equatable, Sendable {
    case seatHeaterLeft(Int32)

  }

  enum OneOf_OptionalSeatHeaterRight: Equatable, Sendable {
    case seatHeaterRight(Int32)

  }

  enum OneOf_OptionalSeatHeaterRearLeft: Equatable, Sendable {
    case seatHeaterRearLeft(Int32)

  }

  enum OneOf_OptionalSeatHeaterRearRight: Equatable, Sendable {
    case seatHeaterRearRight(Int32)

  }

  enum OneOf_OptionalSeatHeaterRearCenter: Equatable, Sendable {
    case seatHeaterRearCenter(Int32)

  }

  enum OneOf_OptionalSeatHeaterRearRightBack: Equatable, Sendable {
    case seatHeaterRearRightBack(Int32)

  }

  enum OneOf_OptionalSeatHeaterRearLeftBack: Equatable, Sendable {
    case seatHeaterRearLeftBack(Int32)

  }

  enum OneOf_OptionalSeatHeaterThirdRowRight: Equatable, Sendable {
    case seatHeaterThirdRowRight(Int32)

  }

  enum OneOf_OptionalSeatHeaterThirdRowLeft: Equatable, Sendable {
    case seatHeaterThirdRowLeft(Int32)

  }

  enum OneOf_OptionalBatteryHeater: Equatable, Sendable {
    case batteryHeater(Bool)

  }

  enum OneOf_OptionalBatteryHeaterNoPower: Equatable, Sendable {
    case batteryHeaterNoPower(Bool)

  }

  enum OneOf_OptionalSteeringWheelHeater: Equatable, Sendable {
    case steeringWheelHeater(Bool)

  }

  enum OneOf_OptionalWiperBladeHeater: Equatable, Sendable {
    case wiperBladeHeater(Bool)

  }

  enum OneOf_OptionalSideMirrorHeaters: Equatable, Sendable {
    case sideMirrorHeaters(Bool)

  }

  enum OneOf_OptionalIsPreconditioning: Equatable, Sendable {
    case isPreconditioning(Bool)

  }

  enum OneOf_OptionalRemoteHeaterControlEnabled: Equatable, Sendable {
    case remoteHeaterControlEnabled(Bool)

  }

  enum OneOf_OptionalBioweaponModeOn: Equatable, Sendable {
    case bioweaponModeOn(Bool)

  }

  enum OneOf_OptionalIsAutoConditioningOn: Equatable, Sendable {
    case isAutoConditioningOn(Bool)

  }

  enum OneOf_OptionalAutoSeatClimateLeft: Equatable, Sendable {
    case autoSeatClimateLeft(Bool)

  }

  enum OneOf_OptionalAutoSeatClimateRight: Equatable, Sendable {
    case autoSeatClimateRight(Bool)

  }

  enum OneOf_OptionalSeatFanFrontLeft: Equatable, Sendable {
    case seatFanFrontLeft(Int32)

  }

  enum OneOf_OptionalSeatFanFrontRight: Equatable, Sendable {
    case seatFanFrontRight(Int32)

  }

  enum OneOf_OptionalAllowCabinOverheatProtection: Equatable, Sendable {
    case allowCabinOverheatProtection(Bool)

  }

  enum OneOf_OptionalSupportsFanOnlyCabinOverheatProtection: Equatable, Sendable {
    case supportsFanOnlyCabinOverheatProtection(Bool)

  }

  enum OneOf_OptionalCabinOverheatProtection: Equatable, Sendable {
    case cabinOverheatProtection(CarServer_ClimateState.CabinOverheatProtection_E)

  }

  enum OneOf_OptionalCabinOverheatProtectionActivelyCooling: Equatable, Sendable {
    case cabinOverheatProtectionActivelyCooling(Bool)

  }

  enum OneOf_OptionalCopActivationTemperature: Equatable, Sendable {
    case copActivationTemperature(CarServer_ClimateState.CopActivationTemp)

  }

  enum OneOf_OptionalAutoSteeringWheelHeat: Equatable, Sendable {
    case autoSteeringWheelHeat(Bool)

  }

  enum OneOf_OptionalSteeringWheelHeatLevel: Equatable, Sendable {
    case steeringWheelHeatLevel(CarServer_StwHeatLevel)

  }

  enum OneOf_OptionalHvacAutoRequest: Equatable, Sendable {
    case hvacAutoRequest(CarServer_ClimateState.HvacAutoRequest)

  }

  enum OneOf_OptionalCopNotRunningReason: Equatable, Sendable {
    case copNotRunningReason(CarServer_ClimateState.COPNotRunningReason)

  }

  enum HvacAutoRequest: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case on // = 0
    case override // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .on
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .on
      case 1: self = .override
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .on: return 0
      case .override: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ClimateState.HvacAutoRequest] = [
      .on,
      .override,
    ]

  }

  enum CabinOverheatProtection_E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case cabinOverheatProtectionOff // = 0
    case cabinOverheatProtectionOn // = 1
    case cabinOverheatProtectionFanOnly // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .cabinOverheatProtectionOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cabinOverheatProtectionOff
      case 1: self = .cabinOverheatProtectionOn
      case 2: self = .cabinOverheatProtectionFanOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .cabinOverheatProtectionOff: return 0
      case .cabinOverheatProtectionOn: return 1
      case .cabinOverheatProtectionFanOnly: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ClimateState.CabinOverheatProtection_E] = [
      .cabinOverheatProtectionOff,
      .cabinOverheatProtectionOn,
      .cabinOverheatProtectionFanOnly,
    ]

  }

  enum SeatHeaterLevel_E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case seatHeaterLevelOff // = 0
    case seatHeaterLevelLow // = 1
    case seatHeaterLevelMed // = 2
    case seatHeaterLevelHigh // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .seatHeaterLevelOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .seatHeaterLevelOff
      case 1: self = .seatHeaterLevelLow
      case 2: self = .seatHeaterLevelMed
      case 3: self = .seatHeaterLevelHigh
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .seatHeaterLevelOff: return 0
      case .seatHeaterLevelLow: return 1
      case .seatHeaterLevelMed: return 2
      case .seatHeaterLevelHigh: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ClimateState.SeatHeaterLevel_E] = [
      .seatHeaterLevelOff,
      .seatHeaterLevelLow,
      .seatHeaterLevelMed,
      .seatHeaterLevelHigh,
    ]

  }

  enum SeatCoolingLevel_E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case seatCoolingLevelOff // = 0
    case seatCoolingLevelLow // = 1
    case seatCoolingLevelMed // = 2
    case seatCoolingLevelHigh // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .seatCoolingLevelOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .seatCoolingLevelOff
      case 1: self = .seatCoolingLevelLow
      case 2: self = .seatCoolingLevelMed
      case 3: self = .seatCoolingLevelHigh
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .seatCoolingLevelOff: return 0
      case .seatCoolingLevelLow: return 1
      case .seatCoolingLevelMed: return 2
      case .seatCoolingLevelHigh: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ClimateState.SeatCoolingLevel_E] = [
      .seatCoolingLevelOff,
      .seatCoolingLevelLow,
      .seatCoolingLevelMed,
      .seatCoolingLevelHigh,
    ]

  }

  enum CopActivationTemp: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unspecified // = 0
    case low // = 1
    case medium // = 2
    case high // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .low
      case 2: self = .medium
      case 3: self = .high
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .low: return 1
      case .medium: return 2
      case .high: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ClimateState.CopActivationTemp] = [
      .unspecified,
      .low,
      .medium,
      .high,
    ]

  }

  enum COPNotRunningReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case noReason // = 0
    case userInteraction // = 1
    case energyConsumptionReached // = 2
    case timeout // = 3
    case lowSolarLoad // = 4
    case fault // = 5
    case cabinBelowThreshold // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .noReason
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noReason
      case 1: self = .userInteraction
      case 2: self = .energyConsumptionReached
      case 3: self = .timeout
      case 4: self = .lowSolarLoad
      case 5: self = .fault
      case 6: self = .cabinBelowThreshold
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .noReason: return 0
      case .userInteraction: return 1
      case .energyConsumptionReached: return 2
      case .timeout: return 3
      case .lowSolarLoad: return 4
      case .fault: return 5
      case .cabinBelowThreshold: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [CarServer_ClimateState.COPNotRunningReason] = [
      .noReason,
      .userInteraction,
      .energyConsumptionReached,
      .timeout,
      .lowSolarLoad,
      .fault,
      .cabinBelowThreshold,
    ]

  }

  struct ClimateKeeperMode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_ClimateState.ClimateKeeperMode.OneOf_Type? = nil

    var unknown: CarServer_Void {
      get {
        if case .unknown(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .unknown(newValue)}
    }

    var off: CarServer_Void {
      get {
        if case .off(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .off(newValue)}
    }

    var on: CarServer_Void {
      get {
        if case .on(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .on(newValue)}
    }

    var dog: CarServer_Void {
      get {
        if case .dog(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .dog(newValue)}
    }

    var party: CarServer_Void {
      get {
        if case .party(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .party(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case unknown(CarServer_Void)
      case off(CarServer_Void)
      case on(CarServer_Void)
      case dog(CarServer_Void)
      case party(CarServer_Void)

    }

    init() {}
  }

  struct DefrostMode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CarServer_ClimateState.DefrostMode.OneOf_Type? = nil

    var off: CarServer_Void {
      get {
        if case .off(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .off(newValue)}
    }

    var normal: CarServer_Void {
      get {
        if case .normal(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .normal(newValue)}
    }

    var max: CarServer_Void {
      get {
        if case .max(let v)? = type {return v}
        return CarServer_Void()
      }
      set {type = .max(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case off(CarServer_Void)
      case normal(CarServer_Void)
      case max(CarServer_Void)

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CarServer_TirePressureState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tpms pressure values in bar
  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var optionalTpmsPressureFl: OneOf_OptionalTpmsPressureFl? {
    get {return _storage._optionalTpmsPressureFl}
    set {_uniqueStorage()._optionalTpmsPressureFl = newValue}
  }

  var tpmsPressureFl: Float {
    get {
      if case .tpmsPressureFl(let v)? = _storage._optionalTpmsPressureFl {return v}
      return 0
    }
    set {_uniqueStorage()._optionalTpmsPressureFl = .tpmsPressureFl(newValue)}
  }

  var optionalTpmsPressureFr: OneOf_OptionalTpmsPressureFr? {
    get {return _storage._optionalTpmsPressureFr}
    set {_uniqueStorage()._optionalTpmsPressureFr = newValue}
  }

  var tpmsPressureFr: Float {
    get {
      if case .tpmsPressureFr(let v)? = _storage._optionalTpmsPressureFr {return v}
      return 0
    }
    set {_uniqueStorage()._optionalTpmsPressureFr = .tpmsPressureFr(newValue)}
  }

  var optionalTpmsPressureRl: OneOf_OptionalTpmsPressureRl? {
    get {return _storage._optionalTpmsPressureRl}
    set {_uniqueStorage()._optionalTpmsPressureRl = newValue}
  }

  var tpmsPressureRl: Float {
    get {
      if case .tpmsPressureRl(let v)? = _storage._optionalTpmsPressureRl {return v}
      return 0
    }
    set {_uniqueStorage()._optionalTpmsPressureRl = .tpmsPressureRl(newValue)}
  }

  var optionalTpmsPressureRr: OneOf_OptionalTpmsPressureRr? {
    get {return _storage._optionalTpmsPressureRr}
    set {_uniqueStorage()._optionalTpmsPressureRr = newValue}
  }

  var tpmsPressureRr: Float {
    get {
      if case .tpmsPressureRr(let v)? = _storage._optionalTpmsPressureRr {return v}
      return 0
    }
    set {_uniqueStorage()._optionalTpmsPressureRr = .tpmsPressureRr(newValue)}
  }

  var tpmsLastSeenPressureTimeFl: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._tpmsLastSeenPressureTimeFl ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._tpmsLastSeenPressureTimeFl = newValue}
  }
  /// Returns true if `tpmsLastSeenPressureTimeFl` has been explicitly set.
  var hasTpmsLastSeenPressureTimeFl: Bool {return _storage._tpmsLastSeenPressureTimeFl != nil}
  /// Clears the value of `tpmsLastSeenPressureTimeFl`. Subsequent reads from it will return its default value.
  mutating func clearTpmsLastSeenPressureTimeFl() {_uniqueStorage()._tpmsLastSeenPressureTimeFl = nil}

  var tpmsLastSeenPressureTimeFr: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._tpmsLastSeenPressureTimeFr ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._tpmsLastSeenPressureTimeFr = newValue}
  }
  /// Returns true if `tpmsLastSeenPressureTimeFr` has been explicitly set.
  var hasTpmsLastSeenPressureTimeFr: Bool {return _storage._tpmsLastSeenPressureTimeFr != nil}
  /// Clears the value of `tpmsLastSeenPressureTimeFr`. Subsequent reads from it will return its default value.
  mutating func clearTpmsLastSeenPressureTimeFr() {_uniqueStorage()._tpmsLastSeenPressureTimeFr = nil}

  var tpmsLastSeenPressureTimeRl: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._tpmsLastSeenPressureTimeRl ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._tpmsLastSeenPressureTimeRl = newValue}
  }
  /// Returns true if `tpmsLastSeenPressureTimeRl` has been explicitly set.
  var hasTpmsLastSeenPressureTimeRl: Bool {return _storage._tpmsLastSeenPressureTimeRl != nil}
  /// Clears the value of `tpmsLastSeenPressureTimeRl`. Subsequent reads from it will return its default value.
  mutating func clearTpmsLastSeenPressureTimeRl() {_uniqueStorage()._tpmsLastSeenPressureTimeRl = nil}

  var tpmsLastSeenPressureTimeRr: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._tpmsLastSeenPressureTimeRr ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._tpmsLastSeenPressureTimeRr = newValue}
  }
  /// Returns true if `tpmsLastSeenPressureTimeRr` has been explicitly set.
  var hasTpmsLastSeenPressureTimeRr: Bool {return _storage._tpmsLastSeenPressureTimeRr != nil}
  /// Clears the value of `tpmsLastSeenPressureTimeRr`. Subsequent reads from it will return its default value.
  mutating func clearTpmsLastSeenPressureTimeRr() {_uniqueStorage()._tpmsLastSeenPressureTimeRr = nil}

  var optionalTpmsHardWarningFl: OneOf_OptionalTpmsHardWarningFl? {
    get {return _storage._optionalTpmsHardWarningFl}
    set {_uniqueStorage()._optionalTpmsHardWarningFl = newValue}
  }

  var tpmsHardWarningFl: Bool {
    get {
      if case .tpmsHardWarningFl(let v)? = _storage._optionalTpmsHardWarningFl {return v}
      return false
    }
    set {_uniqueStorage()._optionalTpmsHardWarningFl = .tpmsHardWarningFl(newValue)}
  }

  var optionalTpmsHardWarningFr: OneOf_OptionalTpmsHardWarningFr? {
    get {return _storage._optionalTpmsHardWarningFr}
    set {_uniqueStorage()._optionalTpmsHardWarningFr = newValue}
  }

  var tpmsHardWarningFr: Bool {
    get {
      if case .tpmsHardWarningFr(let v)? = _storage._optionalTpmsHardWarningFr {return v}
      return false
    }
    set {_uniqueStorage()._optionalTpmsHardWarningFr = .tpmsHardWarningFr(newValue)}
  }

  var optionalTpmsHardWarningRl: OneOf_OptionalTpmsHardWarningRl? {
    get {return _storage._optionalTpmsHardWarningRl}
    set {_uniqueStorage()._optionalTpmsHardWarningRl = newValue}
  }

  var tpmsHardWarningRl: Bool {
    get {
      if case .tpmsHardWarningRl(let v)? = _storage._optionalTpmsHardWarningRl {return v}
      return false
    }
    set {_uniqueStorage()._optionalTpmsHardWarningRl = .tpmsHardWarningRl(newValue)}
  }

  var optionalTpmsHardWarningRr: OneOf_OptionalTpmsHardWarningRr? {
    get {return _storage._optionalTpmsHardWarningRr}
    set {_uniqueStorage()._optionalTpmsHardWarningRr = newValue}
  }

  var tpmsHardWarningRr: Bool {
    get {
      if case .tpmsHardWarningRr(let v)? = _storage._optionalTpmsHardWarningRr {return v}
      return false
    }
    set {_uniqueStorage()._optionalTpmsHardWarningRr = .tpmsHardWarningRr(newValue)}
  }

  var optionalTpmsSoftWarningFl: OneOf_OptionalTpmsSoftWarningFl? {
    get {return _storage._optionalTpmsSoftWarningFl}
    set {_uniqueStorage()._optionalTpmsSoftWarningFl = newValue}
  }

  var tpmsSoftWarningFl: Bool {
    get {
      if case .tpmsSoftWarningFl(let v)? = _storage._optionalTpmsSoftWarningFl {return v}
      return false
    }
    set {_uniqueStorage()._optionalTpmsSoftWarningFl = .tpmsSoftWarningFl(newValue)}
  }

  var optionalTpmsSoftWarningFr: OneOf_OptionalTpmsSoftWarningFr? {
    get {return _storage._optionalTpmsSoftWarningFr}
    set {_uniqueStorage()._optionalTpmsSoftWarningFr = newValue}
  }

  var tpmsSoftWarningFr: Bool {
    get {
      if case .tpmsSoftWarningFr(let v)? = _storage._optionalTpmsSoftWarningFr {return v}
      return false
    }
    set {_uniqueStorage()._optionalTpmsSoftWarningFr = .tpmsSoftWarningFr(newValue)}
  }

  var optionalTpmsSoftWarningRl: OneOf_OptionalTpmsSoftWarningRl? {
    get {return _storage._optionalTpmsSoftWarningRl}
    set {_uniqueStorage()._optionalTpmsSoftWarningRl = newValue}
  }

  var tpmsSoftWarningRl: Bool {
    get {
      if case .tpmsSoftWarningRl(let v)? = _storage._optionalTpmsSoftWarningRl {return v}
      return false
    }
    set {_uniqueStorage()._optionalTpmsSoftWarningRl = .tpmsSoftWarningRl(newValue)}
  }

  var optionalTpmsSoftWarningRr: OneOf_OptionalTpmsSoftWarningRr? {
    get {return _storage._optionalTpmsSoftWarningRr}
    set {_uniqueStorage()._optionalTpmsSoftWarningRr = newValue}
  }

  var tpmsSoftWarningRr: Bool {
    get {
      if case .tpmsSoftWarningRr(let v)? = _storage._optionalTpmsSoftWarningRr {return v}
      return false
    }
    set {_uniqueStorage()._optionalTpmsSoftWarningRr = .tpmsSoftWarningRr(newValue)}
  }

  /// rcp values in bar
  var optionalTpmsRcpFrontValue: OneOf_OptionalTpmsRcpFrontValue? {
    get {return _storage._optionalTpmsRcpFrontValue}
    set {_uniqueStorage()._optionalTpmsRcpFrontValue = newValue}
  }

  var tpmsRcpFrontValue: Float {
    get {
      if case .tpmsRcpFrontValue(let v)? = _storage._optionalTpmsRcpFrontValue {return v}
      return 0
    }
    set {_uniqueStorage()._optionalTpmsRcpFrontValue = .tpmsRcpFrontValue(newValue)}
  }

  var optionalTpmsRcpRearValue: OneOf_OptionalTpmsRcpRearValue? {
    get {return _storage._optionalTpmsRcpRearValue}
    set {_uniqueStorage()._optionalTpmsRcpRearValue = newValue}
  }

  var tpmsRcpRearValue: Float {
    get {
      if case .tpmsRcpRearValue(let v)? = _storage._optionalTpmsRcpRearValue {return v}
      return 0
    }
    set {_uniqueStorage()._optionalTpmsRcpRearValue = .tpmsRcpRearValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalTpmsPressureFl: Equatable, Sendable {
    case tpmsPressureFl(Float)

  }

  enum OneOf_OptionalTpmsPressureFr: Equatable, Sendable {
    case tpmsPressureFr(Float)

  }

  enum OneOf_OptionalTpmsPressureRl: Equatable, Sendable {
    case tpmsPressureRl(Float)

  }

  enum OneOf_OptionalTpmsPressureRr: Equatable, Sendable {
    case tpmsPressureRr(Float)

  }

  enum OneOf_OptionalTpmsHardWarningFl: Equatable, Sendable {
    case tpmsHardWarningFl(Bool)

  }

  enum OneOf_OptionalTpmsHardWarningFr: Equatable, Sendable {
    case tpmsHardWarningFr(Bool)

  }

  enum OneOf_OptionalTpmsHardWarningRl: Equatable, Sendable {
    case tpmsHardWarningRl(Bool)

  }

  enum OneOf_OptionalTpmsHardWarningRr: Equatable, Sendable {
    case tpmsHardWarningRr(Bool)

  }

  enum OneOf_OptionalTpmsSoftWarningFl: Equatable, Sendable {
    case tpmsSoftWarningFl(Bool)

  }

  enum OneOf_OptionalTpmsSoftWarningFr: Equatable, Sendable {
    case tpmsSoftWarningFr(Bool)

  }

  enum OneOf_OptionalTpmsSoftWarningRl: Equatable, Sendable {
    case tpmsSoftWarningRl(Bool)

  }

  enum OneOf_OptionalTpmsSoftWarningRr: Equatable, Sendable {
    case tpmsSoftWarningRr(Bool)

  }

  /// rcp values in bar
  enum OneOf_OptionalTpmsRcpFrontValue: Equatable, Sendable {
    case tpmsRcpFrontValue(Float)

  }

  enum OneOf_OptionalTpmsRcpRearValue: Equatable, Sendable {
    case tpmsRcpRearValue(Float)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CarServer_MediaState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var optionalRemoteControlEnabled: CarServer_MediaState.OneOf_OptionalRemoteControlEnabled? = nil

  var remoteControlEnabled: Bool {
    get {
      if case .remoteControlEnabled(let v)? = optionalRemoteControlEnabled {return v}
      return false
    }
    set {optionalRemoteControlEnabled = .remoteControlEnabled(newValue)}
  }

  var optionalNowPlayingArtist: CarServer_MediaState.OneOf_OptionalNowPlayingArtist? = nil

  var nowPlayingArtist: String {
    get {
      if case .nowPlayingArtist(let v)? = optionalNowPlayingArtist {return v}
      return String()
    }
    set {optionalNowPlayingArtist = .nowPlayingArtist(newValue)}
  }

  var optionalNowPlayingTitle: CarServer_MediaState.OneOf_OptionalNowPlayingTitle? = nil

  var nowPlayingTitle: String {
    get {
      if case .nowPlayingTitle(let v)? = optionalNowPlayingTitle {return v}
      return String()
    }
    set {optionalNowPlayingTitle = .nowPlayingTitle(newValue)}
  }

  var optionalAudioVolume: CarServer_MediaState.OneOf_OptionalAudioVolume? = nil

  var audioVolume: Float {
    get {
      if case .audioVolume(let v)? = optionalAudioVolume {return v}
      return 0
    }
    set {optionalAudioVolume = .audioVolume(newValue)}
  }

  var optionalAudioVolumeIncrement: CarServer_MediaState.OneOf_OptionalAudioVolumeIncrement? = nil

  var audioVolumeIncrement: Float {
    get {
      if case .audioVolumeIncrement(let v)? = optionalAudioVolumeIncrement {return v}
      return 0
    }
    set {optionalAudioVolumeIncrement = .audioVolumeIncrement(newValue)}
  }

  var optionalAudioVolumeMax: CarServer_MediaState.OneOf_OptionalAudioVolumeMax? = nil

  var audioVolumeMax: Float {
    get {
      if case .audioVolumeMax(let v)? = optionalAudioVolumeMax {return v}
      return 0
    }
    set {optionalAudioVolumeMax = .audioVolumeMax(newValue)}
  }

  var optionalNowPlayingSource: CarServer_MediaState.OneOf_OptionalNowPlayingSource? = nil

  var nowPlayingSource: CarServer_MediaSourceType {
    get {
      if case .nowPlayingSource(let v)? = optionalNowPlayingSource {return v}
      return .none
    }
    set {optionalNowPlayingSource = .nowPlayingSource(newValue)}
  }

  var optionalMediaPlaybackStatus: CarServer_MediaState.OneOf_OptionalMediaPlaybackStatus? = nil

  var mediaPlaybackStatus: CarServer_MediaPlaybackStatus {
    get {
      if case .mediaPlaybackStatus(let v)? = optionalMediaPlaybackStatus {return v}
      return .stopped
    }
    set {optionalMediaPlaybackStatus = .mediaPlaybackStatus(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalRemoteControlEnabled: Equatable, Sendable {
    case remoteControlEnabled(Bool)

  }

  enum OneOf_OptionalNowPlayingArtist: Equatable, Sendable {
    case nowPlayingArtist(String)

  }

  enum OneOf_OptionalNowPlayingTitle: Equatable, Sendable {
    case nowPlayingTitle(String)

  }

  enum OneOf_OptionalAudioVolume: Equatable, Sendable {
    case audioVolume(Float)

  }

  enum OneOf_OptionalAudioVolumeIncrement: Equatable, Sendable {
    case audioVolumeIncrement(Float)

  }

  enum OneOf_OptionalAudioVolumeMax: Equatable, Sendable {
    case audioVolumeMax(Float)

  }

  enum OneOf_OptionalNowPlayingSource: Equatable, Sendable {
    case nowPlayingSource(CarServer_MediaSourceType)

  }

  enum OneOf_OptionalMediaPlaybackStatus: Equatable, Sendable {
    case mediaPlaybackStatus(CarServer_MediaPlaybackStatus)

  }

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct CarServer_MediaDetailState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var optionalNowPlayingDuration: CarServer_MediaDetailState.OneOf_OptionalNowPlayingDuration? = nil

  var nowPlayingDuration: Int32 {
    get {
      if case .nowPlayingDuration(let v)? = optionalNowPlayingDuration {return v}
      return 0
    }
    set {optionalNowPlayingDuration = .nowPlayingDuration(newValue)}
  }

  var optionalNowPlayingElapsed: CarServer_MediaDetailState.OneOf_OptionalNowPlayingElapsed? = nil

  var nowPlayingElapsed: Int32 {
    get {
      if case .nowPlayingElapsed(let v)? = optionalNowPlayingElapsed {return v}
      return 0
    }
    set {optionalNowPlayingElapsed = .nowPlayingElapsed(newValue)}
  }

  var optionalNowPlayingSourceString: CarServer_MediaDetailState.OneOf_OptionalNowPlayingSourceString? = nil

  var nowPlayingSourceString: String {
    get {
      if case .nowPlayingSourceString(let v)? = optionalNowPlayingSourceString {return v}
      return String()
    }
    set {optionalNowPlayingSourceString = .nowPlayingSourceString(newValue)}
  }

  var optionalNowPlayingAlbum: CarServer_MediaDetailState.OneOf_OptionalNowPlayingAlbum? = nil

  var nowPlayingAlbum: String {
    get {
      if case .nowPlayingAlbum(let v)? = optionalNowPlayingAlbum {return v}
      return String()
    }
    set {optionalNowPlayingAlbum = .nowPlayingAlbum(newValue)}
  }

  var optionalNowPlayingStation: CarServer_MediaDetailState.OneOf_OptionalNowPlayingStation? = nil

  var nowPlayingStation: String {
    get {
      if case .nowPlayingStation(let v)? = optionalNowPlayingStation {return v}
      return String()
    }
    set {optionalNowPlayingStation = .nowPlayingStation(newValue)}
  }

  var optionalA2DpSourceName: CarServer_MediaDetailState.OneOf_OptionalA2DpSourceName? = nil

  var a2DpSourceName: String {
    get {
      if case .a2DpSourceName(let v)? = optionalA2DpSourceName {return v}
      return String()
    }
    set {optionalA2DpSourceName = .a2DpSourceName(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalNowPlayingDuration: Equatable, Sendable {
    case nowPlayingDuration(Int32)

  }

  enum OneOf_OptionalNowPlayingElapsed: Equatable, Sendable {
    case nowPlayingElapsed(Int32)

  }

  enum OneOf_OptionalNowPlayingSourceString: Equatable, Sendable {
    case nowPlayingSourceString(String)

  }

  enum OneOf_OptionalNowPlayingAlbum: Equatable, Sendable {
    case nowPlayingAlbum(String)

  }

  enum OneOf_OptionalNowPlayingStation: Equatable, Sendable {
    case nowPlayingStation(String)

  }

  enum OneOf_OptionalA2DpSourceName: Equatable, Sendable {
    case a2DpSourceName(String)

  }

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct CarServer_ShiftState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: CarServer_ShiftState.OneOf_Type? = nil

  var invalid: CarServer_Void {
    get {
      if case .invalid(let v)? = type {return v}
      return CarServer_Void()
    }
    set {type = .invalid(newValue)}
  }

  var p: CarServer_Void {
    get {
      if case .p(let v)? = type {return v}
      return CarServer_Void()
    }
    set {type = .p(newValue)}
  }

  var r: CarServer_Void {
    get {
      if case .r(let v)? = type {return v}
      return CarServer_Void()
    }
    set {type = .r(newValue)}
  }

  var n: CarServer_Void {
    get {
      if case .n(let v)? = type {return v}
      return CarServer_Void()
    }
    set {type = .n(newValue)}
  }

  var d: CarServer_Void {
    get {
      if case .d(let v)? = type {return v}
      return CarServer_Void()
    }
    set {type = .d(newValue)}
  }

  var sna: CarServer_Void {
    get {
      if case .sna(let v)? = type {return v}
      return CarServer_Void()
    }
    set {type = .sna(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case invalid(CarServer_Void)
    case p(CarServer_Void)
    case r(CarServer_Void)
    case n(CarServer_Void)
    case d(CarServer_Void)
    case sna(CarServer_Void)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CarServer"

extension CarServer_MediaSourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MediaSourceType_None\0\u{1}MediaSourceType_AM\0\u{1}MediaSourceType_FM\0\u{1}MediaSourceType_XM\0\u{2}\u{2}MediaSourceType_Slacker\0\u{1}MediaSourceType_LocalFiles\0\u{1}MediaSourceType_iPod\0\u{1}MediaSourceType_Bluetooth\0\u{1}MediaSourceType_AuxIn\0\u{1}MediaSourceType_DAB\0\u{1}MediaSourceType_Rdio\0\u{1}MediaSourceType_Spotify\0\u{1}MediaSourceType_USRadio\0\u{1}MediaSourceType_EURadio\0\u{2}\u{2}MediaSourceType_MediaFile\0\u{1}MediaSourceType_TuneIn\0\u{1}MediaSourceType_Stingray\0\u{1}MediaSourceType_SiriusXM\0\u{1}MediaSourceType_Tidal\0\u{1}MediaSourceType_QQMusic\0\u{1}MediaSourceType_QQMusic2\0\u{1}MediaSourceType_Ximalaya\0\u{1}MediaSourceType_OnlineRadio\0\u{1}MediaSourceType_OnlineRadio2\0\u{1}MediaSourceType_NetEaseMusic\0\u{2}\u{2}MediaSourceType_Browser\0\u{1}MediaSourceType_Theater\0\u{1}MediaSourceType_Game\0\u{1}MediaSourceType_Tutorial\0\u{1}MediaSourceType_Toybox\0\u{1}MediaSourceType_RecentsFavorites\0\u{1}MediaSourceType_HomeApps\0\u{1}MediaSourceType_Search\0")
}

extension CarServer_VehicleData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{3}charge_state\0\u{3}climate_state\0\u{3}drive_state\0\u{4}\u{3}location_state\0\u{3}closures_state\0\u{4}\u{6}charge_schedule_state\0\u{3}preconditioning_schedule_state\0\u{4}\u{3}tire_pressure_state\0\u{3}media_state\0\u{3}media_detail_state\0\u{4}\u{2}software_update_state\0\u{3}parental_controls_state\0")

  fileprivate class _StorageClass {
    var _chargeState: CarServer_ChargeState? = nil
    var _climateState: CarServer_ClimateState? = nil
    var _driveState: CarServer_DriveState? = nil
    var _locationState: CarServer_LocationState? = nil
    var _closuresState: CarServer_ClosuresState? = nil
    var _chargeScheduleState: CarServer_ChargeScheduleState? = nil
    var _preconditioningScheduleState: CarServer_PreconditioningScheduleState? = nil
    var _tirePressureState: CarServer_TirePressureState? = nil
    var _mediaState: CarServer_MediaState? = nil
    var _mediaDetailState: CarServer_MediaDetailState? = nil
    var _softwareUpdateState: CarServer_SoftwareUpdateState? = nil
    var _parentalControlsState: CarServer_ParentalControlsState? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chargeState = source._chargeState
      _climateState = source._climateState
      _driveState = source._driveState
      _locationState = source._locationState
      _closuresState = source._closuresState
      _chargeScheduleState = source._chargeScheduleState
      _preconditioningScheduleState = source._preconditioningScheduleState
      _tirePressureState = source._tirePressureState
      _mediaState = source._mediaState
      _mediaDetailState = source._mediaDetailState
      _softwareUpdateState = source._softwareUpdateState
      _parentalControlsState = source._parentalControlsState
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._chargeState) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._climateState) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._driveState) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._locationState) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._closuresState) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._chargeScheduleState) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._preconditioningScheduleState) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._tirePressureState) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._mediaState) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._mediaDetailState) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._softwareUpdateState) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._parentalControlsState) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._chargeState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._climateState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._driveState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._locationState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._closuresState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._chargeScheduleState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._preconditioningScheduleState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._tirePressureState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._mediaState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._mediaDetailState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._softwareUpdateState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._parentalControlsState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleData, rhs: CarServer_VehicleData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chargeState != rhs_storage._chargeState {return false}
        if _storage._climateState != rhs_storage._climateState {return false}
        if _storage._driveState != rhs_storage._driveState {return false}
        if _storage._locationState != rhs_storage._locationState {return false}
        if _storage._closuresState != rhs_storage._closuresState {return false}
        if _storage._chargeScheduleState != rhs_storage._chargeScheduleState {return false}
        if _storage._preconditioningScheduleState != rhs_storage._preconditioningScheduleState {return false}
        if _storage._tirePressureState != rhs_storage._tirePressureState {return false}
        if _storage._mediaState != rhs_storage._mediaState {return false}
        if _storage._mediaDetailState != rhs_storage._mediaDetailState {return false}
        if _storage._softwareUpdateState != rhs_storage._softwareUpdateState {return false}
        if _storage._parentalControlsState != rhs_storage._parentalControlsState {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ClosuresState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosuresState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{b}sun_roof_state\0\u{4}\u{4}center_display_state\0\u{4}\u{4}sentry_mode_state\0\u{4}\u{3}speed_limit_mode\0\u{3}tonneau_state\0\u{3}tonneau_percent_open\0\u{3}tonneau_in_motion\0\u{4}L\u{1}door_open_driver_front\0\u{3}door_open_driver_rear\0\u{3}door_open_passenger_front\0\u{3}door_open_passenger_rear\0\u{3}door_open_trunk_front\0\u{3}door_open_trunk_rear\0\u{3}window_open_driver_front\0\u{3}window_open_passenger_front\0\u{3}window_open_driver_rear\0\u{3}window_open_passenger_rear\0\u{4}\u{2}sun_roof_percent_open\0\u{1}locked\0\u{3}is_user_present\0\u{4}\u{2}remote_start\0\u{3}valet_mode\0\u{3}valet_pin_needed\0\u{4}\u{2}sentry_mode_available\0\u{2}X\u{1d}timestamp\0")

  fileprivate class _StorageClass {
    var _optionalDoorOpenDriverFront: CarServer_ClosuresState.OneOf_OptionalDoorOpenDriverFront?
    var _optionalDoorOpenDriverRear: CarServer_ClosuresState.OneOf_OptionalDoorOpenDriverRear?
    var _optionalDoorOpenPassengerFront: CarServer_ClosuresState.OneOf_OptionalDoorOpenPassengerFront?
    var _optionalDoorOpenPassengerRear: CarServer_ClosuresState.OneOf_OptionalDoorOpenPassengerRear?
    var _optionalDoorOpenTrunkFront: CarServer_ClosuresState.OneOf_OptionalDoorOpenTrunkFront?
    var _optionalDoorOpenTrunkRear: CarServer_ClosuresState.OneOf_OptionalDoorOpenTrunkRear?
    var _optionalWindowOpenDriverFront: CarServer_ClosuresState.OneOf_OptionalWindowOpenDriverFront?
    var _optionalWindowOpenPassengerFront: CarServer_ClosuresState.OneOf_OptionalWindowOpenPassengerFront?
    var _optionalWindowOpenDriverRear: CarServer_ClosuresState.OneOf_OptionalWindowOpenDriverRear?
    var _optionalWindowOpenPassengerRear: CarServer_ClosuresState.OneOf_OptionalWindowOpenPassengerRear?
    var _sunRoofState: CarServer_ClosuresState.SunRoofState? = nil
    var _optionalSunRoofPercentOpen: CarServer_ClosuresState.OneOf_OptionalSunRoofPercentOpen?
    var _optionalLocked: CarServer_ClosuresState.OneOf_OptionalLocked?
    var _optionalIsUserPresent: CarServer_ClosuresState.OneOf_OptionalIsUserPresent?
    var _centerDisplayState: CarServer_ClosuresState.DisplayState? = nil
    var _optionalRemoteStart: CarServer_ClosuresState.OneOf_OptionalRemoteStart?
    var _optionalValetMode: CarServer_ClosuresState.OneOf_OptionalValetMode?
    var _optionalValetPinNeeded: CarServer_ClosuresState.OneOf_OptionalValetPinNeeded?
    var _sentryModeState: CarServer_ClosuresState.SentryModeState? = nil
    var _optionalSentryModeAvailable: CarServer_ClosuresState.OneOf_OptionalSentryModeAvailable?
    var _speedLimitMode: CarServer_SpeedLimitMode? = nil
    var _optionalTonneauState: CarServer_ClosuresState.OneOf_OptionalTonneauState?
    var _optionalTonneauPercentOpen: CarServer_ClosuresState.OneOf_OptionalTonneauPercentOpen?
    var _optionalTonneauInMotion: CarServer_ClosuresState.OneOf_OptionalTonneauInMotion?
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _optionalDoorOpenDriverFront = source._optionalDoorOpenDriverFront
      _optionalDoorOpenDriverRear = source._optionalDoorOpenDriverRear
      _optionalDoorOpenPassengerFront = source._optionalDoorOpenPassengerFront
      _optionalDoorOpenPassengerRear = source._optionalDoorOpenPassengerRear
      _optionalDoorOpenTrunkFront = source._optionalDoorOpenTrunkFront
      _optionalDoorOpenTrunkRear = source._optionalDoorOpenTrunkRear
      _optionalWindowOpenDriverFront = source._optionalWindowOpenDriverFront
      _optionalWindowOpenPassengerFront = source._optionalWindowOpenPassengerFront
      _optionalWindowOpenDriverRear = source._optionalWindowOpenDriverRear
      _optionalWindowOpenPassengerRear = source._optionalWindowOpenPassengerRear
      _sunRoofState = source._sunRoofState
      _optionalSunRoofPercentOpen = source._optionalSunRoofPercentOpen
      _optionalLocked = source._optionalLocked
      _optionalIsUserPresent = source._optionalIsUserPresent
      _centerDisplayState = source._centerDisplayState
      _optionalRemoteStart = source._optionalRemoteStart
      _optionalValetMode = source._optionalValetMode
      _optionalValetPinNeeded = source._optionalValetPinNeeded
      _sentryModeState = source._sentryModeState
      _optionalSentryModeAvailable = source._optionalSentryModeAvailable
      _speedLimitMode = source._speedLimitMode
      _optionalTonneauState = source._optionalTonneauState
      _optionalTonneauPercentOpen = source._optionalTonneauPercentOpen
      _optionalTonneauInMotion = source._optionalTonneauInMotion
      _timestamp = source._timestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._sunRoofState) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._centerDisplayState) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._sentryModeState) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._speedLimitMode) }()
        case 23: try {
          var v: VCSEC_ClosureState_E?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalTonneauState != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTonneauState = .tonneauState(v)
          }
        }()
        case 24: try {
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {
            if _storage._optionalTonneauPercentOpen != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTonneauPercentOpen = .tonneauPercentOpen(v)
          }
        }()
        case 25: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTonneauInMotion != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTonneauInMotion = .tonneauInMotion(v)
          }
        }()
        case 101: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalDoorOpenDriverFront != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalDoorOpenDriverFront = .doorOpenDriverFront(v)
          }
        }()
        case 102: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalDoorOpenDriverRear != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalDoorOpenDriverRear = .doorOpenDriverRear(v)
          }
        }()
        case 103: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalDoorOpenPassengerFront != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalDoorOpenPassengerFront = .doorOpenPassengerFront(v)
          }
        }()
        case 104: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalDoorOpenPassengerRear != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalDoorOpenPassengerRear = .doorOpenPassengerRear(v)
          }
        }()
        case 105: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalDoorOpenTrunkFront != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalDoorOpenTrunkFront = .doorOpenTrunkFront(v)
          }
        }()
        case 106: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalDoorOpenTrunkRear != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalDoorOpenTrunkRear = .doorOpenTrunkRear(v)
          }
        }()
        case 107: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalWindowOpenDriverFront != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalWindowOpenDriverFront = .windowOpenDriverFront(v)
          }
        }()
        case 108: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalWindowOpenPassengerFront != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalWindowOpenPassengerFront = .windowOpenPassengerFront(v)
          }
        }()
        case 109: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalWindowOpenDriverRear != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalWindowOpenDriverRear = .windowOpenDriverRear(v)
          }
        }()
        case 110: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalWindowOpenPassengerRear != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalWindowOpenPassengerRear = .windowOpenPassengerRear(v)
          }
        }()
        case 112: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSunRoofPercentOpen != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSunRoofPercentOpen = .sunRoofPercentOpen(v)
          }
        }()
        case 113: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalLocked != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalLocked = .locked(v)
          }
        }()
        case 114: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalIsUserPresent != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalIsUserPresent = .isUserPresent(v)
          }
        }()
        case 116: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalRemoteStart != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalRemoteStart = .remoteStart(v)
          }
        }()
        case 117: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalValetMode != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalValetMode = .valetMode(v)
          }
        }()
        case 118: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalValetPinNeeded != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalValetPinNeeded = .valetPinNeeded(v)
          }
        }()
        case 120: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalSentryModeAvailable != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSentryModeAvailable = .sentryModeAvailable(v)
          }
        }()
        case 2000: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._sunRoofState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._centerDisplayState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._sentryModeState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._speedLimitMode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if case .tonneauState(let v)? = _storage._optionalTonneauState {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 23)
      } }()
      try { if case .tonneauPercentOpen(let v)? = _storage._optionalTonneauPercentOpen {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 24)
      } }()
      try { if case .tonneauInMotion(let v)? = _storage._optionalTonneauInMotion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
      } }()
      try { if case .doorOpenDriverFront(let v)? = _storage._optionalDoorOpenDriverFront {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 101)
      } }()
      try { if case .doorOpenDriverRear(let v)? = _storage._optionalDoorOpenDriverRear {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 102)
      } }()
      try { if case .doorOpenPassengerFront(let v)? = _storage._optionalDoorOpenPassengerFront {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 103)
      } }()
      try { if case .doorOpenPassengerRear(let v)? = _storage._optionalDoorOpenPassengerRear {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 104)
      } }()
      try { if case .doorOpenTrunkFront(let v)? = _storage._optionalDoorOpenTrunkFront {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 105)
      } }()
      try { if case .doorOpenTrunkRear(let v)? = _storage._optionalDoorOpenTrunkRear {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 106)
      } }()
      try { if case .windowOpenDriverFront(let v)? = _storage._optionalWindowOpenDriverFront {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 107)
      } }()
      try { if case .windowOpenPassengerFront(let v)? = _storage._optionalWindowOpenPassengerFront {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 108)
      } }()
      try { if case .windowOpenDriverRear(let v)? = _storage._optionalWindowOpenDriverRear {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 109)
      } }()
      try { if case .windowOpenPassengerRear(let v)? = _storage._optionalWindowOpenPassengerRear {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 110)
      } }()
      try { if case .sunRoofPercentOpen(let v)? = _storage._optionalSunRoofPercentOpen {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 112)
      } }()
      try { if case .locked(let v)? = _storage._optionalLocked {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 113)
      } }()
      try { if case .isUserPresent(let v)? = _storage._optionalIsUserPresent {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 114)
      } }()
      try { if case .remoteStart(let v)? = _storage._optionalRemoteStart {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 116)
      } }()
      try { if case .valetMode(let v)? = _storage._optionalValetMode {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 117)
      } }()
      try { if case .valetPinNeeded(let v)? = _storage._optionalValetPinNeeded {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 118)
      } }()
      try { if case .sentryModeAvailable(let v)? = _storage._optionalSentryModeAvailable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 120)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2000)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ClosuresState, rhs: CarServer_ClosuresState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._optionalDoorOpenDriverFront != rhs_storage._optionalDoorOpenDriverFront {return false}
        if _storage._optionalDoorOpenDriverRear != rhs_storage._optionalDoorOpenDriverRear {return false}
        if _storage._optionalDoorOpenPassengerFront != rhs_storage._optionalDoorOpenPassengerFront {return false}
        if _storage._optionalDoorOpenPassengerRear != rhs_storage._optionalDoorOpenPassengerRear {return false}
        if _storage._optionalDoorOpenTrunkFront != rhs_storage._optionalDoorOpenTrunkFront {return false}
        if _storage._optionalDoorOpenTrunkRear != rhs_storage._optionalDoorOpenTrunkRear {return false}
        if _storage._optionalWindowOpenDriverFront != rhs_storage._optionalWindowOpenDriverFront {return false}
        if _storage._optionalWindowOpenPassengerFront != rhs_storage._optionalWindowOpenPassengerFront {return false}
        if _storage._optionalWindowOpenDriverRear != rhs_storage._optionalWindowOpenDriverRear {return false}
        if _storage._optionalWindowOpenPassengerRear != rhs_storage._optionalWindowOpenPassengerRear {return false}
        if _storage._sunRoofState != rhs_storage._sunRoofState {return false}
        if _storage._optionalSunRoofPercentOpen != rhs_storage._optionalSunRoofPercentOpen {return false}
        if _storage._optionalLocked != rhs_storage._optionalLocked {return false}
        if _storage._optionalIsUserPresent != rhs_storage._optionalIsUserPresent {return false}
        if _storage._centerDisplayState != rhs_storage._centerDisplayState {return false}
        if _storage._optionalRemoteStart != rhs_storage._optionalRemoteStart {return false}
        if _storage._optionalValetMode != rhs_storage._optionalValetMode {return false}
        if _storage._optionalValetPinNeeded != rhs_storage._optionalValetPinNeeded {return false}
        if _storage._sentryModeState != rhs_storage._sentryModeState {return false}
        if _storage._optionalSentryModeAvailable != rhs_storage._optionalSentryModeAvailable {return false}
        if _storage._speedLimitMode != rhs_storage._speedLimitMode {return false}
        if _storage._optionalTonneauState != rhs_storage._optionalTonneauState {return false}
        if _storage._optionalTonneauPercentOpen != rhs_storage._optionalTonneauPercentOpen {return false}
        if _storage._optionalTonneauInMotion != rhs_storage._optionalTonneauInMotion {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ClosuresState.SunRoofState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_ClosuresState.protoMessageName + ".SunRoofState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Unknown\0\u{1}Calibrating\0\u{1}Closed\0\u{1}Open\0\u{1}Moving\0\u{1}Vent\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .unknown(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .calibrating(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .calibrating(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .closed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .closed(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .open(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .open(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .moving(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .moving(v)
        }
      }()
      case 6: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .vent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .vent(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .unknown?: try {
      guard case .unknown(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .calibrating?: try {
      guard case .calibrating(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .closed?: try {
      guard case .closed(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .open?: try {
      guard case .open(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .moving?: try {
      guard case .moving(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .vent?: try {
      guard case .vent(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ClosuresState.SunRoofState, rhs: CarServer_ClosuresState.SunRoofState) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ClosuresState.DisplayState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_ClosuresState.protoMessageName + ".DisplayState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Off\0\u{1}Dim\0\u{1}Accessory\0\u{1}On\0\u{1}Driving\0\u{1}Charging\0\u{1}Lock\0\u{1}Sentry\0\u{1}Dog\0\u{1}Entertainment\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .off(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .off(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .dim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .dim(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .accessory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .accessory(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .on(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .on(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .driving(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .driving(v)
        }
      }()
      case 6: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .charging(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .charging(v)
        }
      }()
      case 7: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .lock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .lock(v)
        }
      }()
      case 8: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sentry(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sentry(v)
        }
      }()
      case 9: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .dog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .dog(v)
        }
      }()
      case 10: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .entertainment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .entertainment(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .off?: try {
      guard case .off(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .dim?: try {
      guard case .dim(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .accessory?: try {
      guard case .accessory(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .on?: try {
      guard case .on(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .driving?: try {
      guard case .driving(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .charging?: try {
      guard case .charging(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .lock?: try {
      guard case .lock(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .sentry?: try {
      guard case .sentry(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .dog?: try {
      guard case .dog(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .entertainment?: try {
      guard case .entertainment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ClosuresState.DisplayState, rhs: CarServer_ClosuresState.DisplayState) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ClosuresState.SentryModeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_ClosuresState.protoMessageName + ".SentryModeState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Off\0\u{1}Idle\0\u{1}Armed\0\u{1}Aware\0\u{1}Panic\0\u{1}Quiet\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .off(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .off(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .idle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .idle(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .armed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .armed(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .aware(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .aware(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .panic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .panic(v)
        }
      }()
      case 6: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .quiet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .quiet(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .off?: try {
      guard case .off(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .idle?: try {
      guard case .idle(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .armed?: try {
      guard case .armed(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .aware?: try {
      guard case .aware(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .panic?: try {
      guard case .panic(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .quiet?: try {
      guard case .quiet(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ClosuresState.SentryModeState, rhs: CarServer_ClosuresState.SentryModeState) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeScheduleState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeScheduleState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}charge_schedules\0\u{3}charge_schedule_window\0\u{3}charge_buffer\0\u{3}max_num_charge_schedules\0\u{3}next_schedule\0\u{3}show_schedule_complete_state\0\u{2}J\u{1f}timestamp\0")

  fileprivate class _StorageClass {
    var _chargeSchedules: [CarServer_ChargeSchedule] = []
    var _optionalChargeScheduleWindow: CarServer_ChargeScheduleState.OneOf_OptionalChargeScheduleWindow?
    var _optionalChargeBuffer: CarServer_ChargeScheduleState.OneOf_OptionalChargeBuffer?
    var _optionalMaxNumChargeSchedules: CarServer_ChargeScheduleState.OneOf_OptionalMaxNumChargeSchedules?
    var _optionalNextSchedule: CarServer_ChargeScheduleState.OneOf_OptionalNextSchedule?
    var _optionalShowScheduleCompleteState: CarServer_ChargeScheduleState.OneOf_OptionalShowScheduleCompleteState?
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chargeSchedules = source._chargeSchedules
      _optionalChargeScheduleWindow = source._optionalChargeScheduleWindow
      _optionalChargeBuffer = source._optionalChargeBuffer
      _optionalMaxNumChargeSchedules = source._optionalMaxNumChargeSchedules
      _optionalNextSchedule = source._optionalNextSchedule
      _optionalShowScheduleCompleteState = source._optionalShowScheduleCompleteState
      _timestamp = source._timestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._chargeSchedules) }()
        case 2: try {
          var v: CarServer_ChargeSchedule?
          var hadOneofValue = false
          if let current = _storage._optionalChargeScheduleWindow {
            hadOneofValue = true
            if case .chargeScheduleWindow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeScheduleWindow = .chargeScheduleWindow(v)
          }
        }()
        case 3: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargeBuffer != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeBuffer = .chargeBuffer(v)
          }
        }()
        case 4: try {
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {
            if _storage._optionalMaxNumChargeSchedules != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalMaxNumChargeSchedules = .maxNumChargeSchedules(v)
          }
        }()
        case 5: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalNextSchedule != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalNextSchedule = .nextSchedule(v)
          }
        }()
        case 6: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalShowScheduleCompleteState != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalShowScheduleCompleteState = .showScheduleCompleteState(v)
          }
        }()
        case 2000: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._chargeSchedules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chargeSchedules, fieldNumber: 1)
      }
      try { if case .chargeScheduleWindow(let v)? = _storage._optionalChargeScheduleWindow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if case .chargeBuffer(let v)? = _storage._optionalChargeBuffer {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if case .maxNumChargeSchedules(let v)? = _storage._optionalMaxNumChargeSchedules {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if case .nextSchedule(let v)? = _storage._optionalNextSchedule {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if case .showScheduleCompleteState(let v)? = _storage._optionalShowScheduleCompleteState {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2000)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeScheduleState, rhs: CarServer_ChargeScheduleState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chargeSchedules != rhs_storage._chargeSchedules {return false}
        if _storage._optionalChargeScheduleWindow != rhs_storage._optionalChargeScheduleWindow {return false}
        if _storage._optionalChargeBuffer != rhs_storage._optionalChargeBuffer {return false}
        if _storage._optionalMaxNumChargeSchedules != rhs_storage._optionalMaxNumChargeSchedules {return false}
        if _storage._optionalNextSchedule != rhs_storage._optionalNextSchedule {return false}
        if _storage._optionalShowScheduleCompleteState != rhs_storage._optionalShowScheduleCompleteState {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_PreconditioningScheduleState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreconditioningScheduleState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}precondition_schedules\0\u{3}preconditioning_schedule_window\0\u{3}max_num_precondition_schedules\0\u{3}next_schedule\0\u{2}L\u{1f}timestamp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.preconditionSchedules) }()
      case 2: try {
        var v: CarServer_PreconditionSchedule?
        var hadOneofValue = false
        if let current = self.optionalPreconditioningScheduleWindow {
          hadOneofValue = true
          if case .preconditioningScheduleWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.optionalPreconditioningScheduleWindow = .preconditioningScheduleWindow(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.optionalMaxNumPreconditionSchedules != nil {try decoder.handleConflictingOneOf()}
          self.optionalMaxNumPreconditionSchedules = .maxNumPreconditionSchedules(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalNextSchedule != nil {try decoder.handleConflictingOneOf()}
          self.optionalNextSchedule = .nextSchedule(v)
        }
      }()
      case 2000: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.preconditionSchedules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preconditionSchedules, fieldNumber: 1)
    }
    try { if case .preconditioningScheduleWindow(let v)? = self.optionalPreconditioningScheduleWindow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if case .maxNumPreconditionSchedules(let v)? = self.optionalMaxNumPreconditionSchedules {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if case .nextSchedule(let v)? = self.optionalNextSchedule {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_PreconditioningScheduleState, rhs: CarServer_PreconditioningScheduleState) -> Bool {
    if lhs.preconditionSchedules != rhs.preconditionSchedules {return false}
    if lhs.optionalPreconditioningScheduleWindow != rhs.optionalPreconditioningScheduleWindow {return false}
    if lhs.optionalMaxNumPreconditionSchedules != rhs.optionalMaxNumPreconditionSchedules {return false}
    if lhs.optionalNextSchedule != rhs.optionalNextSchedule {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_SpeedLimitMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedLimitMode"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}g\u{1}active\0\u{3}pin_code_set\0\u{4}\u{2}max_limit_mph\0\u{3}min_limit_mph\0\u{3}current_limit_mph\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 103: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalActive != nil {try decoder.handleConflictingOneOf()}
          self.optionalActive = .active(v)
        }
      }()
      case 104: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalPinCodeSet != nil {try decoder.handleConflictingOneOf()}
          self.optionalPinCodeSet = .pinCodeSet(v)
        }
      }()
      case 106: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalMaxLimitMph != nil {try decoder.handleConflictingOneOf()}
          self.optionalMaxLimitMph = .maxLimitMph(v)
        }
      }()
      case 107: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalMinLimitMph != nil {try decoder.handleConflictingOneOf()}
          self.optionalMinLimitMph = .minLimitMph(v)
        }
      }()
      case 108: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalCurrentLimitMph != nil {try decoder.handleConflictingOneOf()}
          self.optionalCurrentLimitMph = .currentLimitMph(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .active(let v)? = self.optionalActive {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 103)
    } }()
    try { if case .pinCodeSet(let v)? = self.optionalPinCodeSet {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 104)
    } }()
    try { if case .maxLimitMph(let v)? = self.optionalMaxLimitMph {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 106)
    } }()
    try { if case .minLimitMph(let v)? = self.optionalMinLimitMph {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 107)
    } }()
    try { if case .currentLimitMph(let v)? = self.optionalCurrentLimitMph {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 108)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_SpeedLimitMode, rhs: CarServer_SpeedLimitMode) -> Bool {
    if lhs.optionalActive != rhs.optionalActive {return false}
    if lhs.optionalPinCodeSet != rhs.optionalPinCodeSet {return false}
    if lhs.optionalMaxLimitMph != rhs.optionalMaxLimitMph {return false}
    if lhs.optionalMinLimitMph != rhs.optionalMinLimitMph {return false}
    if lhs.optionalCurrentLimitMph != rhs.optionalCurrentLimitMph {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ParentalControlsSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParentalControlsSettings"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}speed_limit_enabled\0\u{3}max_limit_mph\0\u{3}min_limit_mph\0\u{3}current_limit_mph\0\u{3}chill_acceleration_enabled\0\u{3}require_safety_settings_enabled\0\u{3}curfew_enabled\0\u{3}curfew_start_time\0\u{3}curfew_end_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalSpeedLimitEnabled != nil {try decoder.handleConflictingOneOf()}
          self.optionalSpeedLimitEnabled = .speedLimitEnabled(v)
        }
      }()
      case 2: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalMaxLimitMph != nil {try decoder.handleConflictingOneOf()}
          self.optionalMaxLimitMph = .maxLimitMph(v)
        }
      }()
      case 3: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalMinLimitMph != nil {try decoder.handleConflictingOneOf()}
          self.optionalMinLimitMph = .minLimitMph(v)
        }
      }()
      case 4: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalCurrentLimitMph != nil {try decoder.handleConflictingOneOf()}
          self.optionalCurrentLimitMph = .currentLimitMph(v)
        }
      }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalChillAccelerationEnabled != nil {try decoder.handleConflictingOneOf()}
          self.optionalChillAccelerationEnabled = .chillAccelerationEnabled(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalRequireSafetySettingsEnabled != nil {try decoder.handleConflictingOneOf()}
          self.optionalRequireSafetySettingsEnabled = .requireSafetySettingsEnabled(v)
        }
      }()
      case 7: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalCurfewEnabled != nil {try decoder.handleConflictingOneOf()}
          self.optionalCurfewEnabled = .curfewEnabled(v)
        }
      }()
      case 8: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.optionalCurfewStartTime != nil {try decoder.handleConflictingOneOf()}
          self.optionalCurfewStartTime = .curfewStartTime(v)
        }
      }()
      case 9: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.optionalCurfewEndTime != nil {try decoder.handleConflictingOneOf()}
          self.optionalCurfewEndTime = .curfewEndTime(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .speedLimitEnabled(let v)? = self.optionalSpeedLimitEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if case .maxLimitMph(let v)? = self.optionalMaxLimitMph {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if case .minLimitMph(let v)? = self.optionalMinLimitMph {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if case .currentLimitMph(let v)? = self.optionalCurrentLimitMph {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if case .chillAccelerationEnabled(let v)? = self.optionalChillAccelerationEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if case .requireSafetySettingsEnabled(let v)? = self.optionalRequireSafetySettingsEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if case .curfewEnabled(let v)? = self.optionalCurfewEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if case .curfewStartTime(let v)? = self.optionalCurfewStartTime {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if case .curfewEndTime(let v)? = self.optionalCurfewEndTime {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ParentalControlsSettings, rhs: CarServer_ParentalControlsSettings) -> Bool {
    if lhs.optionalSpeedLimitEnabled != rhs.optionalSpeedLimitEnabled {return false}
    if lhs.optionalMaxLimitMph != rhs.optionalMaxLimitMph {return false}
    if lhs.optionalMinLimitMph != rhs.optionalMinLimitMph {return false}
    if lhs.optionalCurrentLimitMph != rhs.optionalCurrentLimitMph {return false}
    if lhs.optionalChillAccelerationEnabled != rhs.optionalChillAccelerationEnabled {return false}
    if lhs.optionalRequireSafetySettingsEnabled != rhs.optionalRequireSafetySettingsEnabled {return false}
    if lhs.optionalCurfewEnabled != rhs.optionalCurfewEnabled {return false}
    if lhs.optionalCurfewStartTime != rhs.optionalCurfewStartTime {return false}
    if lhs.optionalCurfewEndTime != rhs.optionalCurfewEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ParentalControlsState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParentalControlsState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}timestamp\0\u{3}parental_controls_active\0\u{3}parental_controls_pin_set\0\u{3}parental_controls_settings\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalParentalControlsActive != nil {try decoder.handleConflictingOneOf()}
          self.optionalParentalControlsActive = .parentalControlsActive(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalParentalControlsPinSet != nil {try decoder.handleConflictingOneOf()}
          self.optionalParentalControlsPinSet = .parentalControlsPinSet(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._parentalControlsSettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if case .parentalControlsActive(let v)? = self.optionalParentalControlsActive {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if case .parentalControlsPinSet(let v)? = self.optionalParentalControlsPinSet {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._parentalControlsSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ParentalControlsState, rhs: CarServer_ParentalControlsState) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.optionalParentalControlsActive != rhs.optionalParentalControlsActive {return false}
    if lhs.optionalParentalControlsPinSet != rhs.optionalParentalControlsPinSet {return false}
    if lhs._parentalControlsSettings != rhs._parentalControlsSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_SoftwareUpdateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SoftwareUpdateState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0\u{4}e\u{1}scheduled_time_ms\0\u{3}warning_time_remaining_ms\0\u{3}expected_duration_sec\0\u{3}download_perc\0\u{3}install_perc\0\u{1}version\0\u{1}timestamp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 102: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.optionalScheduledTimeMs != nil {try decoder.handleConflictingOneOf()}
          self.optionalScheduledTimeMs = .scheduledTimeMs(v)
        }
      }()
      case 103: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.optionalWarningTimeRemainingMs != nil {try decoder.handleConflictingOneOf()}
          self.optionalWarningTimeRemainingMs = .warningTimeRemainingMs(v)
        }
      }()
      case 104: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.optionalExpectedDurationSec != nil {try decoder.handleConflictingOneOf()}
          self.optionalExpectedDurationSec = .expectedDurationSec(v)
        }
      }()
      case 105: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.optionalDownloadPerc != nil {try decoder.handleConflictingOneOf()}
          self.optionalDownloadPerc = .downloadPerc(v)
        }
      }()
      case 106: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.optionalInstallPerc != nil {try decoder.handleConflictingOneOf()}
          self.optionalInstallPerc = .installPerc(v)
        }
      }()
      case 107: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalVersion != nil {try decoder.handleConflictingOneOf()}
          self.optionalVersion = .version(v)
        }
      }()
      case 108: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if case .scheduledTimeMs(let v)? = self.optionalScheduledTimeMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 102)
    } }()
    try { if case .warningTimeRemainingMs(let v)? = self.optionalWarningTimeRemainingMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 103)
    } }()
    try { if case .expectedDurationSec(let v)? = self.optionalExpectedDurationSec {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 104)
    } }()
    try { if case .downloadPerc(let v)? = self.optionalDownloadPerc {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 105)
    } }()
    try { if case .installPerc(let v)? = self.optionalInstallPerc {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 106)
    } }()
    try { if case .version(let v)? = self.optionalVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 107)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_SoftwareUpdateState, rhs: CarServer_SoftwareUpdateState) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.optionalScheduledTimeMs != rhs.optionalScheduledTimeMs {return false}
    if lhs.optionalWarningTimeRemainingMs != rhs.optionalWarningTimeRemainingMs {return false}
    if lhs.optionalExpectedDurationSec != rhs.optionalExpectedDurationSec {return false}
    if lhs.optionalDownloadPerc != rhs.optionalDownloadPerc {return false}
    if lhs.optionalInstallPerc != rhs.optionalInstallPerc {return false}
    if lhs.optionalVersion != rhs.optionalVersion {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_SoftwareUpdateState.SoftwareUpdateStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_SoftwareUpdateState.protoMessageName + ".SoftwareUpdateStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Unknown\0\u{1}Installing\0\u{1}Scheduled\0\u{1}Available\0\u{1}DownloadingWifiWait\0\u{1}Downloading\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .unknown(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .installing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .installing(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .scheduled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .scheduled(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .available(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .available(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .downloadingWifiWait(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .downloadingWifiWait(v)
        }
      }()
      case 6: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .downloading(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .downloading(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .unknown?: try {
      guard case .unknown(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .installing?: try {
      guard case .installing(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .scheduled?: try {
      guard case .scheduled(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .available?: try {
      guard case .available(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .downloadingWifiWait?: try {
      guard case .downloadingWifiWait(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .downloading?: try {
      guard case .downloading(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_SoftwareUpdateState.SoftwareUpdateStatus, rhs: CarServer_SoftwareUpdateState.SoftwareUpdateStatus) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_DriveState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DriveState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shift_state\0\u{2}\u{3}timestamp\0\u{4}\u{3}active_route_destination\0\u{3}active_route_minutes_to_arrival\0\u{3}active_route_miles_to_arrival\0\u{3}active_route_traffic_minutes_delay\0\u{3}active_route_energy_at_arrival\0\u{3}active_route_coordinates\0\u{4}\u{2}last_route_update\0\u{3}last_traffic_update\0\u{2}W\u{1}speed\0\u{1}power\0\u{4}\u{2}odometer_in_hundredths_of_a_mile\0\u{3}speed_float\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shiftState) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalActiveRouteDestination != nil {try decoder.handleConflictingOneOf()}
          self.optionalActiveRouteDestination = .activeRouteDestination(v)
        }
      }()
      case 8: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalActiveRouteMinutesToArrival != nil {try decoder.handleConflictingOneOf()}
          self.optionalActiveRouteMinutesToArrival = .activeRouteMinutesToArrival(v)
        }
      }()
      case 9: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalActiveRouteMilesToArrival != nil {try decoder.handleConflictingOneOf()}
          self.optionalActiveRouteMilesToArrival = .activeRouteMilesToArrival(v)
        }
      }()
      case 10: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalActiveRouteTrafficMinutesDelay != nil {try decoder.handleConflictingOneOf()}
          self.optionalActiveRouteTrafficMinutesDelay = .activeRouteTrafficMinutesDelay(v)
        }
      }()
      case 11: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalActiveRouteEnergyAtArrival != nil {try decoder.handleConflictingOneOf()}
          self.optionalActiveRouteEnergyAtArrival = .activeRouteEnergyAtArrival(v)
        }
      }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._activeRouteCoordinates) }()
      case 14: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.optionalLastRouteUpdate != nil {try decoder.handleConflictingOneOf()}
          self.optionalLastRouteUpdate = .lastRouteUpdate(v)
        }
      }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._lastTrafficUpdate) }()
      case 102: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.optionalSpeed != nil {try decoder.handleConflictingOneOf()}
          self.optionalSpeed = .speed(v)
        }
      }()
      case 103: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.optionalPower != nil {try decoder.handleConflictingOneOf()}
          self.optionalPower = .power(v)
        }
      }()
      case 105: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.optionalOdometerInHundredthsOfAMile != nil {try decoder.handleConflictingOneOf()}
          self.optionalOdometerInHundredthsOfAMile = .odometerInHundredthsOfAMile(v)
        }
      }()
      case 106: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalSpeedFloat != nil {try decoder.handleConflictingOneOf()}
          self.optionalSpeedFloat = .speedFloat(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shiftState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if case .activeRouteDestination(let v)? = self.optionalActiveRouteDestination {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if case .activeRouteMinutesToArrival(let v)? = self.optionalActiveRouteMinutesToArrival {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try { if case .activeRouteMilesToArrival(let v)? = self.optionalActiveRouteMilesToArrival {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
    } }()
    try { if case .activeRouteTrafficMinutesDelay(let v)? = self.optionalActiveRouteTrafficMinutesDelay {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
    } }()
    try { if case .activeRouteEnergyAtArrival(let v)? = self.optionalActiveRouteEnergyAtArrival {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._activeRouteCoordinates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if case .lastRouteUpdate(let v)? = self.optionalLastRouteUpdate {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._lastTrafficUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try { if case .speed(let v)? = self.optionalSpeed {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 102)
    } }()
    try { if case .power(let v)? = self.optionalPower {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 103)
    } }()
    try { if case .odometerInHundredthsOfAMile(let v)? = self.optionalOdometerInHundredthsOfAMile {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 105)
    } }()
    try { if case .speedFloat(let v)? = self.optionalSpeedFloat {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 106)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_DriveState, rhs: CarServer_DriveState) -> Bool {
    if lhs._shiftState != rhs._shiftState {return false}
    if lhs.optionalSpeed != rhs.optionalSpeed {return false}
    if lhs.optionalPower != rhs.optionalPower {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.optionalOdometerInHundredthsOfAMile != rhs.optionalOdometerInHundredthsOfAMile {return false}
    if lhs.optionalSpeedFloat != rhs.optionalSpeedFloat {return false}
    if lhs.optionalActiveRouteDestination != rhs.optionalActiveRouteDestination {return false}
    if lhs.optionalActiveRouteMinutesToArrival != rhs.optionalActiveRouteMinutesToArrival {return false}
    if lhs.optionalActiveRouteMilesToArrival != rhs.optionalActiveRouteMilesToArrival {return false}
    if lhs.optionalActiveRouteTrafficMinutesDelay != rhs.optionalActiveRouteTrafficMinutesDelay {return false}
    if lhs.optionalActiveRouteEnergyAtArrival != rhs.optionalActiveRouteEnergyAtArrival {return false}
    if lhs.optionalLastRouteUpdate != rhs.optionalLastRouteUpdate {return false}
    if lhs._lastTrafficUpdate != rhs._lastTrafficUpdate {return false}
    if lhs._activeRouteCoordinates != rhs._activeRouteCoordinates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}charging_state\0\u{3}fast_charger_type\0\u{3}fast_charger_brand\0\u{4}\u{19}conn_charge_cable\0\u{4}\u{3}scheduled_departure_time\0\u{4}\u{4}charge_port_latch\0\u{2}\u{9}timestamp\0\u{3}preconditioning_times\0\u{3}off_peak_charging_times\0\u{4}:charge_limit_soc\0\u{3}charge_limit_soc_std\0\u{3}charge_limit_soc_min\0\u{3}charge_limit_soc_max\0\u{4}\u{2}max_range_charge_counter\0\u{3}fast_charger_present\0\u{3}battery_range\0\u{3}est_battery_range\0\u{3}ideal_battery_range\0\u{3}battery_level\0\u{3}usable_battery_level\0\u{3}charge_energy_added\0\u{3}charge_miles_added_rated\0\u{3}charge_miles_added_ideal\0\u{3}charger_voltage\0\u{3}charger_pilot_current\0\u{3}charger_actual_current\0\u{3}charger_power\0\u{3}minutes_to_full_charge\0\u{4}\u{2}trip_charging\0\u{3}charge_rate_mph\0\u{3}charge_port_door_open\0\u{4}\u{2}scheduled_charging_start_time\0\u{3}scheduled_charging_pending\0\u{4}\u{2}user_charge_enable_request\0\u{3}charge_enable_request\0\u{3}charger_phases\0\u{4}\u{2}charge_port_cold_weather_mode\0\u{3}charge_current_request\0\u{3}charge_current_request_max\0\u{3}managed_charging_active\0\u{3}managed_charging_user_canceled\0\u{3}managed_charging_start_time\0\u{3}minutes_to_charge_limit\0\u{4}\u{5}off_peak_hours_end_time\0\u{3}scheduled_charging_mode\0\u{3}charging_amps\0\u{3}scheduled_charging_start_time_minutes\0\u{3}scheduled_departure_time_minutes\0\u{3}preconditioning_enabled\0\u{3}scheduled_charging_start_time_app\0\u{3}supercharger_session_trip_planner\0\u{3}charge_port_color\0\u{3}charge_rate_mph_float\0\u{3}charge_limit_reason\0\u{3}managed_charging_state\0\u{3}charge_cable_unlatched\0\u{3}outlet_state\0\u{3}power_feed_state\0\u{3}outlet_soc_limit\0\u{3}power_feed_soc_limit\0\u{3}outlet_time_remaining\0\u{3}power_feed_time_remaining\0\u{3}powershare_feature_allowed\0\u{3}powershare_feature_enabled\0\u{3}powershare_request\0\u{3}powershare_type\0\u{3}powershare_status\0\u{3}powershare_stop_reason\0\u{3}powershare_instantaneous_load_kw\0\u{3}powershare_vehicle_energy_left_hr\0\u{3}powershare_soc_limit\0\u{3}one_time_soc_limit\0\u{3}home_location\0\u{3}work_location\0\u{3}outlet_max_timer_minutes\0\u{c}\u{8}\u{1}\u{c}*\u{1}\u{c}+\u{1}")

  fileprivate class _StorageClass {
    var _chargingState: CarServer_ChargeState.ChargingState? = nil
    var _fastChargerType: CarServer_ChargeState.ChargerType? = nil
    var _fastChargerBrand: CarServer_ChargeState.ChargerBrand? = nil
    var _optionalChargeLimitSoc: CarServer_ChargeState.OneOf_OptionalChargeLimitSoc?
    var _optionalChargeLimitSocStd: CarServer_ChargeState.OneOf_OptionalChargeLimitSocStd?
    var _optionalChargeLimitSocMin: CarServer_ChargeState.OneOf_OptionalChargeLimitSocMin?
    var _optionalChargeLimitSocMax: CarServer_ChargeState.OneOf_OptionalChargeLimitSocMax?
    var _optionalMaxRangeChargeCounter: CarServer_ChargeState.OneOf_OptionalMaxRangeChargeCounter?
    var _optionalFastChargerPresent: CarServer_ChargeState.OneOf_OptionalFastChargerPresent?
    var _optionalBatteryRange: CarServer_ChargeState.OneOf_OptionalBatteryRange?
    var _optionalEstBatteryRange: CarServer_ChargeState.OneOf_OptionalEstBatteryRange?
    var _optionalIdealBatteryRange: CarServer_ChargeState.OneOf_OptionalIdealBatteryRange?
    var _optionalBatteryLevel: CarServer_ChargeState.OneOf_OptionalBatteryLevel?
    var _optionalUsableBatteryLevel: CarServer_ChargeState.OneOf_OptionalUsableBatteryLevel?
    var _optionalChargeEnergyAdded: CarServer_ChargeState.OneOf_OptionalChargeEnergyAdded?
    var _optionalChargeMilesAddedRated: CarServer_ChargeState.OneOf_OptionalChargeMilesAddedRated?
    var _optionalChargeMilesAddedIdeal: CarServer_ChargeState.OneOf_OptionalChargeMilesAddedIdeal?
    var _optionalChargerVoltage: CarServer_ChargeState.OneOf_OptionalChargerVoltage?
    var _optionalChargerPilotCurrent: CarServer_ChargeState.OneOf_OptionalChargerPilotCurrent?
    var _optionalChargerActualCurrent: CarServer_ChargeState.OneOf_OptionalChargerActualCurrent?
    var _optionalChargerPower: CarServer_ChargeState.OneOf_OptionalChargerPower?
    var _optionalMinutesToFullCharge: CarServer_ChargeState.OneOf_OptionalMinutesToFullCharge?
    var _optionalMinutesToChargeLimit: CarServer_ChargeState.OneOf_OptionalMinutesToChargeLimit?
    var _optionalTripCharging: CarServer_ChargeState.OneOf_OptionalTripCharging?
    var _optionalChargeRateMph: CarServer_ChargeState.OneOf_OptionalChargeRateMph?
    var _optionalChargePortDoorOpen: CarServer_ChargeState.OneOf_OptionalChargePortDoorOpen?
    var _connChargeCable: CarServer_ChargeState.CableType? = nil
    var _optionalScheduledChargingStartTime: CarServer_ChargeState.OneOf_OptionalScheduledChargingStartTime?
    var _optionalScheduledChargingPending: CarServer_ChargeState.OneOf_OptionalScheduledChargingPending?
    var _scheduledDepartureTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _optionalUserChargeEnableRequest: CarServer_ChargeState.OneOf_OptionalUserChargeEnableRequest?
    var _optionalChargeEnableRequest: CarServer_ChargeState.OneOf_OptionalChargeEnableRequest?
    var _optionalChargerPhases: CarServer_ChargeState.OneOf_OptionalChargerPhases?
    var _chargePortLatch: CarServer_ChargePortLatchState? = nil
    var _optionalChargePortColdWeatherMode: CarServer_ChargeState.OneOf_OptionalChargePortColdWeatherMode?
    var _optionalChargeCurrentRequest: CarServer_ChargeState.OneOf_OptionalChargeCurrentRequest?
    var _optionalChargeCurrentRequestMax: CarServer_ChargeState.OneOf_OptionalChargeCurrentRequestMax?
    var _optionalManagedChargingActive: CarServer_ChargeState.OneOf_OptionalManagedChargingActive?
    var _optionalManagedChargingUserCanceled: CarServer_ChargeState.OneOf_OptionalManagedChargingUserCanceled?
    var _optionalManagedChargingStartTime: CarServer_ChargeState.OneOf_OptionalManagedChargingStartTime?
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _preconditioningTimes: CarServer_PreconditioningTimes? = nil
    var _offPeakChargingTimes: CarServer_OffPeakChargingTimes? = nil
    var _optionalOffPeakHoursEndTime: CarServer_ChargeState.OneOf_OptionalOffPeakHoursEndTime?
    var _optionalScheduledChargingMode: CarServer_ChargeState.OneOf_OptionalScheduledChargingMode?
    var _optionalChargingAmps: CarServer_ChargeState.OneOf_OptionalChargingAmps?
    var _optionalScheduledChargingStartTimeMinutes: CarServer_ChargeState.OneOf_OptionalScheduledChargingStartTimeMinutes?
    var _optionalScheduledDepartureTimeMinutes: CarServer_ChargeState.OneOf_OptionalScheduledDepartureTimeMinutes?
    var _optionalPreconditioningEnabled: CarServer_ChargeState.OneOf_OptionalPreconditioningEnabled?
    var _optionalScheduledChargingStartTimeApp: CarServer_ChargeState.OneOf_OptionalScheduledChargingStartTimeApp?
    var _optionalSuperchargerSessionTripPlanner: CarServer_ChargeState.OneOf_OptionalSuperchargerSessionTripPlanner?
    var _optionalChargePortColor: CarServer_ChargeState.OneOf_OptionalChargePortColor?
    var _optionalChargeRateMphFloat: CarServer_ChargeState.OneOf_OptionalChargeRateMphFloat?
    var _optionalChargeLimitReason: CarServer_ChargeState.OneOf_OptionalChargeLimitReason?
    var _managedChargingState: CarServer_ManagedChargingState? = nil
    var _optionalChargeCableUnlatched: CarServer_ChargeState.OneOf_OptionalChargeCableUnlatched?
    var _optionalOutletState: CarServer_ChargeState.OneOf_OptionalOutletState?
    var _optionalPowerFeedState: CarServer_ChargeState.OneOf_OptionalPowerFeedState?
    var _optionOutletSocLimit: CarServer_ChargeState.OneOf_OptionOutletSocLimit?
    var _optionPowerFeedSocLimit: CarServer_ChargeState.OneOf_OptionPowerFeedSocLimit?
    var _optionOutletTimeRemaining: CarServer_ChargeState.OneOf_OptionOutletTimeRemaining?
    var _optionPowerFeedTimeRemaining: CarServer_ChargeState.OneOf_OptionPowerFeedTimeRemaining?
    var _optionalPowershareFeatureAllowed: CarServer_ChargeState.OneOf_OptionalPowershareFeatureAllowed?
    var _optionalPowershareFeatureEnabled: CarServer_ChargeState.OneOf_OptionalPowershareFeatureEnabled?
    var _optionalPowershareRequest: CarServer_ChargeState.OneOf_OptionalPowershareRequest?
    var _optionalPowershareType: CarServer_ChargeState.OneOf_OptionalPowershareType?
    var _optionalPowershareStatus: CarServer_ChargeState.OneOf_OptionalPowershareStatus?
    var _optionalPowershareStopReason: CarServer_ChargeState.OneOf_OptionalPowershareStopReason?
    var _optionalPowershareInstantaneousLoadKw: CarServer_ChargeState.OneOf_OptionalPowershareInstantaneousLoadKw?
    var _optionalPowershareVehicleEnergyLeftHr: CarServer_ChargeState.OneOf_OptionalPowershareVehicleEnergyLeftHr?
    var _optionalPowershareSocLimit: CarServer_ChargeState.OneOf_OptionalPowershareSocLimit?
    var _optionalOneTimeSocLimit: CarServer_ChargeState.OneOf_OptionalOneTimeSocLimit?
    var _optionalHomeLocation: CarServer_ChargeState.OneOf_OptionalHomeLocation?
    var _optionalWorkLocation: CarServer_ChargeState.OneOf_OptionalWorkLocation?
    var _optionalOutletMaxTimerMinutes: CarServer_ChargeState.OneOf_OptionalOutletMaxTimerMinutes?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chargingState = source._chargingState
      _fastChargerType = source._fastChargerType
      _fastChargerBrand = source._fastChargerBrand
      _optionalChargeLimitSoc = source._optionalChargeLimitSoc
      _optionalChargeLimitSocStd = source._optionalChargeLimitSocStd
      _optionalChargeLimitSocMin = source._optionalChargeLimitSocMin
      _optionalChargeLimitSocMax = source._optionalChargeLimitSocMax
      _optionalMaxRangeChargeCounter = source._optionalMaxRangeChargeCounter
      _optionalFastChargerPresent = source._optionalFastChargerPresent
      _optionalBatteryRange = source._optionalBatteryRange
      _optionalEstBatteryRange = source._optionalEstBatteryRange
      _optionalIdealBatteryRange = source._optionalIdealBatteryRange
      _optionalBatteryLevel = source._optionalBatteryLevel
      _optionalUsableBatteryLevel = source._optionalUsableBatteryLevel
      _optionalChargeEnergyAdded = source._optionalChargeEnergyAdded
      _optionalChargeMilesAddedRated = source._optionalChargeMilesAddedRated
      _optionalChargeMilesAddedIdeal = source._optionalChargeMilesAddedIdeal
      _optionalChargerVoltage = source._optionalChargerVoltage
      _optionalChargerPilotCurrent = source._optionalChargerPilotCurrent
      _optionalChargerActualCurrent = source._optionalChargerActualCurrent
      _optionalChargerPower = source._optionalChargerPower
      _optionalMinutesToFullCharge = source._optionalMinutesToFullCharge
      _optionalMinutesToChargeLimit = source._optionalMinutesToChargeLimit
      _optionalTripCharging = source._optionalTripCharging
      _optionalChargeRateMph = source._optionalChargeRateMph
      _optionalChargePortDoorOpen = source._optionalChargePortDoorOpen
      _connChargeCable = source._connChargeCable
      _optionalScheduledChargingStartTime = source._optionalScheduledChargingStartTime
      _optionalScheduledChargingPending = source._optionalScheduledChargingPending
      _scheduledDepartureTime = source._scheduledDepartureTime
      _optionalUserChargeEnableRequest = source._optionalUserChargeEnableRequest
      _optionalChargeEnableRequest = source._optionalChargeEnableRequest
      _optionalChargerPhases = source._optionalChargerPhases
      _chargePortLatch = source._chargePortLatch
      _optionalChargePortColdWeatherMode = source._optionalChargePortColdWeatherMode
      _optionalChargeCurrentRequest = source._optionalChargeCurrentRequest
      _optionalChargeCurrentRequestMax = source._optionalChargeCurrentRequestMax
      _optionalManagedChargingActive = source._optionalManagedChargingActive
      _optionalManagedChargingUserCanceled = source._optionalManagedChargingUserCanceled
      _optionalManagedChargingStartTime = source._optionalManagedChargingStartTime
      _timestamp = source._timestamp
      _preconditioningTimes = source._preconditioningTimes
      _offPeakChargingTimes = source._offPeakChargingTimes
      _optionalOffPeakHoursEndTime = source._optionalOffPeakHoursEndTime
      _optionalScheduledChargingMode = source._optionalScheduledChargingMode
      _optionalChargingAmps = source._optionalChargingAmps
      _optionalScheduledChargingStartTimeMinutes = source._optionalScheduledChargingStartTimeMinutes
      _optionalScheduledDepartureTimeMinutes = source._optionalScheduledDepartureTimeMinutes
      _optionalPreconditioningEnabled = source._optionalPreconditioningEnabled
      _optionalScheduledChargingStartTimeApp = source._optionalScheduledChargingStartTimeApp
      _optionalSuperchargerSessionTripPlanner = source._optionalSuperchargerSessionTripPlanner
      _optionalChargePortColor = source._optionalChargePortColor
      _optionalChargeRateMphFloat = source._optionalChargeRateMphFloat
      _optionalChargeLimitReason = source._optionalChargeLimitReason
      _managedChargingState = source._managedChargingState
      _optionalChargeCableUnlatched = source._optionalChargeCableUnlatched
      _optionalOutletState = source._optionalOutletState
      _optionalPowerFeedState = source._optionalPowerFeedState
      _optionOutletSocLimit = source._optionOutletSocLimit
      _optionPowerFeedSocLimit = source._optionPowerFeedSocLimit
      _optionOutletTimeRemaining = source._optionOutletTimeRemaining
      _optionPowerFeedTimeRemaining = source._optionPowerFeedTimeRemaining
      _optionalPowershareFeatureAllowed = source._optionalPowershareFeatureAllowed
      _optionalPowershareFeatureEnabled = source._optionalPowershareFeatureEnabled
      _optionalPowershareRequest = source._optionalPowershareRequest
      _optionalPowershareType = source._optionalPowershareType
      _optionalPowershareStatus = source._optionalPowershareStatus
      _optionalPowershareStopReason = source._optionalPowershareStopReason
      _optionalPowershareInstantaneousLoadKw = source._optionalPowershareInstantaneousLoadKw
      _optionalPowershareVehicleEnergyLeftHr = source._optionalPowershareVehicleEnergyLeftHr
      _optionalPowershareSocLimit = source._optionalPowershareSocLimit
      _optionalOneTimeSocLimit = source._optionalOneTimeSocLimit
      _optionalHomeLocation = source._optionalHomeLocation
      _optionalWorkLocation = source._optionalWorkLocation
      _optionalOutletMaxTimerMinutes = source._optionalOutletMaxTimerMinutes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._chargingState) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._fastChargerType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._fastChargerBrand) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._connChargeCable) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledDepartureTime) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._chargePortLatch) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._preconditioningTimes) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._offPeakChargingTimes) }()
        case 104: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargeLimitSoc != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeLimitSoc = .chargeLimitSoc(v)
          }
        }()
        case 105: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargeLimitSocStd != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeLimitSocStd = .chargeLimitSocStd(v)
          }
        }()
        case 106: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargeLimitSocMin != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeLimitSocMin = .chargeLimitSocMin(v)
          }
        }()
        case 107: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargeLimitSocMax != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeLimitSocMax = .chargeLimitSocMax(v)
          }
        }()
        case 109: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalMaxRangeChargeCounter != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalMaxRangeChargeCounter = .maxRangeChargeCounter(v)
          }
        }()
        case 110: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalFastChargerPresent != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalFastChargerPresent = .fastChargerPresent(v)
          }
        }()
        case 111: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalBatteryRange != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalBatteryRange = .batteryRange(v)
          }
        }()
        case 112: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalEstBatteryRange != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalEstBatteryRange = .estBatteryRange(v)
          }
        }()
        case 113: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalIdealBatteryRange != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalIdealBatteryRange = .idealBatteryRange(v)
          }
        }()
        case 114: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalBatteryLevel != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalBatteryLevel = .batteryLevel(v)
          }
        }()
        case 115: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalUsableBatteryLevel != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalUsableBatteryLevel = .usableBatteryLevel(v)
          }
        }()
        case 116: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalChargeEnergyAdded != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeEnergyAdded = .chargeEnergyAdded(v)
          }
        }()
        case 117: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalChargeMilesAddedRated != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeMilesAddedRated = .chargeMilesAddedRated(v)
          }
        }()
        case 118: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalChargeMilesAddedIdeal != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeMilesAddedIdeal = .chargeMilesAddedIdeal(v)
          }
        }()
        case 119: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargerVoltage != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargerVoltage = .chargerVoltage(v)
          }
        }()
        case 120: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargerPilotCurrent != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargerPilotCurrent = .chargerPilotCurrent(v)
          }
        }()
        case 121: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargerActualCurrent != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargerActualCurrent = .chargerActualCurrent(v)
          }
        }()
        case 122: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargerPower != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargerPower = .chargerPower(v)
          }
        }()
        case 123: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalMinutesToFullCharge != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalMinutesToFullCharge = .minutesToFullCharge(v)
          }
        }()
        case 125: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTripCharging != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTripCharging = .tripCharging(v)
          }
        }()
        case 126: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargeRateMph != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeRateMph = .chargeRateMph(v)
          }
        }()
        case 127: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalChargePortDoorOpen != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargePortDoorOpen = .chargePortDoorOpen(v)
          }
        }()
        case 129: try {
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {
            if _storage._optionalScheduledChargingStartTime != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalScheduledChargingStartTime = .scheduledChargingStartTime(v)
          }
        }()
        case 130: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalScheduledChargingPending != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalScheduledChargingPending = .scheduledChargingPending(v)
          }
        }()
        case 132: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalUserChargeEnableRequest != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalUserChargeEnableRequest = .userChargeEnableRequest(v)
          }
        }()
        case 133: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalChargeEnableRequest != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeEnableRequest = .chargeEnableRequest(v)
          }
        }()
        case 134: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargerPhases != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargerPhases = .chargerPhases(v)
          }
        }()
        case 136: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalChargePortColdWeatherMode != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargePortColdWeatherMode = .chargePortColdWeatherMode(v)
          }
        }()
        case 137: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargeCurrentRequest != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeCurrentRequest = .chargeCurrentRequest(v)
          }
        }()
        case 138: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargeCurrentRequestMax != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeCurrentRequestMax = .chargeCurrentRequestMax(v)
          }
        }()
        case 139: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalManagedChargingActive != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalManagedChargingActive = .managedChargingActive(v)
          }
        }()
        case 140: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalManagedChargingUserCanceled != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalManagedChargingUserCanceled = .managedChargingUserCanceled(v)
          }
        }()
        case 141: try {
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {
            if _storage._optionalManagedChargingStartTime != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalManagedChargingStartTime = .managedChargingStartTime(v)
          }
        }()
        case 142: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalMinutesToChargeLimit != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalMinutesToChargeLimit = .minutesToChargeLimit(v)
          }
        }()
        case 147: try {
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {
            if _storage._optionalOffPeakHoursEndTime != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalOffPeakHoursEndTime = .offPeakHoursEndTime(v)
          }
        }()
        case 148: try {
          var v: CarServer_ChargeState.ScheduledChargingMode?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalScheduledChargingMode != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalScheduledChargingMode = .scheduledChargingMode(v)
          }
        }()
        case 149: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalChargingAmps != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargingAmps = .chargingAmps(v)
          }
        }()
        case 150: try {
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {
            if _storage._optionalScheduledChargingStartTimeMinutes != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalScheduledChargingStartTimeMinutes = .scheduledChargingStartTimeMinutes(v)
          }
        }()
        case 151: try {
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {
            if _storage._optionalScheduledDepartureTimeMinutes != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalScheduledDepartureTimeMinutes = .scheduledDepartureTimeMinutes(v)
          }
        }()
        case 152: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalPreconditioningEnabled != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPreconditioningEnabled = .preconditioningEnabled(v)
          }
        }()
        case 153: try {
          var v: Int32?
          try decoder.decodeSingularSInt32Field(value: &v)
          if let v = v {
            if _storage._optionalScheduledChargingStartTimeApp != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalScheduledChargingStartTimeApp = .scheduledChargingStartTimeApp(v)
          }
        }()
        case 154: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalSuperchargerSessionTripPlanner != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSuperchargerSessionTripPlanner = .superchargerSessionTripPlanner(v)
          }
        }()
        case 155: try {
          var v: CarServer_ChargeState.ChargePortColor_E?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalChargePortColor != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargePortColor = .chargePortColor(v)
          }
        }()
        case 156: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalChargeRateMphFloat != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeRateMphFloat = .chargeRateMphFloat(v)
          }
        }()
        case 157: try {
          var v: CarServer_ChargeState.ChargeLimitReason?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalChargeLimitReason != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeLimitReason = .chargeLimitReason(v)
          }
        }()
        case 158: try { try decoder.decodeSingularMessageField(value: &_storage._managedChargingState) }()
        case 159: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalChargeCableUnlatched != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalChargeCableUnlatched = .chargeCableUnlatched(v)
          }
        }()
        case 160: try {
          var v: CarServer_ChargeState.OutletState?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalOutletState != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalOutletState = .outletState(v)
          }
        }()
        case 161: try {
          var v: CarServer_ChargeState.PowerFeedState?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalPowerFeedState != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowerFeedState = .powerFeedState(v)
          }
        }()
        case 162: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionOutletSocLimit != nil {try decoder.handleConflictingOneOf()}
            _storage._optionOutletSocLimit = .outletSocLimit(v)
          }
        }()
        case 163: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionPowerFeedSocLimit != nil {try decoder.handleConflictingOneOf()}
            _storage._optionPowerFeedSocLimit = .powerFeedSocLimit(v)
          }
        }()
        case 164: try {
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {
            if _storage._optionOutletTimeRemaining != nil {try decoder.handleConflictingOneOf()}
            _storage._optionOutletTimeRemaining = .outletTimeRemaining(v)
          }
        }()
        case 165: try {
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {
            if _storage._optionPowerFeedTimeRemaining != nil {try decoder.handleConflictingOneOf()}
            _storage._optionPowerFeedTimeRemaining = .powerFeedTimeRemaining(v)
          }
        }()
        case 166: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalPowershareFeatureAllowed != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowershareFeatureAllowed = .powershareFeatureAllowed(v)
          }
        }()
        case 167: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalPowershareFeatureEnabled != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowershareFeatureEnabled = .powershareFeatureEnabled(v)
          }
        }()
        case 168: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalPowershareRequest != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowershareRequest = .powershareRequest(v)
          }
        }()
        case 169: try {
          var v: CarServer_ChargeState.PowershareType?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalPowershareType != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowershareType = .powershareType(v)
          }
        }()
        case 170: try {
          var v: CarServer_ChargeState.PowershareStatus?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalPowershareStatus != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowershareStatus = .powershareStatus(v)
          }
        }()
        case 171: try {
          var v: CarServer_ChargeState.PowershareStopReason?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalPowershareStopReason != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowershareStopReason = .powershareStopReason(v)
          }
        }()
        case 172: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalPowershareInstantaneousLoadKw != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowershareInstantaneousLoadKw = .powershareInstantaneousLoadKw(v)
          }
        }()
        case 173: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalPowershareVehicleEnergyLeftHr != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowershareVehicleEnergyLeftHr = .powershareVehicleEnergyLeftHr(v)
          }
        }()
        case 174: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalPowershareSocLimit != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPowershareSocLimit = .powershareSocLimit(v)
          }
        }()
        case 175: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalOneTimeSocLimit != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalOneTimeSocLimit = .oneTimeSocLimit(v)
          }
        }()
        case 176: try {
          var v: CarServer_LatLong?
          var hadOneofValue = false
          if let current = _storage._optionalHomeLocation {
            hadOneofValue = true
            if case .homeLocation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._optionalHomeLocation = .homeLocation(v)
          }
        }()
        case 177: try {
          var v: CarServer_LatLong?
          var hadOneofValue = false
          if let current = _storage._optionalWorkLocation {
            hadOneofValue = true
            if case .workLocation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._optionalWorkLocation = .workLocation(v)
          }
        }()
        case 178: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalOutletMaxTimerMinutes != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalOutletMaxTimerMinutes = .outletMaxTimerMinutes(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._chargingState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._fastChargerType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._fastChargerBrand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connChargeCable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._scheduledDepartureTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._chargePortLatch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._preconditioningTimes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._offPeakChargingTimes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      } }()
      try { if case .chargeLimitSoc(let v)? = _storage._optionalChargeLimitSoc {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 104)
      } }()
      try { if case .chargeLimitSocStd(let v)? = _storage._optionalChargeLimitSocStd {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 105)
      } }()
      try { if case .chargeLimitSocMin(let v)? = _storage._optionalChargeLimitSocMin {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 106)
      } }()
      try { if case .chargeLimitSocMax(let v)? = _storage._optionalChargeLimitSocMax {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 107)
      } }()
      try { if case .maxRangeChargeCounter(let v)? = _storage._optionalMaxRangeChargeCounter {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 109)
      } }()
      try { if case .fastChargerPresent(let v)? = _storage._optionalFastChargerPresent {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 110)
      } }()
      try { if case .batteryRange(let v)? = _storage._optionalBatteryRange {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 111)
      } }()
      try { if case .estBatteryRange(let v)? = _storage._optionalEstBatteryRange {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 112)
      } }()
      try { if case .idealBatteryRange(let v)? = _storage._optionalIdealBatteryRange {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 113)
      } }()
      try { if case .batteryLevel(let v)? = _storage._optionalBatteryLevel {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 114)
      } }()
      try { if case .usableBatteryLevel(let v)? = _storage._optionalUsableBatteryLevel {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 115)
      } }()
      try { if case .chargeEnergyAdded(let v)? = _storage._optionalChargeEnergyAdded {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 116)
      } }()
      try { if case .chargeMilesAddedRated(let v)? = _storage._optionalChargeMilesAddedRated {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 117)
      } }()
      try { if case .chargeMilesAddedIdeal(let v)? = _storage._optionalChargeMilesAddedIdeal {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 118)
      } }()
      try { if case .chargerVoltage(let v)? = _storage._optionalChargerVoltage {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 119)
      } }()
      try { if case .chargerPilotCurrent(let v)? = _storage._optionalChargerPilotCurrent {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 120)
      } }()
      try { if case .chargerActualCurrent(let v)? = _storage._optionalChargerActualCurrent {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 121)
      } }()
      try { if case .chargerPower(let v)? = _storage._optionalChargerPower {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 122)
      } }()
      try { if case .minutesToFullCharge(let v)? = _storage._optionalMinutesToFullCharge {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 123)
      } }()
      try { if case .tripCharging(let v)? = _storage._optionalTripCharging {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 125)
      } }()
      try { if case .chargeRateMph(let v)? = _storage._optionalChargeRateMph {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 126)
      } }()
      try { if case .chargePortDoorOpen(let v)? = _storage._optionalChargePortDoorOpen {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 127)
      } }()
      try { if case .scheduledChargingStartTime(let v)? = _storage._optionalScheduledChargingStartTime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 129)
      } }()
      try { if case .scheduledChargingPending(let v)? = _storage._optionalScheduledChargingPending {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 130)
      } }()
      try { if case .userChargeEnableRequest(let v)? = _storage._optionalUserChargeEnableRequest {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 132)
      } }()
      try { if case .chargeEnableRequest(let v)? = _storage._optionalChargeEnableRequest {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 133)
      } }()
      try { if case .chargerPhases(let v)? = _storage._optionalChargerPhases {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 134)
      } }()
      try { if case .chargePortColdWeatherMode(let v)? = _storage._optionalChargePortColdWeatherMode {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 136)
      } }()
      try { if case .chargeCurrentRequest(let v)? = _storage._optionalChargeCurrentRequest {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 137)
      } }()
      try { if case .chargeCurrentRequestMax(let v)? = _storage._optionalChargeCurrentRequestMax {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 138)
      } }()
      try { if case .managedChargingActive(let v)? = _storage._optionalManagedChargingActive {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 139)
      } }()
      try { if case .managedChargingUserCanceled(let v)? = _storage._optionalManagedChargingUserCanceled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 140)
      } }()
      try { if case .managedChargingStartTime(let v)? = _storage._optionalManagedChargingStartTime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 141)
      } }()
      try { if case .minutesToChargeLimit(let v)? = _storage._optionalMinutesToChargeLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 142)
      } }()
      try { if case .offPeakHoursEndTime(let v)? = _storage._optionalOffPeakHoursEndTime {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 147)
      } }()
      try { if case .scheduledChargingMode(let v)? = _storage._optionalScheduledChargingMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 148)
      } }()
      try { if case .chargingAmps(let v)? = _storage._optionalChargingAmps {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 149)
      } }()
      try { if case .scheduledChargingStartTimeMinutes(let v)? = _storage._optionalScheduledChargingStartTimeMinutes {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 150)
      } }()
      try { if case .scheduledDepartureTimeMinutes(let v)? = _storage._optionalScheduledDepartureTimeMinutes {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 151)
      } }()
      try { if case .preconditioningEnabled(let v)? = _storage._optionalPreconditioningEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 152)
      } }()
      try { if case .scheduledChargingStartTimeApp(let v)? = _storage._optionalScheduledChargingStartTimeApp {
        try visitor.visitSingularSInt32Field(value: v, fieldNumber: 153)
      } }()
      try { if case .superchargerSessionTripPlanner(let v)? = _storage._optionalSuperchargerSessionTripPlanner {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 154)
      } }()
      try { if case .chargePortColor(let v)? = _storage._optionalChargePortColor {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 155)
      } }()
      try { if case .chargeRateMphFloat(let v)? = _storage._optionalChargeRateMphFloat {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 156)
      } }()
      try { if case .chargeLimitReason(let v)? = _storage._optionalChargeLimitReason {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 157)
      } }()
      try { if let v = _storage._managedChargingState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 158)
      } }()
      try { if case .chargeCableUnlatched(let v)? = _storage._optionalChargeCableUnlatched {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 159)
      } }()
      try { if case .outletState(let v)? = _storage._optionalOutletState {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 160)
      } }()
      try { if case .powerFeedState(let v)? = _storage._optionalPowerFeedState {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 161)
      } }()
      try { if case .outletSocLimit(let v)? = _storage._optionOutletSocLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 162)
      } }()
      try { if case .powerFeedSocLimit(let v)? = _storage._optionPowerFeedSocLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 163)
      } }()
      try { if case .outletTimeRemaining(let v)? = _storage._optionOutletTimeRemaining {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 164)
      } }()
      try { if case .powerFeedTimeRemaining(let v)? = _storage._optionPowerFeedTimeRemaining {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 165)
      } }()
      try { if case .powershareFeatureAllowed(let v)? = _storage._optionalPowershareFeatureAllowed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 166)
      } }()
      try { if case .powershareFeatureEnabled(let v)? = _storage._optionalPowershareFeatureEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 167)
      } }()
      try { if case .powershareRequest(let v)? = _storage._optionalPowershareRequest {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 168)
      } }()
      try { if case .powershareType(let v)? = _storage._optionalPowershareType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 169)
      } }()
      try { if case .powershareStatus(let v)? = _storage._optionalPowershareStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 170)
      } }()
      try { if case .powershareStopReason(let v)? = _storage._optionalPowershareStopReason {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 171)
      } }()
      try { if case .powershareInstantaneousLoadKw(let v)? = _storage._optionalPowershareInstantaneousLoadKw {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 172)
      } }()
      try { if case .powershareVehicleEnergyLeftHr(let v)? = _storage._optionalPowershareVehicleEnergyLeftHr {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 173)
      } }()
      try { if case .powershareSocLimit(let v)? = _storage._optionalPowershareSocLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 174)
      } }()
      try { if case .oneTimeSocLimit(let v)? = _storage._optionalOneTimeSocLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 175)
      } }()
      try { if case .homeLocation(let v)? = _storage._optionalHomeLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 176)
      } }()
      try { if case .workLocation(let v)? = _storage._optionalWorkLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 177)
      } }()
      try { if case .outletMaxTimerMinutes(let v)? = _storage._optionalOutletMaxTimerMinutes {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 178)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeState, rhs: CarServer_ChargeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chargingState != rhs_storage._chargingState {return false}
        if _storage._fastChargerType != rhs_storage._fastChargerType {return false}
        if _storage._fastChargerBrand != rhs_storage._fastChargerBrand {return false}
        if _storage._optionalChargeLimitSoc != rhs_storage._optionalChargeLimitSoc {return false}
        if _storage._optionalChargeLimitSocStd != rhs_storage._optionalChargeLimitSocStd {return false}
        if _storage._optionalChargeLimitSocMin != rhs_storage._optionalChargeLimitSocMin {return false}
        if _storage._optionalChargeLimitSocMax != rhs_storage._optionalChargeLimitSocMax {return false}
        if _storage._optionalMaxRangeChargeCounter != rhs_storage._optionalMaxRangeChargeCounter {return false}
        if _storage._optionalFastChargerPresent != rhs_storage._optionalFastChargerPresent {return false}
        if _storage._optionalBatteryRange != rhs_storage._optionalBatteryRange {return false}
        if _storage._optionalEstBatteryRange != rhs_storage._optionalEstBatteryRange {return false}
        if _storage._optionalIdealBatteryRange != rhs_storage._optionalIdealBatteryRange {return false}
        if _storage._optionalBatteryLevel != rhs_storage._optionalBatteryLevel {return false}
        if _storage._optionalUsableBatteryLevel != rhs_storage._optionalUsableBatteryLevel {return false}
        if _storage._optionalChargeEnergyAdded != rhs_storage._optionalChargeEnergyAdded {return false}
        if _storage._optionalChargeMilesAddedRated != rhs_storage._optionalChargeMilesAddedRated {return false}
        if _storage._optionalChargeMilesAddedIdeal != rhs_storage._optionalChargeMilesAddedIdeal {return false}
        if _storage._optionalChargerVoltage != rhs_storage._optionalChargerVoltage {return false}
        if _storage._optionalChargerPilotCurrent != rhs_storage._optionalChargerPilotCurrent {return false}
        if _storage._optionalChargerActualCurrent != rhs_storage._optionalChargerActualCurrent {return false}
        if _storage._optionalChargerPower != rhs_storage._optionalChargerPower {return false}
        if _storage._optionalMinutesToFullCharge != rhs_storage._optionalMinutesToFullCharge {return false}
        if _storage._optionalMinutesToChargeLimit != rhs_storage._optionalMinutesToChargeLimit {return false}
        if _storage._optionalTripCharging != rhs_storage._optionalTripCharging {return false}
        if _storage._optionalChargeRateMph != rhs_storage._optionalChargeRateMph {return false}
        if _storage._optionalChargePortDoorOpen != rhs_storage._optionalChargePortDoorOpen {return false}
        if _storage._connChargeCable != rhs_storage._connChargeCable {return false}
        if _storage._optionalScheduledChargingStartTime != rhs_storage._optionalScheduledChargingStartTime {return false}
        if _storage._optionalScheduledChargingPending != rhs_storage._optionalScheduledChargingPending {return false}
        if _storage._scheduledDepartureTime != rhs_storage._scheduledDepartureTime {return false}
        if _storage._optionalUserChargeEnableRequest != rhs_storage._optionalUserChargeEnableRequest {return false}
        if _storage._optionalChargeEnableRequest != rhs_storage._optionalChargeEnableRequest {return false}
        if _storage._optionalChargerPhases != rhs_storage._optionalChargerPhases {return false}
        if _storage._chargePortLatch != rhs_storage._chargePortLatch {return false}
        if _storage._optionalChargePortColdWeatherMode != rhs_storage._optionalChargePortColdWeatherMode {return false}
        if _storage._optionalChargeCurrentRequest != rhs_storage._optionalChargeCurrentRequest {return false}
        if _storage._optionalChargeCurrentRequestMax != rhs_storage._optionalChargeCurrentRequestMax {return false}
        if _storage._optionalManagedChargingActive != rhs_storage._optionalManagedChargingActive {return false}
        if _storage._optionalManagedChargingUserCanceled != rhs_storage._optionalManagedChargingUserCanceled {return false}
        if _storage._optionalManagedChargingStartTime != rhs_storage._optionalManagedChargingStartTime {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._preconditioningTimes != rhs_storage._preconditioningTimes {return false}
        if _storage._offPeakChargingTimes != rhs_storage._offPeakChargingTimes {return false}
        if _storage._optionalOffPeakHoursEndTime != rhs_storage._optionalOffPeakHoursEndTime {return false}
        if _storage._optionalScheduledChargingMode != rhs_storage._optionalScheduledChargingMode {return false}
        if _storage._optionalChargingAmps != rhs_storage._optionalChargingAmps {return false}
        if _storage._optionalScheduledChargingStartTimeMinutes != rhs_storage._optionalScheduledChargingStartTimeMinutes {return false}
        if _storage._optionalScheduledDepartureTimeMinutes != rhs_storage._optionalScheduledDepartureTimeMinutes {return false}
        if _storage._optionalPreconditioningEnabled != rhs_storage._optionalPreconditioningEnabled {return false}
        if _storage._optionalScheduledChargingStartTimeApp != rhs_storage._optionalScheduledChargingStartTimeApp {return false}
        if _storage._optionalSuperchargerSessionTripPlanner != rhs_storage._optionalSuperchargerSessionTripPlanner {return false}
        if _storage._optionalChargePortColor != rhs_storage._optionalChargePortColor {return false}
        if _storage._optionalChargeRateMphFloat != rhs_storage._optionalChargeRateMphFloat {return false}
        if _storage._optionalChargeLimitReason != rhs_storage._optionalChargeLimitReason {return false}
        if _storage._managedChargingState != rhs_storage._managedChargingState {return false}
        if _storage._optionalChargeCableUnlatched != rhs_storage._optionalChargeCableUnlatched {return false}
        if _storage._optionalOutletState != rhs_storage._optionalOutletState {return false}
        if _storage._optionalPowerFeedState != rhs_storage._optionalPowerFeedState {return false}
        if _storage._optionOutletSocLimit != rhs_storage._optionOutletSocLimit {return false}
        if _storage._optionPowerFeedSocLimit != rhs_storage._optionPowerFeedSocLimit {return false}
        if _storage._optionOutletTimeRemaining != rhs_storage._optionOutletTimeRemaining {return false}
        if _storage._optionPowerFeedTimeRemaining != rhs_storage._optionPowerFeedTimeRemaining {return false}
        if _storage._optionalPowershareFeatureAllowed != rhs_storage._optionalPowershareFeatureAllowed {return false}
        if _storage._optionalPowershareFeatureEnabled != rhs_storage._optionalPowershareFeatureEnabled {return false}
        if _storage._optionalPowershareRequest != rhs_storage._optionalPowershareRequest {return false}
        if _storage._optionalPowershareType != rhs_storage._optionalPowershareType {return false}
        if _storage._optionalPowershareStatus != rhs_storage._optionalPowershareStatus {return false}
        if _storage._optionalPowershareStopReason != rhs_storage._optionalPowershareStopReason {return false}
        if _storage._optionalPowershareInstantaneousLoadKw != rhs_storage._optionalPowershareInstantaneousLoadKw {return false}
        if _storage._optionalPowershareVehicleEnergyLeftHr != rhs_storage._optionalPowershareVehicleEnergyLeftHr {return false}
        if _storage._optionalPowershareSocLimit != rhs_storage._optionalPowershareSocLimit {return false}
        if _storage._optionalOneTimeSocLimit != rhs_storage._optionalOneTimeSocLimit {return false}
        if _storage._optionalHomeLocation != rhs_storage._optionalHomeLocation {return false}
        if _storage._optionalWorkLocation != rhs_storage._optionalWorkLocation {return false}
        if _storage._optionalOutletMaxTimerMinutes != rhs_storage._optionalOutletMaxTimerMinutes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeState.ScheduledChargingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ScheduledChargingModeOff\0\u{1}ScheduledChargingModeStartAt\0\u{1}ScheduledChargingModeDepartBy\0")
}

extension CarServer_ChargeState.ChargePortColor_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ChargePortColorOff\0\u{1}ChargePortColorRed\0\u{1}ChargePortColorGreen\0\u{1}ChargePortColorBlue\0\u{1}ChargePortColorWhite\0\u{1}ChargePortColorFlashingGreen\0\u{1}ChargePortColorFlashingAmber\0\u{1}ChargePortColorAmber\0\u{1}ChargePortColorRave\0\u{1}ChargePortColorDebug\0\u{1}ChargePortColorFlashingBlue\0")
}

extension CarServer_ChargeState.ChargeLimitReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ChargeLimitReasonUnknown\0\u{1}ChargeLimitReasonNone\0\u{1}ChargeLimitReasonEvse\0\u{1}ChargeLimitReasonBattTempLow\0\u{1}ChargeLimitReasonHighSoc\0\u{1}ChargeLimitReasonCabin\0")
}

extension CarServer_ChargeState.OutletState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OutletStateOff\0\u{1}OutletStateCabinAndBed\0\u{1}OutletStateCabin\0")
}

extension CarServer_ChargeState.PowerFeedState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PowerFeedStateOff\0\u{1}PowerFeedStateCabinAndBed\0\u{1}PowerFeedStateCabin\0")
}

extension CarServer_ChargeState.PowershareStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PowershareStatusInactive\0\u{1}PowershareStatusInit\0\u{1}PowershareStatusActive\0\u{1}PowershareStatusStopped\0\u{1}PowershareStatusHandshaking\0\u{1}PowershareStatusActiveReconnectingSoon\0")
}

extension CarServer_ChargeState.PowershareType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PowershareTypeNone\0\u{1}PowershareTypeLoad\0\u{1}PowershareTypeHome\0")
}

extension CarServer_ChargeState.PowershareStopReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PowershareStopReasonNone\0\u{1}PowershareStopReasonSOCTooLow\0\u{1}PowershareStopReasonRetry\0\u{1}PowershareStopReasonFault\0\u{1}PowershareStopReasonUser\0\u{1}PowershareStopReasonReconnecting\0\u{1}PowershareStopReasonAuthentication\0")
}

extension CarServer_ChargeState.CableType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_ChargeState.protoMessageName + ".CableType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}SNA\0\u{1}IEC\0\u{1}SAE\0\u{3}GB_AC\0\u{3}GB_DC\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sna(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sna(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .iec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .iec(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sae(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sae(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .gbAc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .gbAc(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .gbDc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .gbDc(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .sna?: try {
      guard case .sna(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .iec?: try {
      guard case .iec(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sae?: try {
      guard case .sae(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .gbAc?: try {
      guard case .gbAc(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .gbDc?: try {
      guard case .gbDc(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeState.CableType, rhs: CarServer_ChargeState.CableType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeState.ChargerType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_ChargeState.protoMessageName + ".ChargerType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}SNA\0\u{1}Supercharger\0\u{1}Chademo\0\u{1}Gb\0\u{1}ACSingleWireCAN\0\u{1}Combo\0\u{1}MCSingleWireCAN\0\u{1}Other\0\u{1}Tesla\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sna(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sna(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .supercharger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .supercharger(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .chademo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .chademo(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .gb(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .gb(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .acsingleWireCan(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .acsingleWireCan(v)
        }
      }()
      case 6: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .combo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .combo(v)
        }
      }()
      case 7: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .mcsingleWireCan(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .mcsingleWireCan(v)
        }
      }()
      case 8: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .other(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .other(v)
        }
      }()
      case 9: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tesla(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tesla(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .sna?: try {
      guard case .sna(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .supercharger?: try {
      guard case .supercharger(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .chademo?: try {
      guard case .chademo(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .gb?: try {
      guard case .gb(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .acsingleWireCan?: try {
      guard case .acsingleWireCan(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .combo?: try {
      guard case .combo(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .mcsingleWireCan?: try {
      guard case .mcsingleWireCan(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .other?: try {
      guard case .other(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .tesla?: try {
      guard case .tesla(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeState.ChargerType, rhs: CarServer_ChargeState.ChargerType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeState.ChargingState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_ChargeState.protoMessageName + ".ChargingState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Unknown\0\u{1}Disconnected\0\u{1}NoPower\0\u{1}Starting\0\u{1}Charging\0\u{1}Complete\0\u{1}Stopped\0\u{1}Calibrating\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .unknown(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .disconnected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .disconnected(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPower(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPower(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .starting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .starting(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .charging(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .charging(v)
        }
      }()
      case 6: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .complete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .complete(v)
        }
      }()
      case 7: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .stopped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .stopped(v)
        }
      }()
      case 8: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .calibrating(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .calibrating(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .unknown?: try {
      guard case .unknown(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .disconnected?: try {
      guard case .disconnected(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .noPower?: try {
      guard case .noPower(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .starting?: try {
      guard case .starting(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .charging?: try {
      guard case .charging(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .complete?: try {
      guard case .complete(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .stopped?: try {
      guard case .stopped(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .calibrating?: try {
      guard case .calibrating(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeState.ChargingState, rhs: CarServer_ChargeState.ChargingState) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeState.ChargerBrand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_ChargeState.protoMessageName + ".ChargerBrand"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Tesla\0\u{1}SNA\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tesla(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tesla(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sna(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sna(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .tesla?: try {
      guard case .tesla(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sna?: try {
      guard case .sna(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeState.ChargerBrand, rhs: CarServer_ChargeState.ChargerBrand) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ManagedChargingState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManagedChargingState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}charge_on_solar_state\0\u{3}charge_on_solar_gateway_din\0\u{3}tesla_electric_asset_id\0\u{3}minutes_to_lower_limit\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chargeOnSolarState) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalChargeOnSolarGatewayDin != nil {try decoder.handleConflictingOneOf()}
          self.optionalChargeOnSolarGatewayDin = .chargeOnSolarGatewayDin(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalTeslaElectricAssetID != nil {try decoder.handleConflictingOneOf()}
          self.optionalTeslaElectricAssetID = .teslaElectricAssetID(v)
        }
      }()
      case 4: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.optionalMinutesToLowerLimit != nil {try decoder.handleConflictingOneOf()}
          self.optionalMinutesToLowerLimit = .minutesToLowerLimit(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chargeOnSolarState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if case .chargeOnSolarGatewayDin(let v)? = self.optionalChargeOnSolarGatewayDin {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if case .teslaElectricAssetID(let v)? = self.optionalTeslaElectricAssetID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if case .minutesToLowerLimit(let v)? = self.optionalMinutesToLowerLimit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ManagedChargingState, rhs: CarServer_ManagedChargingState) -> Bool {
    if lhs._chargeOnSolarState != rhs._chargeOnSolarState {return false}
    if lhs.optionalChargeOnSolarGatewayDin != rhs.optionalChargeOnSolarGatewayDin {return false}
    if lhs.optionalTeslaElectricAssetID != rhs.optionalTeslaElectricAssetID {return false}
    if lhs.optionalMinutesToLowerLimit != rhs.optionalMinutesToLowerLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeOnSolarState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOnSolarState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}not_allowed\0\u{3}no_charge_recommended\0\u{3}charging_on_excess_solar\0\u{3}charging_on_anything\0\u{4}\u{2}user_disabled\0\u{3}waiting_for_server\0\u{1}error\0\u{3}user_stopped\0\u{c}\u{5}\u{1}")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_ChargeOnSolarStateNotAllowed?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .notAllowed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .notAllowed(v)
        }
      }()
      case 2: try {
        var v: CarServer_ChargeOnSolarStateNoChargeRecommended?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .noChargeRecommended(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .noChargeRecommended(v)
        }
      }()
      case 3: try {
        var v: CarServer_ChargeOnSolarStateChargingOnExcessSolar?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .chargingOnExcessSolar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .chargingOnExcessSolar(v)
        }
      }()
      case 4: try {
        var v: CarServer_ChargeOnSolarStateChargingOnAnything?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .chargingOnAnything(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .chargingOnAnything(v)
        }
      }()
      case 6: try {
        var v: CarServer_ChargeOnSolarStateUserDisabled?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .userDisabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .userDisabled(v)
        }
      }()
      case 7: try {
        var v: CarServer_ChargeOnSolarStateWaitingForServer?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .waitingForServer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .waitingForServer(v)
        }
      }()
      case 8: try {
        var v: CarServer_ChargeOnSolarStateError?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .error(v)
        }
      }()
      case 9: try {
        var v: CarServer_ChargeOnSolarStateUserStopped?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .userStopped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .userStopped(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.state {
    case .notAllowed?: try {
      guard case .notAllowed(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .noChargeRecommended?: try {
      guard case .noChargeRecommended(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .chargingOnExcessSolar?: try {
      guard case .chargingOnExcessSolar(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .chargingOnAnything?: try {
      guard case .chargingOnAnything(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .userDisabled?: try {
      guard case .userDisabled(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .waitingForServer?: try {
      guard case .waitingForServer(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .error?: try {
      guard case .error(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .userStopped?: try {
      guard case .userStopped(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeOnSolarState, rhs: CarServer_ChargeOnSolarState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeOnSolarStateNotAllowed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOnSolarStateNotAllowed"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeOnSolarStateNotAllowed, rhs: CarServer_ChargeOnSolarStateNotAllowed) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeOnSolarStateNoChargeRecommended: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOnSolarStateNoChargeRecommended"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .invalid {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeOnSolarStateNoChargeRecommended, rhs: CarServer_ChargeOnSolarStateNoChargeRecommended) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeOnSolarStateChargingOnExcessSolar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOnSolarStateChargingOnExcessSolar"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeOnSolarStateChargingOnExcessSolar, rhs: CarServer_ChargeOnSolarStateChargingOnExcessSolar) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeOnSolarStateChargingOnAnything: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOnSolarStateChargingOnAnything"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeOnSolarStateChargingOnAnything, rhs: CarServer_ChargeOnSolarStateChargingOnAnything) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeOnSolarStateUserDisabled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOnSolarStateUserDisabled"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeOnSolarStateUserDisabled, rhs: CarServer_ChargeOnSolarStateUserDisabled) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeOnSolarStateWaitingForServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOnSolarStateWaitingForServer"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeOnSolarStateWaitingForServer, rhs: CarServer_ChargeOnSolarStateWaitingForServer) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeOnSolarStateError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOnSolarStateError"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeOnSolarStateError, rhs: CarServer_ChargeOnSolarStateError) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ChargeOnSolarStateUserStopped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOnSolarStateUserStopped"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ChargeOnSolarStateUserStopped, rhs: CarServer_ChargeOnSolarStateUserStopped) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_LocationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocationState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{8}native_type\0\u{2}\u{3}timestamp\0\u{2}Z\u{1}latitude\0\u{1}longitude\0\u{1}heading\0\u{3}gps_as_of\0\u{3}native_location_supported\0\u{3}native_latitude\0\u{3}native_longitude\0\u{4}\u{2}corrected_latitude\0\u{3}corrected_longitude\0\u{4}\u{2}homelink_nearby\0\u{3}location_name\0\u{3}geo_latitude\0\u{3}geo_longitude\0\u{3}geo_heading\0\u{3}geo_elevation\0\u{3}geo_accuracy\0\u{3}estimated_gps_valid\0\u{3}estimated_to_raw_distance\0\u{c}\u{c}\u{1}")

  fileprivate class _StorageClass {
    var _optionalLatitude: CarServer_LocationState.OneOf_OptionalLatitude?
    var _optionalLongitude: CarServer_LocationState.OneOf_OptionalLongitude?
    var _optionalHeading: CarServer_LocationState.OneOf_OptionalHeading?
    var _optionalGpsAsOf: CarServer_LocationState.OneOf_OptionalGpsAsOf?
    var _optionalNativeLocationSupported: CarServer_LocationState.OneOf_OptionalNativeLocationSupported?
    var _optionalNativeLatitude: CarServer_LocationState.OneOf_OptionalNativeLatitude?
    var _optionalNativeLongitude: CarServer_LocationState.OneOf_OptionalNativeLongitude?
    var _nativeType: CarServer_LocationState.GPSCoordinateType? = nil
    var _optionalCorrectedLatitude: CarServer_LocationState.OneOf_OptionalCorrectedLatitude?
    var _optionalCorrectedLongitude: CarServer_LocationState.OneOf_OptionalCorrectedLongitude?
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _optionalHomelinkNearby: CarServer_LocationState.OneOf_OptionalHomelinkNearby?
    var _optionalLocationName: CarServer_LocationState.OneOf_OptionalLocationName?
    var _optionalGeoLatitude: CarServer_LocationState.OneOf_OptionalGeoLatitude?
    var _optionalGeoLongitude: CarServer_LocationState.OneOf_OptionalGeoLongitude?
    var _optionalGeoHeading: CarServer_LocationState.OneOf_OptionalGeoHeading?
    var _optionalGeoElevation: CarServer_LocationState.OneOf_OptionalGeoElevation?
    var _optionalGeoAccuracy: CarServer_LocationState.OneOf_OptionalGeoAccuracy?
    var _optionalEstimatedGpsValid: CarServer_LocationState.OneOf_OptionalEstimatedGpsValid?
    var _optionalEstimatedToRawDistance: CarServer_LocationState.OneOf_OptionalEstimatedToRawDistance?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _optionalLatitude = source._optionalLatitude
      _optionalLongitude = source._optionalLongitude
      _optionalHeading = source._optionalHeading
      _optionalGpsAsOf = source._optionalGpsAsOf
      _optionalNativeLocationSupported = source._optionalNativeLocationSupported
      _optionalNativeLatitude = source._optionalNativeLatitude
      _optionalNativeLongitude = source._optionalNativeLongitude
      _nativeType = source._nativeType
      _optionalCorrectedLatitude = source._optionalCorrectedLatitude
      _optionalCorrectedLongitude = source._optionalCorrectedLongitude
      _timestamp = source._timestamp
      _optionalHomelinkNearby = source._optionalHomelinkNearby
      _optionalLocationName = source._optionalLocationName
      _optionalGeoLatitude = source._optionalGeoLatitude
      _optionalGeoLongitude = source._optionalGeoLongitude
      _optionalGeoHeading = source._optionalGeoHeading
      _optionalGeoElevation = source._optionalGeoElevation
      _optionalGeoAccuracy = source._optionalGeoAccuracy
      _optionalEstimatedGpsValid = source._optionalEstimatedGpsValid
      _optionalEstimatedToRawDistance = source._optionalEstimatedToRawDistance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._nativeType) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 101: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalLatitude != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalLatitude = .latitude(v)
          }
        }()
        case 102: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalLongitude != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalLongitude = .longitude(v)
          }
        }()
        case 103: try {
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {
            if _storage._optionalHeading != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalHeading = .heading(v)
          }
        }()
        case 104: try {
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {
            if _storage._optionalGpsAsOf != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalGpsAsOf = .gpsAsOf(v)
          }
        }()
        case 105: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalNativeLocationSupported != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalNativeLocationSupported = .nativeLocationSupported(v)
          }
        }()
        case 106: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalNativeLatitude != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalNativeLatitude = .nativeLatitude(v)
          }
        }()
        case 107: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalNativeLongitude != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalNativeLongitude = .nativeLongitude(v)
          }
        }()
        case 109: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalCorrectedLatitude != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalCorrectedLatitude = .correctedLatitude(v)
          }
        }()
        case 110: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalCorrectedLongitude != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalCorrectedLongitude = .correctedLongitude(v)
          }
        }()
        case 112: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalHomelinkNearby != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalHomelinkNearby = .homelinkNearby(v)
          }
        }()
        case 113: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._optionalLocationName != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalLocationName = .locationName(v)
          }
        }()
        case 114: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalGeoLatitude != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalGeoLatitude = .geoLatitude(v)
          }
        }()
        case 115: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalGeoLongitude != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalGeoLongitude = .geoLongitude(v)
          }
        }()
        case 116: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalGeoHeading != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalGeoHeading = .geoHeading(v)
          }
        }()
        case 117: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalGeoElevation != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalGeoElevation = .geoElevation(v)
          }
        }()
        case 118: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalGeoAccuracy != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalGeoAccuracy = .geoAccuracy(v)
          }
        }()
        case 119: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalEstimatedGpsValid != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalEstimatedGpsValid = .estimatedGpsValid(v)
          }
        }()
        case 120: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalEstimatedToRawDistance != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalEstimatedToRawDistance = .estimatedToRawDistance(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._nativeType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if case .latitude(let v)? = _storage._optionalLatitude {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 101)
      } }()
      try { if case .longitude(let v)? = _storage._optionalLongitude {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 102)
      } }()
      try { if case .heading(let v)? = _storage._optionalHeading {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 103)
      } }()
      try { if case .gpsAsOf(let v)? = _storage._optionalGpsAsOf {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 104)
      } }()
      try { if case .nativeLocationSupported(let v)? = _storage._optionalNativeLocationSupported {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 105)
      } }()
      try { if case .nativeLatitude(let v)? = _storage._optionalNativeLatitude {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 106)
      } }()
      try { if case .nativeLongitude(let v)? = _storage._optionalNativeLongitude {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 107)
      } }()
      try { if case .correctedLatitude(let v)? = _storage._optionalCorrectedLatitude {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 109)
      } }()
      try { if case .correctedLongitude(let v)? = _storage._optionalCorrectedLongitude {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 110)
      } }()
      try { if case .homelinkNearby(let v)? = _storage._optionalHomelinkNearby {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 112)
      } }()
      try { if case .locationName(let v)? = _storage._optionalLocationName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 113)
      } }()
      try { if case .geoLatitude(let v)? = _storage._optionalGeoLatitude {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 114)
      } }()
      try { if case .geoLongitude(let v)? = _storage._optionalGeoLongitude {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 115)
      } }()
      try { if case .geoHeading(let v)? = _storage._optionalGeoHeading {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 116)
      } }()
      try { if case .geoElevation(let v)? = _storage._optionalGeoElevation {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 117)
      } }()
      try { if case .geoAccuracy(let v)? = _storage._optionalGeoAccuracy {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 118)
      } }()
      try { if case .estimatedGpsValid(let v)? = _storage._optionalEstimatedGpsValid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 119)
      } }()
      try { if case .estimatedToRawDistance(let v)? = _storage._optionalEstimatedToRawDistance {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 120)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_LocationState, rhs: CarServer_LocationState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._optionalLatitude != rhs_storage._optionalLatitude {return false}
        if _storage._optionalLongitude != rhs_storage._optionalLongitude {return false}
        if _storage._optionalHeading != rhs_storage._optionalHeading {return false}
        if _storage._optionalGpsAsOf != rhs_storage._optionalGpsAsOf {return false}
        if _storage._optionalNativeLocationSupported != rhs_storage._optionalNativeLocationSupported {return false}
        if _storage._optionalNativeLatitude != rhs_storage._optionalNativeLatitude {return false}
        if _storage._optionalNativeLongitude != rhs_storage._optionalNativeLongitude {return false}
        if _storage._nativeType != rhs_storage._nativeType {return false}
        if _storage._optionalCorrectedLatitude != rhs_storage._optionalCorrectedLatitude {return false}
        if _storage._optionalCorrectedLongitude != rhs_storage._optionalCorrectedLongitude {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._optionalHomelinkNearby != rhs_storage._optionalHomelinkNearby {return false}
        if _storage._optionalLocationName != rhs_storage._optionalLocationName {return false}
        if _storage._optionalGeoLatitude != rhs_storage._optionalGeoLatitude {return false}
        if _storage._optionalGeoLongitude != rhs_storage._optionalGeoLongitude {return false}
        if _storage._optionalGeoHeading != rhs_storage._optionalGeoHeading {return false}
        if _storage._optionalGeoElevation != rhs_storage._optionalGeoElevation {return false}
        if _storage._optionalGeoAccuracy != rhs_storage._optionalGeoAccuracy {return false}
        if _storage._optionalEstimatedGpsValid != rhs_storage._optionalEstimatedGpsValid {return false}
        if _storage._optionalEstimatedToRawDistance != rhs_storage._optionalEstimatedToRawDistance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_LocationState.GPSCoordinateType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_LocationState.protoMessageName + ".GPSCoordinateType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}GCJ\0\u{1}WGS\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .gcj(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .gcj(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .wgs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .wgs(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .gcj?: try {
      guard case .gcj(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wgs?: try {
      guard case .wgs(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_LocationState.GPSCoordinateType, rhs: CarServer_LocationState.GPSCoordinateType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}J\u{1}guestMode\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 74: try { try decoder.decodeSingularMessageField(value: &self._guestMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._guestMode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleState, rhs: CarServer_VehicleState) -> Bool {
    if lhs._guestMode != rhs._guestMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_VehicleState.GuestMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_VehicleState.protoMessageName + ".GuestMode"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}GuestModeActive\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.guestModeActive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guestModeActive != false {
      try visitor.visitSingularBoolField(value: self.guestModeActive, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_VehicleState.GuestMode, rhs: CarServer_VehicleState.GuestMode) -> Bool {
    if lhs.guestModeActive != rhs.guestModeActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ClimateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClimateState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{1e}climate_keeper_mode\0\u{2}\u{3}timestamp\0\u{4}\u{2}defrost_mode\0\u{4}B\u{1}inside_temp_celsius\0\u{3}outside_temp_celsius\0\u{3}driver_temp_setting\0\u{3}passenger_temp_setting\0\u{3}left_temp_direction\0\u{3}right_temp_direction\0\u{3}is_front_defroster_on\0\u{3}is_rear_defroster_on\0\u{3}fan_status\0\u{3}is_climate_on\0\u{3}min_avail_temp_celsius\0\u{3}max_avail_temp_celsius\0\u{3}seat_heater_left\0\u{3}seat_heater_right\0\u{3}seat_heater_rear_left\0\u{3}seat_heater_rear_right\0\u{3}seat_heater_rear_center\0\u{3}seat_heater_rear_right_back\0\u{3}seat_heater_rear_left_back\0\u{3}seat_heater_third_row_right\0\u{3}seat_heater_third_row_left\0\u{3}battery_heater\0\u{3}battery_heater_no_power\0\u{4}\u{2}steering_wheel_heater\0\u{3}wiper_blade_heater\0\u{3}side_mirror_heaters\0\u{3}is_preconditioning\0\u{3}remote_heater_control_enabled\0\u{4}\u{5}bioweapon_mode_on\0\u{4}\u{2}is_auto_conditioning_on\0\u{3}auto_seat_climate_left\0\u{3}auto_seat_climate_right\0\u{3}seat_fan_front_left\0\u{3}seat_fan_front_right\0\u{3}allow_cabin_overheat_protection\0\u{3}supports_fan_only_cabin_overheat_protection\0\u{3}cabin_overheat_protection\0\u{3}cabin_overheat_protection_actively_cooling\0\u{4}\u{2}cop_activation_temperature\0\u{3}auto_steering_wheel_heat\0\u{3}steering_wheel_heat_level\0\u{4}\u{2}hvac_auto_request\0\u{3}cop_not_running_reason\0\u{c}Q\u{2}\u{1}")

  fileprivate class _StorageClass {
    var _optionalInsideTempCelsius: CarServer_ClimateState.OneOf_OptionalInsideTempCelsius?
    var _optionalOutsideTempCelsius: CarServer_ClimateState.OneOf_OptionalOutsideTempCelsius?
    var _optionalDriverTempSetting: CarServer_ClimateState.OneOf_OptionalDriverTempSetting?
    var _optionalPassengerTempSetting: CarServer_ClimateState.OneOf_OptionalPassengerTempSetting?
    var _optionalLeftTempDirection: CarServer_ClimateState.OneOf_OptionalLeftTempDirection?
    var _optionalRightTempDirection: CarServer_ClimateState.OneOf_OptionalRightTempDirection?
    var _optionalIsFrontDefrosterOn: CarServer_ClimateState.OneOf_OptionalIsFrontDefrosterOn?
    var _optionalIsRearDefrosterOn: CarServer_ClimateState.OneOf_OptionalIsRearDefrosterOn?
    var _optionalFanStatus: CarServer_ClimateState.OneOf_OptionalFanStatus?
    var _optionalIsClimateOn: CarServer_ClimateState.OneOf_OptionalIsClimateOn?
    var _optionalMinAvailTempCelsius: CarServer_ClimateState.OneOf_OptionalMinAvailTempCelsius?
    var _optionalMaxAvailTempCelsius: CarServer_ClimateState.OneOf_OptionalMaxAvailTempCelsius?
    var _optionalSeatHeaterLeft: CarServer_ClimateState.OneOf_OptionalSeatHeaterLeft?
    var _optionalSeatHeaterRight: CarServer_ClimateState.OneOf_OptionalSeatHeaterRight?
    var _optionalSeatHeaterRearLeft: CarServer_ClimateState.OneOf_OptionalSeatHeaterRearLeft?
    var _optionalSeatHeaterRearRight: CarServer_ClimateState.OneOf_OptionalSeatHeaterRearRight?
    var _optionalSeatHeaterRearCenter: CarServer_ClimateState.OneOf_OptionalSeatHeaterRearCenter?
    var _optionalSeatHeaterRearRightBack: CarServer_ClimateState.OneOf_OptionalSeatHeaterRearRightBack?
    var _optionalSeatHeaterRearLeftBack: CarServer_ClimateState.OneOf_OptionalSeatHeaterRearLeftBack?
    var _optionalSeatHeaterThirdRowRight: CarServer_ClimateState.OneOf_OptionalSeatHeaterThirdRowRight?
    var _optionalSeatHeaterThirdRowLeft: CarServer_ClimateState.OneOf_OptionalSeatHeaterThirdRowLeft?
    var _optionalBatteryHeater: CarServer_ClimateState.OneOf_OptionalBatteryHeater?
    var _optionalBatteryHeaterNoPower: CarServer_ClimateState.OneOf_OptionalBatteryHeaterNoPower?
    var _optionalSteeringWheelHeater: CarServer_ClimateState.OneOf_OptionalSteeringWheelHeater?
    var _optionalWiperBladeHeater: CarServer_ClimateState.OneOf_OptionalWiperBladeHeater?
    var _optionalSideMirrorHeaters: CarServer_ClimateState.OneOf_OptionalSideMirrorHeaters?
    var _optionalIsPreconditioning: CarServer_ClimateState.OneOf_OptionalIsPreconditioning?
    var _optionalRemoteHeaterControlEnabled: CarServer_ClimateState.OneOf_OptionalRemoteHeaterControlEnabled?
    var _climateKeeperMode: CarServer_ClimateState.ClimateKeeperMode? = nil
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _optionalBioweaponModeOn: CarServer_ClimateState.OneOf_OptionalBioweaponModeOn?
    var _defrostMode: CarServer_ClimateState.DefrostMode? = nil
    var _optionalIsAutoConditioningOn: CarServer_ClimateState.OneOf_OptionalIsAutoConditioningOn?
    var _optionalAutoSeatClimateLeft: CarServer_ClimateState.OneOf_OptionalAutoSeatClimateLeft?
    var _optionalAutoSeatClimateRight: CarServer_ClimateState.OneOf_OptionalAutoSeatClimateRight?
    var _optionalSeatFanFrontLeft: CarServer_ClimateState.OneOf_OptionalSeatFanFrontLeft?
    var _optionalSeatFanFrontRight: CarServer_ClimateState.OneOf_OptionalSeatFanFrontRight?
    var _optionalAllowCabinOverheatProtection: CarServer_ClimateState.OneOf_OptionalAllowCabinOverheatProtection?
    var _optionalSupportsFanOnlyCabinOverheatProtection: CarServer_ClimateState.OneOf_OptionalSupportsFanOnlyCabinOverheatProtection?
    var _optionalCabinOverheatProtection: CarServer_ClimateState.OneOf_OptionalCabinOverheatProtection?
    var _optionalCabinOverheatProtectionActivelyCooling: CarServer_ClimateState.OneOf_OptionalCabinOverheatProtectionActivelyCooling?
    var _optionalCopActivationTemperature: CarServer_ClimateState.OneOf_OptionalCopActivationTemperature?
    var _optionalAutoSteeringWheelHeat: CarServer_ClimateState.OneOf_OptionalAutoSteeringWheelHeat?
    var _optionalSteeringWheelHeatLevel: CarServer_ClimateState.OneOf_OptionalSteeringWheelHeatLevel?
    var _optionalHvacAutoRequest: CarServer_ClimateState.OneOf_OptionalHvacAutoRequest?
    var _optionalCopNotRunningReason: CarServer_ClimateState.OneOf_OptionalCopNotRunningReason?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _optionalInsideTempCelsius = source._optionalInsideTempCelsius
      _optionalOutsideTempCelsius = source._optionalOutsideTempCelsius
      _optionalDriverTempSetting = source._optionalDriverTempSetting
      _optionalPassengerTempSetting = source._optionalPassengerTempSetting
      _optionalLeftTempDirection = source._optionalLeftTempDirection
      _optionalRightTempDirection = source._optionalRightTempDirection
      _optionalIsFrontDefrosterOn = source._optionalIsFrontDefrosterOn
      _optionalIsRearDefrosterOn = source._optionalIsRearDefrosterOn
      _optionalFanStatus = source._optionalFanStatus
      _optionalIsClimateOn = source._optionalIsClimateOn
      _optionalMinAvailTempCelsius = source._optionalMinAvailTempCelsius
      _optionalMaxAvailTempCelsius = source._optionalMaxAvailTempCelsius
      _optionalSeatHeaterLeft = source._optionalSeatHeaterLeft
      _optionalSeatHeaterRight = source._optionalSeatHeaterRight
      _optionalSeatHeaterRearLeft = source._optionalSeatHeaterRearLeft
      _optionalSeatHeaterRearRight = source._optionalSeatHeaterRearRight
      _optionalSeatHeaterRearCenter = source._optionalSeatHeaterRearCenter
      _optionalSeatHeaterRearRightBack = source._optionalSeatHeaterRearRightBack
      _optionalSeatHeaterRearLeftBack = source._optionalSeatHeaterRearLeftBack
      _optionalSeatHeaterThirdRowRight = source._optionalSeatHeaterThirdRowRight
      _optionalSeatHeaterThirdRowLeft = source._optionalSeatHeaterThirdRowLeft
      _optionalBatteryHeater = source._optionalBatteryHeater
      _optionalBatteryHeaterNoPower = source._optionalBatteryHeaterNoPower
      _optionalSteeringWheelHeater = source._optionalSteeringWheelHeater
      _optionalWiperBladeHeater = source._optionalWiperBladeHeater
      _optionalSideMirrorHeaters = source._optionalSideMirrorHeaters
      _optionalIsPreconditioning = source._optionalIsPreconditioning
      _optionalRemoteHeaterControlEnabled = source._optionalRemoteHeaterControlEnabled
      _climateKeeperMode = source._climateKeeperMode
      _timestamp = source._timestamp
      _optionalBioweaponModeOn = source._optionalBioweaponModeOn
      _defrostMode = source._defrostMode
      _optionalIsAutoConditioningOn = source._optionalIsAutoConditioningOn
      _optionalAutoSeatClimateLeft = source._optionalAutoSeatClimateLeft
      _optionalAutoSeatClimateRight = source._optionalAutoSeatClimateRight
      _optionalSeatFanFrontLeft = source._optionalSeatFanFrontLeft
      _optionalSeatFanFrontRight = source._optionalSeatFanFrontRight
      _optionalAllowCabinOverheatProtection = source._optionalAllowCabinOverheatProtection
      _optionalSupportsFanOnlyCabinOverheatProtection = source._optionalSupportsFanOnlyCabinOverheatProtection
      _optionalCabinOverheatProtection = source._optionalCabinOverheatProtection
      _optionalCabinOverheatProtectionActivelyCooling = source._optionalCabinOverheatProtectionActivelyCooling
      _optionalCopActivationTemperature = source._optionalCopActivationTemperature
      _optionalAutoSteeringWheelHeat = source._optionalAutoSteeringWheelHeat
      _optionalSteeringWheelHeatLevel = source._optionalSteeringWheelHeatLevel
      _optionalHvacAutoRequest = source._optionalHvacAutoRequest
      _optionalCopNotRunningReason = source._optionalCopNotRunningReason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._climateKeeperMode) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._defrostMode) }()
        case 101: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalInsideTempCelsius != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalInsideTempCelsius = .insideTempCelsius(v)
          }
        }()
        case 102: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalOutsideTempCelsius != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalOutsideTempCelsius = .outsideTempCelsius(v)
          }
        }()
        case 103: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalDriverTempSetting != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalDriverTempSetting = .driverTempSetting(v)
          }
        }()
        case 104: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalPassengerTempSetting != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalPassengerTempSetting = .passengerTempSetting(v)
          }
        }()
        case 105: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalLeftTempDirection != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalLeftTempDirection = .leftTempDirection(v)
          }
        }()
        case 106: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalRightTempDirection != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalRightTempDirection = .rightTempDirection(v)
          }
        }()
        case 107: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalIsFrontDefrosterOn != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalIsFrontDefrosterOn = .isFrontDefrosterOn(v)
          }
        }()
        case 108: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalIsRearDefrosterOn != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalIsRearDefrosterOn = .isRearDefrosterOn(v)
          }
        }()
        case 109: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalFanStatus != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalFanStatus = .fanStatus(v)
          }
        }()
        case 110: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalIsClimateOn != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalIsClimateOn = .isClimateOn(v)
          }
        }()
        case 111: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalMinAvailTempCelsius != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalMinAvailTempCelsius = .minAvailTempCelsius(v)
          }
        }()
        case 112: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalMaxAvailTempCelsius != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalMaxAvailTempCelsius = .maxAvailTempCelsius(v)
          }
        }()
        case 113: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatHeaterLeft != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatHeaterLeft = .seatHeaterLeft(v)
          }
        }()
        case 114: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatHeaterRight != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatHeaterRight = .seatHeaterRight(v)
          }
        }()
        case 115: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatHeaterRearLeft != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatHeaterRearLeft = .seatHeaterRearLeft(v)
          }
        }()
        case 116: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatHeaterRearRight != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatHeaterRearRight = .seatHeaterRearRight(v)
          }
        }()
        case 117: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatHeaterRearCenter != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatHeaterRearCenter = .seatHeaterRearCenter(v)
          }
        }()
        case 118: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatHeaterRearRightBack != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatHeaterRearRightBack = .seatHeaterRearRightBack(v)
          }
        }()
        case 119: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatHeaterRearLeftBack != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatHeaterRearLeftBack = .seatHeaterRearLeftBack(v)
          }
        }()
        case 120: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatHeaterThirdRowRight != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatHeaterThirdRowRight = .seatHeaterThirdRowRight(v)
          }
        }()
        case 121: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatHeaterThirdRowLeft != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatHeaterThirdRowLeft = .seatHeaterThirdRowLeft(v)
          }
        }()
        case 122: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalBatteryHeater != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalBatteryHeater = .batteryHeater(v)
          }
        }()
        case 123: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalBatteryHeaterNoPower != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalBatteryHeaterNoPower = .batteryHeaterNoPower(v)
          }
        }()
        case 125: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalSteeringWheelHeater != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSteeringWheelHeater = .steeringWheelHeater(v)
          }
        }()
        case 126: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalWiperBladeHeater != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalWiperBladeHeater = .wiperBladeHeater(v)
          }
        }()
        case 127: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalSideMirrorHeaters != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSideMirrorHeaters = .sideMirrorHeaters(v)
          }
        }()
        case 128: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalIsPreconditioning != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalIsPreconditioning = .isPreconditioning(v)
          }
        }()
        case 129: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalRemoteHeaterControlEnabled != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalRemoteHeaterControlEnabled = .remoteHeaterControlEnabled(v)
          }
        }()
        case 134: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalBioweaponModeOn != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalBioweaponModeOn = .bioweaponModeOn(v)
          }
        }()
        case 136: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalIsAutoConditioningOn != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalIsAutoConditioningOn = .isAutoConditioningOn(v)
          }
        }()
        case 137: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalAutoSeatClimateLeft != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalAutoSeatClimateLeft = .autoSeatClimateLeft(v)
          }
        }()
        case 138: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalAutoSeatClimateRight != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalAutoSeatClimateRight = .autoSeatClimateRight(v)
          }
        }()
        case 139: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatFanFrontLeft != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatFanFrontLeft = .seatFanFrontLeft(v)
          }
        }()
        case 140: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._optionalSeatFanFrontRight != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSeatFanFrontRight = .seatFanFrontRight(v)
          }
        }()
        case 141: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalAllowCabinOverheatProtection != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalAllowCabinOverheatProtection = .allowCabinOverheatProtection(v)
          }
        }()
        case 142: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalSupportsFanOnlyCabinOverheatProtection != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSupportsFanOnlyCabinOverheatProtection = .supportsFanOnlyCabinOverheatProtection(v)
          }
        }()
        case 143: try {
          var v: CarServer_ClimateState.CabinOverheatProtection_E?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalCabinOverheatProtection != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalCabinOverheatProtection = .cabinOverheatProtection(v)
          }
        }()
        case 144: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalCabinOverheatProtectionActivelyCooling != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalCabinOverheatProtectionActivelyCooling = .cabinOverheatProtectionActivelyCooling(v)
          }
        }()
        case 146: try {
          var v: CarServer_ClimateState.CopActivationTemp?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalCopActivationTemperature != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalCopActivationTemperature = .copActivationTemperature(v)
          }
        }()
        case 147: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalAutoSteeringWheelHeat != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalAutoSteeringWheelHeat = .autoSteeringWheelHeat(v)
          }
        }()
        case 148: try {
          var v: CarServer_StwHeatLevel?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalSteeringWheelHeatLevel != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalSteeringWheelHeatLevel = .steeringWheelHeatLevel(v)
          }
        }()
        case 150: try {
          var v: CarServer_ClimateState.HvacAutoRequest?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalHvacAutoRequest != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalHvacAutoRequest = .hvacAutoRequest(v)
          }
        }()
        case 151: try {
          var v: CarServer_ClimateState.COPNotRunningReason?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._optionalCopNotRunningReason != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalCopNotRunningReason = .copNotRunningReason(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._climateKeeperMode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._defrostMode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if case .insideTempCelsius(let v)? = _storage._optionalInsideTempCelsius {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 101)
      } }()
      try { if case .outsideTempCelsius(let v)? = _storage._optionalOutsideTempCelsius {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 102)
      } }()
      try { if case .driverTempSetting(let v)? = _storage._optionalDriverTempSetting {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 103)
      } }()
      try { if case .passengerTempSetting(let v)? = _storage._optionalPassengerTempSetting {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 104)
      } }()
      try { if case .leftTempDirection(let v)? = _storage._optionalLeftTempDirection {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 105)
      } }()
      try { if case .rightTempDirection(let v)? = _storage._optionalRightTempDirection {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 106)
      } }()
      try { if case .isFrontDefrosterOn(let v)? = _storage._optionalIsFrontDefrosterOn {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 107)
      } }()
      try { if case .isRearDefrosterOn(let v)? = _storage._optionalIsRearDefrosterOn {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 108)
      } }()
      try { if case .fanStatus(let v)? = _storage._optionalFanStatus {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 109)
      } }()
      try { if case .isClimateOn(let v)? = _storage._optionalIsClimateOn {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 110)
      } }()
      try { if case .minAvailTempCelsius(let v)? = _storage._optionalMinAvailTempCelsius {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 111)
      } }()
      try { if case .maxAvailTempCelsius(let v)? = _storage._optionalMaxAvailTempCelsius {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 112)
      } }()
      try { if case .seatHeaterLeft(let v)? = _storage._optionalSeatHeaterLeft {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 113)
      } }()
      try { if case .seatHeaterRight(let v)? = _storage._optionalSeatHeaterRight {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 114)
      } }()
      try { if case .seatHeaterRearLeft(let v)? = _storage._optionalSeatHeaterRearLeft {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 115)
      } }()
      try { if case .seatHeaterRearRight(let v)? = _storage._optionalSeatHeaterRearRight {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 116)
      } }()
      try { if case .seatHeaterRearCenter(let v)? = _storage._optionalSeatHeaterRearCenter {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 117)
      } }()
      try { if case .seatHeaterRearRightBack(let v)? = _storage._optionalSeatHeaterRearRightBack {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 118)
      } }()
      try { if case .seatHeaterRearLeftBack(let v)? = _storage._optionalSeatHeaterRearLeftBack {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 119)
      } }()
      try { if case .seatHeaterThirdRowRight(let v)? = _storage._optionalSeatHeaterThirdRowRight {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 120)
      } }()
      try { if case .seatHeaterThirdRowLeft(let v)? = _storage._optionalSeatHeaterThirdRowLeft {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 121)
      } }()
      try { if case .batteryHeater(let v)? = _storage._optionalBatteryHeater {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 122)
      } }()
      try { if case .batteryHeaterNoPower(let v)? = _storage._optionalBatteryHeaterNoPower {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 123)
      } }()
      try { if case .steeringWheelHeater(let v)? = _storage._optionalSteeringWheelHeater {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 125)
      } }()
      try { if case .wiperBladeHeater(let v)? = _storage._optionalWiperBladeHeater {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 126)
      } }()
      try { if case .sideMirrorHeaters(let v)? = _storage._optionalSideMirrorHeaters {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 127)
      } }()
      try { if case .isPreconditioning(let v)? = _storage._optionalIsPreconditioning {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 128)
      } }()
      try { if case .remoteHeaterControlEnabled(let v)? = _storage._optionalRemoteHeaterControlEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 129)
      } }()
      try { if case .bioweaponModeOn(let v)? = _storage._optionalBioweaponModeOn {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 134)
      } }()
      try { if case .isAutoConditioningOn(let v)? = _storage._optionalIsAutoConditioningOn {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 136)
      } }()
      try { if case .autoSeatClimateLeft(let v)? = _storage._optionalAutoSeatClimateLeft {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 137)
      } }()
      try { if case .autoSeatClimateRight(let v)? = _storage._optionalAutoSeatClimateRight {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 138)
      } }()
      try { if case .seatFanFrontLeft(let v)? = _storage._optionalSeatFanFrontLeft {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 139)
      } }()
      try { if case .seatFanFrontRight(let v)? = _storage._optionalSeatFanFrontRight {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 140)
      } }()
      try { if case .allowCabinOverheatProtection(let v)? = _storage._optionalAllowCabinOverheatProtection {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 141)
      } }()
      try { if case .supportsFanOnlyCabinOverheatProtection(let v)? = _storage._optionalSupportsFanOnlyCabinOverheatProtection {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 142)
      } }()
      try { if case .cabinOverheatProtection(let v)? = _storage._optionalCabinOverheatProtection {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 143)
      } }()
      try { if case .cabinOverheatProtectionActivelyCooling(let v)? = _storage._optionalCabinOverheatProtectionActivelyCooling {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 144)
      } }()
      try { if case .copActivationTemperature(let v)? = _storage._optionalCopActivationTemperature {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 146)
      } }()
      try { if case .autoSteeringWheelHeat(let v)? = _storage._optionalAutoSteeringWheelHeat {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 147)
      } }()
      try { if case .steeringWheelHeatLevel(let v)? = _storage._optionalSteeringWheelHeatLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 148)
      } }()
      try { if case .hvacAutoRequest(let v)? = _storage._optionalHvacAutoRequest {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 150)
      } }()
      try { if case .copNotRunningReason(let v)? = _storage._optionalCopNotRunningReason {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 151)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ClimateState, rhs: CarServer_ClimateState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._optionalInsideTempCelsius != rhs_storage._optionalInsideTempCelsius {return false}
        if _storage._optionalOutsideTempCelsius != rhs_storage._optionalOutsideTempCelsius {return false}
        if _storage._optionalDriverTempSetting != rhs_storage._optionalDriverTempSetting {return false}
        if _storage._optionalPassengerTempSetting != rhs_storage._optionalPassengerTempSetting {return false}
        if _storage._optionalLeftTempDirection != rhs_storage._optionalLeftTempDirection {return false}
        if _storage._optionalRightTempDirection != rhs_storage._optionalRightTempDirection {return false}
        if _storage._optionalIsFrontDefrosterOn != rhs_storage._optionalIsFrontDefrosterOn {return false}
        if _storage._optionalIsRearDefrosterOn != rhs_storage._optionalIsRearDefrosterOn {return false}
        if _storage._optionalFanStatus != rhs_storage._optionalFanStatus {return false}
        if _storage._optionalIsClimateOn != rhs_storage._optionalIsClimateOn {return false}
        if _storage._optionalMinAvailTempCelsius != rhs_storage._optionalMinAvailTempCelsius {return false}
        if _storage._optionalMaxAvailTempCelsius != rhs_storage._optionalMaxAvailTempCelsius {return false}
        if _storage._optionalSeatHeaterLeft != rhs_storage._optionalSeatHeaterLeft {return false}
        if _storage._optionalSeatHeaterRight != rhs_storage._optionalSeatHeaterRight {return false}
        if _storage._optionalSeatHeaterRearLeft != rhs_storage._optionalSeatHeaterRearLeft {return false}
        if _storage._optionalSeatHeaterRearRight != rhs_storage._optionalSeatHeaterRearRight {return false}
        if _storage._optionalSeatHeaterRearCenter != rhs_storage._optionalSeatHeaterRearCenter {return false}
        if _storage._optionalSeatHeaterRearRightBack != rhs_storage._optionalSeatHeaterRearRightBack {return false}
        if _storage._optionalSeatHeaterRearLeftBack != rhs_storage._optionalSeatHeaterRearLeftBack {return false}
        if _storage._optionalSeatHeaterThirdRowRight != rhs_storage._optionalSeatHeaterThirdRowRight {return false}
        if _storage._optionalSeatHeaterThirdRowLeft != rhs_storage._optionalSeatHeaterThirdRowLeft {return false}
        if _storage._optionalBatteryHeater != rhs_storage._optionalBatteryHeater {return false}
        if _storage._optionalBatteryHeaterNoPower != rhs_storage._optionalBatteryHeaterNoPower {return false}
        if _storage._optionalSteeringWheelHeater != rhs_storage._optionalSteeringWheelHeater {return false}
        if _storage._optionalWiperBladeHeater != rhs_storage._optionalWiperBladeHeater {return false}
        if _storage._optionalSideMirrorHeaters != rhs_storage._optionalSideMirrorHeaters {return false}
        if _storage._optionalIsPreconditioning != rhs_storage._optionalIsPreconditioning {return false}
        if _storage._optionalRemoteHeaterControlEnabled != rhs_storage._optionalRemoteHeaterControlEnabled {return false}
        if _storage._climateKeeperMode != rhs_storage._climateKeeperMode {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._optionalBioweaponModeOn != rhs_storage._optionalBioweaponModeOn {return false}
        if _storage._defrostMode != rhs_storage._defrostMode {return false}
        if _storage._optionalIsAutoConditioningOn != rhs_storage._optionalIsAutoConditioningOn {return false}
        if _storage._optionalAutoSeatClimateLeft != rhs_storage._optionalAutoSeatClimateLeft {return false}
        if _storage._optionalAutoSeatClimateRight != rhs_storage._optionalAutoSeatClimateRight {return false}
        if _storage._optionalSeatFanFrontLeft != rhs_storage._optionalSeatFanFrontLeft {return false}
        if _storage._optionalSeatFanFrontRight != rhs_storage._optionalSeatFanFrontRight {return false}
        if _storage._optionalAllowCabinOverheatProtection != rhs_storage._optionalAllowCabinOverheatProtection {return false}
        if _storage._optionalSupportsFanOnlyCabinOverheatProtection != rhs_storage._optionalSupportsFanOnlyCabinOverheatProtection {return false}
        if _storage._optionalCabinOverheatProtection != rhs_storage._optionalCabinOverheatProtection {return false}
        if _storage._optionalCabinOverheatProtectionActivelyCooling != rhs_storage._optionalCabinOverheatProtectionActivelyCooling {return false}
        if _storage._optionalCopActivationTemperature != rhs_storage._optionalCopActivationTemperature {return false}
        if _storage._optionalAutoSteeringWheelHeat != rhs_storage._optionalAutoSteeringWheelHeat {return false}
        if _storage._optionalSteeringWheelHeatLevel != rhs_storage._optionalSteeringWheelHeatLevel {return false}
        if _storage._optionalHvacAutoRequest != rhs_storage._optionalHvacAutoRequest {return false}
        if _storage._optionalCopNotRunningReason != rhs_storage._optionalCopNotRunningReason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ClimateState.HvacAutoRequest: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0HvacAutoRequestOn\0\u{1}HvacAutoRequestOverride\0")
}

extension CarServer_ClimateState.CabinOverheatProtection_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CabinOverheatProtectionOff\0\u{1}CabinOverheatProtectionOn\0\u{1}CabinOverheatProtectionFanOnly\0")
}

extension CarServer_ClimateState.SeatHeaterLevel_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SeatHeaterLevelOff\0\u{1}SeatHeaterLevelLow\0\u{1}SeatHeaterLevelMed\0\u{1}SeatHeaterLevelHigh\0")
}

extension CarServer_ClimateState.SeatCoolingLevel_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SeatCoolingLevelOff\0\u{1}SeatCoolingLevelLow\0\u{1}SeatCoolingLevelMed\0\u{1}SeatCoolingLevelHigh\0")
}

extension CarServer_ClimateState.CopActivationTemp: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CopActivationTempUnspecified\0\u{1}CopActivationTempLow\0\u{1}CopActivationTempMedium\0\u{1}CopActivationTempHigh\0")
}

extension CarServer_ClimateState.COPNotRunningReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0COPNotRunningReasonNoReason\0\u{1}COPNotRunningReasonUserInteraction\0\u{1}COPNotRunningReasonEnergyConsumptionReached\0\u{1}COPNotRunningReasonTimeout\0\u{1}COPNotRunningReasonLowSolarLoad\0\u{1}COPNotRunningReasonFault\0\u{1}COPNotRunningReasonCabinBelowThreshold\0")
}

extension CarServer_ClimateState.ClimateKeeperMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_ClimateState.protoMessageName + ".ClimateKeeperMode"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Unknown\0\u{1}Off\0\u{1}On\0\u{1}Dog\0\u{1}Party\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .unknown(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .off(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .off(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .on(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .on(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .dog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .dog(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .party(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .party(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .unknown?: try {
      guard case .unknown(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .off?: try {
      guard case .off(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .on?: try {
      guard case .on(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dog?: try {
      guard case .dog(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .party?: try {
      guard case .party(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ClimateState.ClimateKeeperMode, rhs: CarServer_ClimateState.ClimateKeeperMode) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ClimateState.DefrostMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CarServer_ClimateState.protoMessageName + ".DefrostMode"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Off\0\u{1}Normal\0\u{1}Max\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .off(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .off(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .normal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .normal(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .max(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .max(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .off?: try {
      guard case .off(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .normal?: try {
      guard case .normal(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .max?: try {
      guard case .max(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ClimateState.DefrostMode, rhs: CarServer_ClimateState.DefrostMode) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_TirePressureState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TirePressureState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}timestamp\0\u{3}tpms_pressure_fl\0\u{3}tpms_pressure_fr\0\u{3}tpms_pressure_rl\0\u{3}tpms_pressure_rr\0\u{3}tpms_last_seen_pressure_time_fl\0\u{3}tpms_last_seen_pressure_time_fr\0\u{3}tpms_last_seen_pressure_time_rl\0\u{3}tpms_last_seen_pressure_time_rr\0\u{3}tpms_hard_warning_fl\0\u{3}tpms_hard_warning_fr\0\u{3}tpms_hard_warning_rl\0\u{3}tpms_hard_warning_rr\0\u{3}tpms_soft_warning_fl\0\u{3}tpms_soft_warning_fr\0\u{3}tpms_soft_warning_rl\0\u{3}tpms_soft_warning_rr\0\u{3}tpms_rcp_front_value\0\u{3}tpms_rcp_rear_value\0")

  fileprivate class _StorageClass {
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _optionalTpmsPressureFl: CarServer_TirePressureState.OneOf_OptionalTpmsPressureFl?
    var _optionalTpmsPressureFr: CarServer_TirePressureState.OneOf_OptionalTpmsPressureFr?
    var _optionalTpmsPressureRl: CarServer_TirePressureState.OneOf_OptionalTpmsPressureRl?
    var _optionalTpmsPressureRr: CarServer_TirePressureState.OneOf_OptionalTpmsPressureRr?
    var _tpmsLastSeenPressureTimeFl: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _tpmsLastSeenPressureTimeFr: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _tpmsLastSeenPressureTimeRl: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _tpmsLastSeenPressureTimeRr: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _optionalTpmsHardWarningFl: CarServer_TirePressureState.OneOf_OptionalTpmsHardWarningFl?
    var _optionalTpmsHardWarningFr: CarServer_TirePressureState.OneOf_OptionalTpmsHardWarningFr?
    var _optionalTpmsHardWarningRl: CarServer_TirePressureState.OneOf_OptionalTpmsHardWarningRl?
    var _optionalTpmsHardWarningRr: CarServer_TirePressureState.OneOf_OptionalTpmsHardWarningRr?
    var _optionalTpmsSoftWarningFl: CarServer_TirePressureState.OneOf_OptionalTpmsSoftWarningFl?
    var _optionalTpmsSoftWarningFr: CarServer_TirePressureState.OneOf_OptionalTpmsSoftWarningFr?
    var _optionalTpmsSoftWarningRl: CarServer_TirePressureState.OneOf_OptionalTpmsSoftWarningRl?
    var _optionalTpmsSoftWarningRr: CarServer_TirePressureState.OneOf_OptionalTpmsSoftWarningRr?
    var _optionalTpmsRcpFrontValue: CarServer_TirePressureState.OneOf_OptionalTpmsRcpFrontValue?
    var _optionalTpmsRcpRearValue: CarServer_TirePressureState.OneOf_OptionalTpmsRcpRearValue?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamp = source._timestamp
      _optionalTpmsPressureFl = source._optionalTpmsPressureFl
      _optionalTpmsPressureFr = source._optionalTpmsPressureFr
      _optionalTpmsPressureRl = source._optionalTpmsPressureRl
      _optionalTpmsPressureRr = source._optionalTpmsPressureRr
      _tpmsLastSeenPressureTimeFl = source._tpmsLastSeenPressureTimeFl
      _tpmsLastSeenPressureTimeFr = source._tpmsLastSeenPressureTimeFr
      _tpmsLastSeenPressureTimeRl = source._tpmsLastSeenPressureTimeRl
      _tpmsLastSeenPressureTimeRr = source._tpmsLastSeenPressureTimeRr
      _optionalTpmsHardWarningFl = source._optionalTpmsHardWarningFl
      _optionalTpmsHardWarningFr = source._optionalTpmsHardWarningFr
      _optionalTpmsHardWarningRl = source._optionalTpmsHardWarningRl
      _optionalTpmsHardWarningRr = source._optionalTpmsHardWarningRr
      _optionalTpmsSoftWarningFl = source._optionalTpmsSoftWarningFl
      _optionalTpmsSoftWarningFr = source._optionalTpmsSoftWarningFr
      _optionalTpmsSoftWarningRl = source._optionalTpmsSoftWarningRl
      _optionalTpmsSoftWarningRr = source._optionalTpmsSoftWarningRr
      _optionalTpmsRcpFrontValue = source._optionalTpmsRcpFrontValue
      _optionalTpmsRcpRearValue = source._optionalTpmsRcpRearValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 2: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalTpmsPressureFl != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsPressureFl = .tpmsPressureFl(v)
          }
        }()
        case 3: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalTpmsPressureFr != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsPressureFr = .tpmsPressureFr(v)
          }
        }()
        case 4: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalTpmsPressureRl != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsPressureRl = .tpmsPressureRl(v)
          }
        }()
        case 5: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalTpmsPressureRr != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsPressureRr = .tpmsPressureRr(v)
          }
        }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._tpmsLastSeenPressureTimeFl) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tpmsLastSeenPressureTimeFr) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._tpmsLastSeenPressureTimeRl) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tpmsLastSeenPressureTimeRr) }()
        case 10: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTpmsHardWarningFl != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsHardWarningFl = .tpmsHardWarningFl(v)
          }
        }()
        case 11: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTpmsHardWarningFr != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsHardWarningFr = .tpmsHardWarningFr(v)
          }
        }()
        case 12: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTpmsHardWarningRl != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsHardWarningRl = .tpmsHardWarningRl(v)
          }
        }()
        case 13: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTpmsHardWarningRr != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsHardWarningRr = .tpmsHardWarningRr(v)
          }
        }()
        case 14: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTpmsSoftWarningFl != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsSoftWarningFl = .tpmsSoftWarningFl(v)
          }
        }()
        case 15: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTpmsSoftWarningFr != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsSoftWarningFr = .tpmsSoftWarningFr(v)
          }
        }()
        case 16: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTpmsSoftWarningRl != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsSoftWarningRl = .tpmsSoftWarningRl(v)
          }
        }()
        case 17: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._optionalTpmsSoftWarningRr != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsSoftWarningRr = .tpmsSoftWarningRr(v)
          }
        }()
        case 18: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalTpmsRcpFrontValue != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsRcpFrontValue = .tpmsRcpFrontValue(v)
          }
        }()
        case 19: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._optionalTpmsRcpRearValue != nil {try decoder.handleConflictingOneOf()}
            _storage._optionalTpmsRcpRearValue = .tpmsRcpRearValue(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if case .tpmsPressureFl(let v)? = _storage._optionalTpmsPressureFl {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      } }()
      try { if case .tpmsPressureFr(let v)? = _storage._optionalTpmsPressureFr {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if case .tpmsPressureRl(let v)? = _storage._optionalTpmsPressureRl {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if case .tpmsPressureRr(let v)? = _storage._optionalTpmsPressureRr {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._tpmsLastSeenPressureTimeFl {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._tpmsLastSeenPressureTimeFr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._tpmsLastSeenPressureTimeRl {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._tpmsLastSeenPressureTimeRr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if case .tpmsHardWarningFl(let v)? = _storage._optionalTpmsHardWarningFl {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if case .tpmsHardWarningFr(let v)? = _storage._optionalTpmsHardWarningFr {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if case .tpmsHardWarningRl(let v)? = _storage._optionalTpmsHardWarningRl {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if case .tpmsHardWarningRr(let v)? = _storage._optionalTpmsHardWarningRr {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if case .tpmsSoftWarningFl(let v)? = _storage._optionalTpmsSoftWarningFl {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if case .tpmsSoftWarningFr(let v)? = _storage._optionalTpmsSoftWarningFr {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if case .tpmsSoftWarningRl(let v)? = _storage._optionalTpmsSoftWarningRl {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      try { if case .tpmsSoftWarningRr(let v)? = _storage._optionalTpmsSoftWarningRr {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      try { if case .tpmsRcpFrontValue(let v)? = _storage._optionalTpmsRcpFrontValue {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 18)
      } }()
      try { if case .tpmsRcpRearValue(let v)? = _storage._optionalTpmsRcpRearValue {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_TirePressureState, rhs: CarServer_TirePressureState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._optionalTpmsPressureFl != rhs_storage._optionalTpmsPressureFl {return false}
        if _storage._optionalTpmsPressureFr != rhs_storage._optionalTpmsPressureFr {return false}
        if _storage._optionalTpmsPressureRl != rhs_storage._optionalTpmsPressureRl {return false}
        if _storage._optionalTpmsPressureRr != rhs_storage._optionalTpmsPressureRr {return false}
        if _storage._tpmsLastSeenPressureTimeFl != rhs_storage._tpmsLastSeenPressureTimeFl {return false}
        if _storage._tpmsLastSeenPressureTimeFr != rhs_storage._tpmsLastSeenPressureTimeFr {return false}
        if _storage._tpmsLastSeenPressureTimeRl != rhs_storage._tpmsLastSeenPressureTimeRl {return false}
        if _storage._tpmsLastSeenPressureTimeRr != rhs_storage._tpmsLastSeenPressureTimeRr {return false}
        if _storage._optionalTpmsHardWarningFl != rhs_storage._optionalTpmsHardWarningFl {return false}
        if _storage._optionalTpmsHardWarningFr != rhs_storage._optionalTpmsHardWarningFr {return false}
        if _storage._optionalTpmsHardWarningRl != rhs_storage._optionalTpmsHardWarningRl {return false}
        if _storage._optionalTpmsHardWarningRr != rhs_storage._optionalTpmsHardWarningRr {return false}
        if _storage._optionalTpmsSoftWarningFl != rhs_storage._optionalTpmsSoftWarningFl {return false}
        if _storage._optionalTpmsSoftWarningFr != rhs_storage._optionalTpmsSoftWarningFr {return false}
        if _storage._optionalTpmsSoftWarningRl != rhs_storage._optionalTpmsSoftWarningRl {return false}
        if _storage._optionalTpmsSoftWarningRr != rhs_storage._optionalTpmsSoftWarningRr {return false}
        if _storage._optionalTpmsRcpFrontValue != rhs_storage._optionalTpmsRcpFrontValue {return false}
        if _storage._optionalTpmsRcpRearValue != rhs_storage._optionalTpmsRcpRearValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_MediaState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}timestamp\0\u{3}remote_control_enabled\0\u{3}now_playing_artist\0\u{3}now_playing_title\0\u{3}audio_volume\0\u{3}audio_volume_increment\0\u{3}audio_volume_max\0\u{3}now_playing_source\0\u{3}media_playback_status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.optionalRemoteControlEnabled != nil {try decoder.handleConflictingOneOf()}
          self.optionalRemoteControlEnabled = .remoteControlEnabled(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalNowPlayingArtist != nil {try decoder.handleConflictingOneOf()}
          self.optionalNowPlayingArtist = .nowPlayingArtist(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalNowPlayingTitle != nil {try decoder.handleConflictingOneOf()}
          self.optionalNowPlayingTitle = .nowPlayingTitle(v)
        }
      }()
      case 5: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalAudioVolume != nil {try decoder.handleConflictingOneOf()}
          self.optionalAudioVolume = .audioVolume(v)
        }
      }()
      case 6: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalAudioVolumeIncrement != nil {try decoder.handleConflictingOneOf()}
          self.optionalAudioVolumeIncrement = .audioVolumeIncrement(v)
        }
      }()
      case 7: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.optionalAudioVolumeMax != nil {try decoder.handleConflictingOneOf()}
          self.optionalAudioVolumeMax = .audioVolumeMax(v)
        }
      }()
      case 8: try {
        var v: CarServer_MediaSourceType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.optionalNowPlayingSource != nil {try decoder.handleConflictingOneOf()}
          self.optionalNowPlayingSource = .nowPlayingSource(v)
        }
      }()
      case 9: try {
        var v: CarServer_MediaPlaybackStatus?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.optionalMediaPlaybackStatus != nil {try decoder.handleConflictingOneOf()}
          self.optionalMediaPlaybackStatus = .mediaPlaybackStatus(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if case .remoteControlEnabled(let v)? = self.optionalRemoteControlEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if case .nowPlayingArtist(let v)? = self.optionalNowPlayingArtist {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if case .nowPlayingTitle(let v)? = self.optionalNowPlayingTitle {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if case .audioVolume(let v)? = self.optionalAudioVolume {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if case .audioVolumeIncrement(let v)? = self.optionalAudioVolumeIncrement {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if case .audioVolumeMax(let v)? = self.optionalAudioVolumeMax {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try { if case .nowPlayingSource(let v)? = self.optionalNowPlayingSource {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
    } }()
    try { if case .mediaPlaybackStatus(let v)? = self.optionalMediaPlaybackStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_MediaState, rhs: CarServer_MediaState) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.optionalRemoteControlEnabled != rhs.optionalRemoteControlEnabled {return false}
    if lhs.optionalNowPlayingArtist != rhs.optionalNowPlayingArtist {return false}
    if lhs.optionalNowPlayingTitle != rhs.optionalNowPlayingTitle {return false}
    if lhs.optionalAudioVolume != rhs.optionalAudioVolume {return false}
    if lhs.optionalAudioVolumeIncrement != rhs.optionalAudioVolumeIncrement {return false}
    if lhs.optionalAudioVolumeMax != rhs.optionalAudioVolumeMax {return false}
    if lhs.optionalNowPlayingSource != rhs.optionalNowPlayingSource {return false}
    if lhs.optionalMediaPlaybackStatus != rhs.optionalMediaPlaybackStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_MediaDetailState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaDetailState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}timestamp\0\u{3}now_playing_duration\0\u{3}now_playing_elapsed\0\u{3}now_playing_source_string\0\u{3}now_playing_album\0\u{3}now_playing_station\0\u{3}a2dp_source_name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.optionalNowPlayingDuration != nil {try decoder.handleConflictingOneOf()}
          self.optionalNowPlayingDuration = .nowPlayingDuration(v)
        }
      }()
      case 3: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.optionalNowPlayingElapsed != nil {try decoder.handleConflictingOneOf()}
          self.optionalNowPlayingElapsed = .nowPlayingElapsed(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalNowPlayingSourceString != nil {try decoder.handleConflictingOneOf()}
          self.optionalNowPlayingSourceString = .nowPlayingSourceString(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalNowPlayingAlbum != nil {try decoder.handleConflictingOneOf()}
          self.optionalNowPlayingAlbum = .nowPlayingAlbum(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalNowPlayingStation != nil {try decoder.handleConflictingOneOf()}
          self.optionalNowPlayingStation = .nowPlayingStation(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.optionalA2DpSourceName != nil {try decoder.handleConflictingOneOf()}
          self.optionalA2DpSourceName = .a2DpSourceName(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if case .nowPlayingDuration(let v)? = self.optionalNowPlayingDuration {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if case .nowPlayingElapsed(let v)? = self.optionalNowPlayingElapsed {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if case .nowPlayingSourceString(let v)? = self.optionalNowPlayingSourceString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if case .nowPlayingAlbum(let v)? = self.optionalNowPlayingAlbum {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if case .nowPlayingStation(let v)? = self.optionalNowPlayingStation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if case .a2DpSourceName(let v)? = self.optionalA2DpSourceName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_MediaDetailState, rhs: CarServer_MediaDetailState) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.optionalNowPlayingDuration != rhs.optionalNowPlayingDuration {return false}
    if lhs.optionalNowPlayingElapsed != rhs.optionalNowPlayingElapsed {return false}
    if lhs.optionalNowPlayingSourceString != rhs.optionalNowPlayingSourceString {return false}
    if lhs.optionalNowPlayingAlbum != rhs.optionalNowPlayingAlbum {return false}
    if lhs.optionalNowPlayingStation != rhs.optionalNowPlayingStation {return false}
    if lhs.optionalA2DpSourceName != rhs.optionalA2DpSourceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarServer_ShiftState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShiftState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Invalid\0\u{1}P\0\u{1}R\0\u{1}N\0\u{1}D\0\u{1}SNA\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .invalid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .invalid(v)
        }
      }()
      case 2: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .p(v)
        }
      }()
      case 3: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .r(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .r(v)
        }
      }()
      case 4: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .n(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .n(v)
        }
      }()
      case 5: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .d(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .d(v)
        }
      }()
      case 6: try {
        var v: CarServer_Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sna(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sna(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .invalid?: try {
      guard case .invalid(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .p?: try {
      guard case .p(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .r?: try {
      guard case .r(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .n?: try {
      guard case .n(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .d?: try {
      guard case .d(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .sna?: try {
      guard case .sna(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarServer_ShiftState, rhs: CarServer_ShiftState) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
