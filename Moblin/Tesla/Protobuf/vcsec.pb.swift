// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vcsec.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum VCSEC_SignatureType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case presentKey // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 2: self = .presentKey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .presentKey: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_SignatureType] = [
    .none,
    .presentKey,
  ]

}

enum VCSEC_KeyFormFactor: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case nfcCard // = 1
  case iosDevice // = 6
  case androidDevice // = 7
  case cloudKey // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .nfcCard
    case 6: self = .iosDevice
    case 7: self = .androidDevice
    case 9: self = .cloudKey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .nfcCard: return 1
    case .iosDevice: return 6
    case .androidDevice: return 7
    case .cloudKey: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_KeyFormFactor] = [
    .unknown,
    .nfcCard,
    .iosDevice,
    .androidDevice,
    .cloudKey,
  ]

}

enum VCSEC_InformationRequestType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case getStatus // = 0
  case getWhitelistInfo // = 5
  case getWhitelistEntryInfo // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .getStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .getStatus
    case 5: self = .getWhitelistInfo
    case 6: self = .getWhitelistEntryInfo
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .getStatus: return 0
    case .getWhitelistInfo: return 5
    case .getWhitelistEntryInfo: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_InformationRequestType] = [
    .getStatus,
    .getWhitelistInfo,
    .getWhitelistEntryInfo,
  ]

}

enum VCSEC_RKEAction_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case rkeActionUnlock // = 0
  case rkeActionLock // = 1
  case rkeActionRemoteDrive // = 20
  case rkeActionAutoSecureVehicle // = 29
  case rkeActionWakeVehicle // = 30
  case UNRECOGNIZED(Int)

  init() {
    self = .rkeActionUnlock
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rkeActionUnlock
    case 1: self = .rkeActionLock
    case 20: self = .rkeActionRemoteDrive
    case 29: self = .rkeActionAutoSecureVehicle
    case 30: self = .rkeActionWakeVehicle
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rkeActionUnlock: return 0
    case .rkeActionLock: return 1
    case .rkeActionRemoteDrive: return 20
    case .rkeActionAutoSecureVehicle: return 29
    case .rkeActionWakeVehicle: return 30
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_RKEAction_E] = [
    .rkeActionUnlock,
    .rkeActionLock,
    .rkeActionRemoteDrive,
    .rkeActionAutoSecureVehicle,
    .rkeActionWakeVehicle,
  ]

}

enum VCSEC_ClosureMoveType_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case closureMoveTypeNone // = 0
  case closureMoveTypeMove // = 1
  case closureMoveTypeStop // = 2
  case closureMoveTypeOpen // = 3
  case closureMoveTypeClose // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .closureMoveTypeNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .closureMoveTypeNone
    case 1: self = .closureMoveTypeMove
    case 2: self = .closureMoveTypeStop
    case 3: self = .closureMoveTypeOpen
    case 4: self = .closureMoveTypeClose
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .closureMoveTypeNone: return 0
    case .closureMoveTypeMove: return 1
    case .closureMoveTypeStop: return 2
    case .closureMoveTypeOpen: return 3
    case .closureMoveTypeClose: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_ClosureMoveType_E] = [
    .closureMoveTypeNone,
    .closureMoveTypeMove,
    .closureMoveTypeStop,
    .closureMoveTypeOpen,
    .closureMoveTypeClose,
  ]

}

enum VCSEC_OperationStatus_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case operationstatusOk // = 0
  case operationstatusWait // = 1
  case rror // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .operationstatusOk
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .operationstatusOk
    case 1: self = .operationstatusWait
    case 2: self = .rror
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .operationstatusOk: return 0
    case .operationstatusWait: return 1
    case .rror: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_OperationStatus_E] = [
    .operationstatusOk,
    .operationstatusWait,
    .rror,
  ]

}

enum VCSEC_SignedMessage_information_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case signedmessageInformationNone // = 0
  case signedmessageInformationFaultUnknown // = 1
  case signedmessageInformationFaultNotOnWhitelist // = 2
  case signedmessageInformationFaultIvSmallerThanExpected // = 3
  case signedmessageInformationFaultInvalidToken // = 4
  case signedmessageInformationFaultTokenAndCounterInvalid // = 5
  case signedmessageInformationFaultAesDecryptAuth // = 6
  case signedmessageInformationFaultEcdsaInput // = 7
  case signedmessageInformationFaultEcdsaSignature // = 8
  case signedmessageInformationFaultLocalEntityStart // = 9
  case signedmessageInformationFaultLocalEntityResult // = 10
  case signedmessageInformationFaultCouldNotRetrieveKey // = 11
  case signedmessageInformationFaultCouldNotRetrieveToken // = 12
  case signedmessageInformationFaultSignatureTooShort // = 13
  case signedmessageInformationFaultTokenIsIncorrectLength // = 14
  case signedmessageInformationFaultIncorrectEpoch // = 15
  case signedmessageInformationFaultIvIncorrectLength // = 16
  case signedmessageInformationFaultTimeExpired // = 17
  case signedmessageInformationFaultNotProvisionedWithIdentity // = 18
  case signedmessageInformationFaultCouldNotHashMetadata // = 19
  case UNRECOGNIZED(Int)

  init() {
    self = .signedmessageInformationNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .signedmessageInformationNone
    case 1: self = .signedmessageInformationFaultUnknown
    case 2: self = .signedmessageInformationFaultNotOnWhitelist
    case 3: self = .signedmessageInformationFaultIvSmallerThanExpected
    case 4: self = .signedmessageInformationFaultInvalidToken
    case 5: self = .signedmessageInformationFaultTokenAndCounterInvalid
    case 6: self = .signedmessageInformationFaultAesDecryptAuth
    case 7: self = .signedmessageInformationFaultEcdsaInput
    case 8: self = .signedmessageInformationFaultEcdsaSignature
    case 9: self = .signedmessageInformationFaultLocalEntityStart
    case 10: self = .signedmessageInformationFaultLocalEntityResult
    case 11: self = .signedmessageInformationFaultCouldNotRetrieveKey
    case 12: self = .signedmessageInformationFaultCouldNotRetrieveToken
    case 13: self = .signedmessageInformationFaultSignatureTooShort
    case 14: self = .signedmessageInformationFaultTokenIsIncorrectLength
    case 15: self = .signedmessageInformationFaultIncorrectEpoch
    case 16: self = .signedmessageInformationFaultIvIncorrectLength
    case 17: self = .signedmessageInformationFaultTimeExpired
    case 18: self = .signedmessageInformationFaultNotProvisionedWithIdentity
    case 19: self = .signedmessageInformationFaultCouldNotHashMetadata
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .signedmessageInformationNone: return 0
    case .signedmessageInformationFaultUnknown: return 1
    case .signedmessageInformationFaultNotOnWhitelist: return 2
    case .signedmessageInformationFaultIvSmallerThanExpected: return 3
    case .signedmessageInformationFaultInvalidToken: return 4
    case .signedmessageInformationFaultTokenAndCounterInvalid: return 5
    case .signedmessageInformationFaultAesDecryptAuth: return 6
    case .signedmessageInformationFaultEcdsaInput: return 7
    case .signedmessageInformationFaultEcdsaSignature: return 8
    case .signedmessageInformationFaultLocalEntityStart: return 9
    case .signedmessageInformationFaultLocalEntityResult: return 10
    case .signedmessageInformationFaultCouldNotRetrieveKey: return 11
    case .signedmessageInformationFaultCouldNotRetrieveToken: return 12
    case .signedmessageInformationFaultSignatureTooShort: return 13
    case .signedmessageInformationFaultTokenIsIncorrectLength: return 14
    case .signedmessageInformationFaultIncorrectEpoch: return 15
    case .signedmessageInformationFaultIvIncorrectLength: return 16
    case .signedmessageInformationFaultTimeExpired: return 17
    case .signedmessageInformationFaultNotProvisionedWithIdentity: return 18
    case .signedmessageInformationFaultCouldNotHashMetadata: return 19
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_SignedMessage_information_E] = [
    .signedmessageInformationNone,
    .signedmessageInformationFaultUnknown,
    .signedmessageInformationFaultNotOnWhitelist,
    .signedmessageInformationFaultIvSmallerThanExpected,
    .signedmessageInformationFaultInvalidToken,
    .signedmessageInformationFaultTokenAndCounterInvalid,
    .signedmessageInformationFaultAesDecryptAuth,
    .signedmessageInformationFaultEcdsaInput,
    .signedmessageInformationFaultEcdsaSignature,
    .signedmessageInformationFaultLocalEntityStart,
    .signedmessageInformationFaultLocalEntityResult,
    .signedmessageInformationFaultCouldNotRetrieveKey,
    .signedmessageInformationFaultCouldNotRetrieveToken,
    .signedmessageInformationFaultSignatureTooShort,
    .signedmessageInformationFaultTokenIsIncorrectLength,
    .signedmessageInformationFaultIncorrectEpoch,
    .signedmessageInformationFaultIvIncorrectLength,
    .signedmessageInformationFaultTimeExpired,
    .signedmessageInformationFaultNotProvisionedWithIdentity,
    .signedmessageInformationFaultCouldNotHashMetadata,
  ]

}

enum VCSEC_WhitelistOperation_information_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case whitelistoperationInformationNone // = 0
  case whitelistoperationInformationUndocumentedError // = 1
  case whitelistoperationInformationNoPermissionToRemoveOneself // = 2
  case whitelistoperationInformationKeyfobSlotsFull // = 3
  case whitelistoperationInformationWhitelistFull // = 4
  case whitelistoperationInformationNoPermissionToAdd // = 5
  case whitelistoperationInformationInvalidPublicKey // = 6
  case whitelistoperationInformationNoPermissionToRemove // = 7
  case whitelistoperationInformationNoPermissionToChangePermissions // = 8
  case whitelistoperationInformationAttemptingToElevateOtherAboveOneself // = 9
  case whitelistoperationInformationAttemptingToDemoteSuperiorToOneself // = 10
  case whitelistoperationInformationAttemptingToRemoveOwnPermissions // = 11
  case whitelistoperationInformationPublicKeyNotOnWhitelist // = 12
  case whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist // = 13
  case whitelistoperationInformationNotAllowedToAddUnlessOnReader // = 14
  case whitelistoperationInformationFmModifyingOutsideOfFMode // = 15
  case whitelistoperationInformationFmAttemptingToAddPermanentKey // = 16
  case whitelistoperationInformationFmAttemptingToRemovePermanentKey // = 17
  case whitelistoperationInformationKeychainWhileFsFull // = 18
  case whitelistoperationInformationAttemptingToAddKeyWithoutRole // = 19
  case whitelistoperationInformationAttemptingToAddKeyWithServiceRole // = 20
  case whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech // = 21
  case whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode // = 22
  case UNRECOGNIZED(Int)

  init() {
    self = .whitelistoperationInformationNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .whitelistoperationInformationNone
    case 1: self = .whitelistoperationInformationUndocumentedError
    case 2: self = .whitelistoperationInformationNoPermissionToRemoveOneself
    case 3: self = .whitelistoperationInformationKeyfobSlotsFull
    case 4: self = .whitelistoperationInformationWhitelistFull
    case 5: self = .whitelistoperationInformationNoPermissionToAdd
    case 6: self = .whitelistoperationInformationInvalidPublicKey
    case 7: self = .whitelistoperationInformationNoPermissionToRemove
    case 8: self = .whitelistoperationInformationNoPermissionToChangePermissions
    case 9: self = .whitelistoperationInformationAttemptingToElevateOtherAboveOneself
    case 10: self = .whitelistoperationInformationAttemptingToDemoteSuperiorToOneself
    case 11: self = .whitelistoperationInformationAttemptingToRemoveOwnPermissions
    case 12: self = .whitelistoperationInformationPublicKeyNotOnWhitelist
    case 13: self = .whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist
    case 14: self = .whitelistoperationInformationNotAllowedToAddUnlessOnReader
    case 15: self = .whitelistoperationInformationFmModifyingOutsideOfFMode
    case 16: self = .whitelistoperationInformationFmAttemptingToAddPermanentKey
    case 17: self = .whitelistoperationInformationFmAttemptingToRemovePermanentKey
    case 18: self = .whitelistoperationInformationKeychainWhileFsFull
    case 19: self = .whitelistoperationInformationAttemptingToAddKeyWithoutRole
    case 20: self = .whitelistoperationInformationAttemptingToAddKeyWithServiceRole
    case 21: self = .whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech
    case 22: self = .whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .whitelistoperationInformationNone: return 0
    case .whitelistoperationInformationUndocumentedError: return 1
    case .whitelistoperationInformationNoPermissionToRemoveOneself: return 2
    case .whitelistoperationInformationKeyfobSlotsFull: return 3
    case .whitelistoperationInformationWhitelistFull: return 4
    case .whitelistoperationInformationNoPermissionToAdd: return 5
    case .whitelistoperationInformationInvalidPublicKey: return 6
    case .whitelistoperationInformationNoPermissionToRemove: return 7
    case .whitelistoperationInformationNoPermissionToChangePermissions: return 8
    case .whitelistoperationInformationAttemptingToElevateOtherAboveOneself: return 9
    case .whitelistoperationInformationAttemptingToDemoteSuperiorToOneself: return 10
    case .whitelistoperationInformationAttemptingToRemoveOwnPermissions: return 11
    case .whitelistoperationInformationPublicKeyNotOnWhitelist: return 12
    case .whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist: return 13
    case .whitelistoperationInformationNotAllowedToAddUnlessOnReader: return 14
    case .whitelistoperationInformationFmModifyingOutsideOfFMode: return 15
    case .whitelistoperationInformationFmAttemptingToAddPermanentKey: return 16
    case .whitelistoperationInformationFmAttemptingToRemovePermanentKey: return 17
    case .whitelistoperationInformationKeychainWhileFsFull: return 18
    case .whitelistoperationInformationAttemptingToAddKeyWithoutRole: return 19
    case .whitelistoperationInformationAttemptingToAddKeyWithServiceRole: return 20
    case .whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech: return 21
    case .whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_WhitelistOperation_information_E] = [
    .whitelistoperationInformationNone,
    .whitelistoperationInformationUndocumentedError,
    .whitelistoperationInformationNoPermissionToRemoveOneself,
    .whitelistoperationInformationKeyfobSlotsFull,
    .whitelistoperationInformationWhitelistFull,
    .whitelistoperationInformationNoPermissionToAdd,
    .whitelistoperationInformationInvalidPublicKey,
    .whitelistoperationInformationNoPermissionToRemove,
    .whitelistoperationInformationNoPermissionToChangePermissions,
    .whitelistoperationInformationAttemptingToElevateOtherAboveOneself,
    .whitelistoperationInformationAttemptingToDemoteSuperiorToOneself,
    .whitelistoperationInformationAttemptingToRemoveOwnPermissions,
    .whitelistoperationInformationPublicKeyNotOnWhitelist,
    .whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist,
    .whitelistoperationInformationNotAllowedToAddUnlessOnReader,
    .whitelistoperationInformationFmModifyingOutsideOfFMode,
    .whitelistoperationInformationFmAttemptingToAddPermanentKey,
    .whitelistoperationInformationFmAttemptingToRemovePermanentKey,
    .whitelistoperationInformationKeychainWhileFsFull,
    .whitelistoperationInformationAttemptingToAddKeyWithoutRole,
    .whitelistoperationInformationAttemptingToAddKeyWithServiceRole,
    .whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech,
    .whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode,
  ]

}

enum VCSEC_ClosureState_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case closurestateClosed // = 0
  case closurestateOpen // = 1
  case closurestateAjar // = 2
  case closurestateUnknown // = 3
  case closurestateFailedUnlatch // = 4
  case closurestateOpening // = 5
  case closurestateClosing // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .closurestateClosed
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .closurestateClosed
    case 1: self = .closurestateOpen
    case 2: self = .closurestateAjar
    case 3: self = .closurestateUnknown
    case 4: self = .closurestateFailedUnlatch
    case 5: self = .closurestateOpening
    case 6: self = .closurestateClosing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .closurestateClosed: return 0
    case .closurestateOpen: return 1
    case .closurestateAjar: return 2
    case .closurestateUnknown: return 3
    case .closurestateFailedUnlatch: return 4
    case .closurestateOpening: return 5
    case .closurestateClosing: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_ClosureState_E] = [
    .closurestateClosed,
    .closurestateOpen,
    .closurestateAjar,
    .closurestateUnknown,
    .closurestateFailedUnlatch,
    .closurestateOpening,
    .closurestateClosing,
  ]

}

enum VCSEC_VehicleLockState_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case vehiclelockstateUnlocked // = 0
  case vehiclelockstateLocked // = 1
  case vehiclelockstateInternalLocked // = 2
  case vehiclelockstateSelectiveUnlocked // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .vehiclelockstateUnlocked
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .vehiclelockstateUnlocked
    case 1: self = .vehiclelockstateLocked
    case 2: self = .vehiclelockstateInternalLocked
    case 3: self = .vehiclelockstateSelectiveUnlocked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .vehiclelockstateUnlocked: return 0
    case .vehiclelockstateLocked: return 1
    case .vehiclelockstateInternalLocked: return 2
    case .vehiclelockstateSelectiveUnlocked: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_VehicleLockState_E] = [
    .vehiclelockstateUnlocked,
    .vehiclelockstateLocked,
    .vehiclelockstateInternalLocked,
    .vehiclelockstateSelectiveUnlocked,
  ]

}

enum VCSEC_VehicleSleepStatus_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case vehicleSleepStatusUnknown // = 0
  case vehicleSleepStatusAwake // = 1
  case vehicleSleepStatusAsleep // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .vehicleSleepStatusUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .vehicleSleepStatusUnknown
    case 1: self = .vehicleSleepStatusAwake
    case 2: self = .vehicleSleepStatusAsleep
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .vehicleSleepStatusUnknown: return 0
    case .vehicleSleepStatusAwake: return 1
    case .vehicleSleepStatusAsleep: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_VehicleSleepStatus_E] = [
    .vehicleSleepStatusUnknown,
    .vehicleSleepStatusAwake,
    .vehicleSleepStatusAsleep,
  ]

}

enum VCSEC_UserPresence_E: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case vehicleUserPresenceUnknown // = 0
  case vehicleUserPresenceNotPresent // = 1
  case vehicleUserPresencePresent // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .vehicleUserPresenceUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .vehicleUserPresenceUnknown
    case 1: self = .vehicleUserPresenceNotPresent
    case 2: self = .vehicleUserPresencePresent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .vehicleUserPresenceUnknown: return 0
    case .vehicleUserPresenceNotPresent: return 1
    case .vehicleUserPresencePresent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_UserPresence_E] = [
    .vehicleUserPresenceUnknown,
    .vehicleUserPresenceNotPresent,
    .vehicleUserPresencePresent,
  ]

}

struct VCSEC_SignedMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var protobufMessageAsBytes: Data = Data()

  var signatureType: VCSEC_SignatureType = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_ToVCSECMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signedMessage: VCSEC_SignedMessage {
    get {return _signedMessage ?? VCSEC_SignedMessage()}
    set {_signedMessage = newValue}
  }
  /// Returns true if `signedMessage` has been explicitly set.
  var hasSignedMessage: Bool {return self._signedMessage != nil}
  /// Clears the value of `signedMessage`. Subsequent reads from it will return its default value.
  mutating func clearSignedMessage() {self._signedMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signedMessage: VCSEC_SignedMessage? = nil
}

struct VCSEC_KeyIdentifier: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKeySha1: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_KeyMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyFormFactor: VCSEC_KeyFormFactor = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_PublicKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKeyRaw: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_WhitelistInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numberOfEntries: UInt32 = 0

  var whitelistEntries: [VCSEC_KeyIdentifier] = []

  var slotMask: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_WhitelistEntryInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyID: VCSEC_KeyIdentifier {
    get {return _keyID ?? VCSEC_KeyIdentifier()}
    set {_keyID = newValue}
  }
  /// Returns true if `keyID` has been explicitly set.
  var hasKeyID: Bool {return self._keyID != nil}
  /// Clears the value of `keyID`. Subsequent reads from it will return its default value.
  mutating func clearKeyID() {self._keyID = nil}

  var publicKey: VCSEC_PublicKey {
    get {return _publicKey ?? VCSEC_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var metadataForKey: VCSEC_KeyMetadata {
    get {return _metadataForKey ?? VCSEC_KeyMetadata()}
    set {_metadataForKey = newValue}
  }
  /// Returns true if `metadataForKey` has been explicitly set.
  var hasMetadataForKey: Bool {return self._metadataForKey != nil}
  /// Clears the value of `metadataForKey`. Subsequent reads from it will return its default value.
  mutating func clearMetadataForKey() {self._metadataForKey = nil}

  var slot: UInt32 = 0

  var keyRole: Keys_Role = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyID: VCSEC_KeyIdentifier? = nil
  fileprivate var _publicKey: VCSEC_PublicKey? = nil
  fileprivate var _metadataForKey: VCSEC_KeyMetadata? = nil
}

struct VCSEC_InformationRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var informationRequestType: VCSEC_InformationRequestType = .getStatus

  var key: VCSEC_InformationRequest.OneOf_Key? = nil

  var keyID: VCSEC_KeyIdentifier {
    get {
      if case .keyID(let v)? = key {return v}
      return VCSEC_KeyIdentifier()
    }
    set {key = .keyID(newValue)}
  }

  var publicKey: Data {
    get {
      if case .publicKey(let v)? = key {return v}
      return Data()
    }
    set {key = .publicKey(newValue)}
  }

  var slot: UInt32 {
    get {
      if case .slot(let v)? = key {return v}
      return 0
    }
    set {key = .slot(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Key: Equatable, @unchecked Sendable {
    case keyID(VCSEC_KeyIdentifier)
    case publicKey(Data)
    case slot(UInt32)

  }

  init() {}
}

struct VCSEC_ClosureMoveRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frontDriverDoor: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var frontPassengerDoor: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var rearDriverDoor: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var rearPassengerDoor: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var rearTrunk: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var frontTrunk: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var chargePort: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var tonneau: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_PermissionChange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: VCSEC_PublicKey {
    get {return _key ?? VCSEC_PublicKey()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var secondsToBeActive: UInt32 = 0

  var keyRole: Keys_Role = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: VCSEC_PublicKey? = nil
}

struct VCSEC_ReplaceKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyToReplace: VCSEC_ReplaceKey.OneOf_KeyToReplace? = nil

  var publicKeyToReplace: VCSEC_PublicKey {
    get {
      if case .publicKeyToReplace(let v)? = keyToReplace {return v}
      return VCSEC_PublicKey()
    }
    set {keyToReplace = .publicKeyToReplace(newValue)}
  }

  var slotToReplace: UInt32 {
    get {
      if case .slotToReplace(let v)? = keyToReplace {return v}
      return 0
    }
    set {keyToReplace = .slotToReplace(newValue)}
  }

  var keyToAdd: VCSEC_PublicKey {
    get {return _keyToAdd ?? VCSEC_PublicKey()}
    set {_keyToAdd = newValue}
  }
  /// Returns true if `keyToAdd` has been explicitly set.
  var hasKeyToAdd: Bool {return self._keyToAdd != nil}
  /// Clears the value of `keyToAdd`. Subsequent reads from it will return its default value.
  mutating func clearKeyToAdd() {self._keyToAdd = nil}

  var keyRole: Keys_Role = .none

  var impermanent: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_KeyToReplace: Equatable, Sendable {
    case publicKeyToReplace(VCSEC_PublicKey)
    case slotToReplace(UInt32)

  }

  init() {}

  fileprivate var _keyToAdd: VCSEC_PublicKey? = nil
}

struct VCSEC_WhitelistOperation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_WhitelistOperation.OneOf_SubMessage? = nil

  var addPublicKeyToWhitelist: VCSEC_PublicKey {
    get {
      if case .addPublicKeyToWhitelist(let v)? = subMessage {return v}
      return VCSEC_PublicKey()
    }
    set {subMessage = .addPublicKeyToWhitelist(newValue)}
  }

  var removePublicKeyFromWhitelist: VCSEC_PublicKey {
    get {
      if case .removePublicKeyFromWhitelist(let v)? = subMessage {return v}
      return VCSEC_PublicKey()
    }
    set {subMessage = .removePublicKeyFromWhitelist(newValue)}
  }

  var addPermissionsToPublicKey: VCSEC_PermissionChange {
    get {
      if case .addPermissionsToPublicKey(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .addPermissionsToPublicKey(newValue)}
  }

  var removePermissionsFromPublicKey: VCSEC_PermissionChange {
    get {
      if case .removePermissionsFromPublicKey(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .removePermissionsFromPublicKey(newValue)}
  }

  var addKeyToWhitelistAndAddPermissions: VCSEC_PermissionChange {
    get {
      if case .addKeyToWhitelistAndAddPermissions(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .addKeyToWhitelistAndAddPermissions(newValue)}
  }

  var updateKeyAndPermissions: VCSEC_PermissionChange {
    get {
      if case .updateKeyAndPermissions(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .updateKeyAndPermissions(newValue)}
  }

  var addImpermanentKey: VCSEC_PermissionChange {
    get {
      if case .addImpermanentKey(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .addImpermanentKey(newValue)}
  }

  var addImpermanentKeyAndRemoveExisting: VCSEC_PermissionChange {
    get {
      if case .addImpermanentKeyAndRemoveExisting(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .addImpermanentKeyAndRemoveExisting(newValue)}
  }

  var removeAllImpermanentKeys: Bool {
    get {
      if case .removeAllImpermanentKeys(let v)? = subMessage {return v}
      return false
    }
    set {subMessage = .removeAllImpermanentKeys(newValue)}
  }

  var replaceKey: VCSEC_ReplaceKey {
    get {
      if case .replaceKey(let v)? = subMessage {return v}
      return VCSEC_ReplaceKey()
    }
    set {subMessage = .replaceKey(newValue)}
  }

  var metadataForKey: VCSEC_KeyMetadata {
    get {return _metadataForKey ?? VCSEC_KeyMetadata()}
    set {_metadataForKey = newValue}
  }
  /// Returns true if `metadataForKey` has been explicitly set.
  var hasMetadataForKey: Bool {return self._metadataForKey != nil}
  /// Clears the value of `metadataForKey`. Subsequent reads from it will return its default value.
  mutating func clearMetadataForKey() {self._metadataForKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable, Sendable {
    case addPublicKeyToWhitelist(VCSEC_PublicKey)
    case removePublicKeyFromWhitelist(VCSEC_PublicKey)
    case addPermissionsToPublicKey(VCSEC_PermissionChange)
    case removePermissionsFromPublicKey(VCSEC_PermissionChange)
    case addKeyToWhitelistAndAddPermissions(VCSEC_PermissionChange)
    case updateKeyAndPermissions(VCSEC_PermissionChange)
    case addImpermanentKey(VCSEC_PermissionChange)
    case addImpermanentKeyAndRemoveExisting(VCSEC_PermissionChange)
    case removeAllImpermanentKeys(Bool)
    case replaceKey(VCSEC_ReplaceKey)

  }

  init() {}

  fileprivate var _metadataForKey: VCSEC_KeyMetadata? = nil
}

struct VCSEC_WhitelistOperation_status: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var whitelistOperationInformation: VCSEC_WhitelistOperation_information_E = .whitelistoperationInformationNone

  var signerOfOperation: VCSEC_KeyIdentifier {
    get {return _signerOfOperation ?? VCSEC_KeyIdentifier()}
    set {_signerOfOperation = newValue}
  }
  /// Returns true if `signerOfOperation` has been explicitly set.
  var hasSignerOfOperation: Bool {return self._signerOfOperation != nil}
  /// Clears the value of `signerOfOperation`. Subsequent reads from it will return its default value.
  mutating func clearSignerOfOperation() {self._signerOfOperation = nil}

  var operationStatus: VCSEC_OperationStatus_E = .operationstatusOk

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signerOfOperation: VCSEC_KeyIdentifier? = nil
}

struct VCSEC_SignedMessage_status: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var counter: UInt32 = 0

  var signedMessageInformation: VCSEC_SignedMessage_information_E = .signedmessageInformationNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_CommandStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operationStatus: VCSEC_OperationStatus_E = .operationstatusOk

  var subMessage: VCSEC_CommandStatus.OneOf_SubMessage? = nil

  var signedMessageStatus: VCSEC_SignedMessage_status {
    get {
      if case .signedMessageStatus(let v)? = subMessage {return v}
      return VCSEC_SignedMessage_status()
    }
    set {subMessage = .signedMessageStatus(newValue)}
  }

  var whitelistOperationStatus: VCSEC_WhitelistOperation_status {
    get {
      if case .whitelistOperationStatus(let v)? = subMessage {return v}
      return VCSEC_WhitelistOperation_status()
    }
    set {subMessage = .whitelistOperationStatus(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable, Sendable {
    case signedMessageStatus(VCSEC_SignedMessage_status)
    case whitelistOperationStatus(VCSEC_WhitelistOperation_status)

  }

  init() {}
}

struct VCSEC_UnsignedMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_UnsignedMessage.OneOf_SubMessage? = nil

  var informationRequest: VCSEC_InformationRequest {
    get {
      if case .informationRequest(let v)? = subMessage {return v}
      return VCSEC_InformationRequest()
    }
    set {subMessage = .informationRequest(newValue)}
  }

  var rkeaction: VCSEC_RKEAction_E {
    get {
      if case .rkeaction(let v)? = subMessage {return v}
      return .rkeActionUnlock
    }
    set {subMessage = .rkeaction(newValue)}
  }

  var closureMoveRequest: VCSEC_ClosureMoveRequest {
    get {
      if case .closureMoveRequest(let v)? = subMessage {return v}
      return VCSEC_ClosureMoveRequest()
    }
    set {subMessage = .closureMoveRequest(newValue)}
  }

  var whitelistOperation: VCSEC_WhitelistOperation {
    get {
      if case .whitelistOperation(let v)? = subMessage {return v}
      return VCSEC_WhitelistOperation()
    }
    set {subMessage = .whitelistOperation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable, Sendable {
    case informationRequest(VCSEC_InformationRequest)
    case rkeaction(VCSEC_RKEAction_E)
    case closureMoveRequest(VCSEC_ClosureMoveRequest)
    case whitelistOperation(VCSEC_WhitelistOperation)

  }

  init() {}
}

struct VCSEC_ClosureStatuses: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frontDriverDoor: VCSEC_ClosureState_E = .closurestateClosed

  var frontPassengerDoor: VCSEC_ClosureState_E = .closurestateClosed

  var rearDriverDoor: VCSEC_ClosureState_E = .closurestateClosed

  var rearPassengerDoor: VCSEC_ClosureState_E = .closurestateClosed

  var rearTrunk: VCSEC_ClosureState_E = .closurestateClosed

  var frontTrunk: VCSEC_ClosureState_E = .closurestateClosed

  var chargePort: VCSEC_ClosureState_E = .closurestateClosed

  var tonneau: VCSEC_ClosureState_E = .closurestateClosed

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_DetailedClosureStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tonneauPercentOpen: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_VehicleStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closureStatuses: VCSEC_ClosureStatuses {
    get {return _closureStatuses ?? VCSEC_ClosureStatuses()}
    set {_closureStatuses = newValue}
  }
  /// Returns true if `closureStatuses` has been explicitly set.
  var hasClosureStatuses: Bool {return self._closureStatuses != nil}
  /// Clears the value of `closureStatuses`. Subsequent reads from it will return its default value.
  mutating func clearClosureStatuses() {self._closureStatuses = nil}

  var vehicleLockState: VCSEC_VehicleLockState_E = .vehiclelockstateUnlocked

  var vehicleSleepStatus: VCSEC_VehicleSleepStatus_E = .vehicleSleepStatusUnknown

  var userPresence: VCSEC_UserPresence_E = .vehicleUserPresenceUnknown

  var detailedClosureStatus: VCSEC_DetailedClosureStatus {
    get {return _detailedClosureStatus ?? VCSEC_DetailedClosureStatus()}
    set {_detailedClosureStatus = newValue}
  }
  /// Returns true if `detailedClosureStatus` has been explicitly set.
  var hasDetailedClosureStatus: Bool {return self._detailedClosureStatus != nil}
  /// Clears the value of `detailedClosureStatus`. Subsequent reads from it will return its default value.
  mutating func clearDetailedClosureStatus() {self._detailedClosureStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _closureStatuses: VCSEC_ClosureStatuses? = nil
  fileprivate var _detailedClosureStatus: VCSEC_DetailedClosureStatus? = nil
}

struct VCSEC_FromVCSECMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_FromVCSECMessage.OneOf_SubMessage? = nil

  var vehicleStatus: VCSEC_VehicleStatus {
    get {
      if case .vehicleStatus(let v)? = subMessage {return v}
      return VCSEC_VehicleStatus()
    }
    set {subMessage = .vehicleStatus(newValue)}
  }

  var commandStatus: VCSEC_CommandStatus {
    get {
      if case .commandStatus(let v)? = subMessage {return v}
      return VCSEC_CommandStatus()
    }
    set {subMessage = .commandStatus(newValue)}
  }

  var whitelistInfo: VCSEC_WhitelistInfo {
    get {
      if case .whitelistInfo(let v)? = subMessage {return v}
      return VCSEC_WhitelistInfo()
    }
    set {subMessage = .whitelistInfo(newValue)}
  }

  var whitelistEntryInfo: VCSEC_WhitelistEntryInfo {
    get {
      if case .whitelistEntryInfo(let v)? = subMessage {return v}
      return VCSEC_WhitelistEntryInfo()
    }
    set {subMessage = .whitelistEntryInfo(newValue)}
  }

  var nominalError: Errors_NominalError {
    get {
      if case .nominalError(let v)? = subMessage {return v}
      return Errors_NominalError()
    }
    set {subMessage = .nominalError(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable, Sendable {
    case vehicleStatus(VCSEC_VehicleStatus)
    case commandStatus(VCSEC_CommandStatus)
    case whitelistInfo(VCSEC_WhitelistInfo)
    case whitelistEntryInfo(VCSEC_WhitelistEntryInfo)
    case nominalError(Errors_NominalError)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "VCSEC"

extension VCSEC_SignatureType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNATURE_TYPE_NONE"),
    2: .same(proto: "SIGNATURE_TYPE_PRESENT_KEY"),
  ]
}

extension VCSEC_KeyFormFactor: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_FORM_FACTOR_UNKNOWN"),
    1: .same(proto: "KEY_FORM_FACTOR_NFC_CARD"),
    6: .same(proto: "KEY_FORM_FACTOR_IOS_DEVICE"),
    7: .same(proto: "KEY_FORM_FACTOR_ANDROID_DEVICE"),
    9: .same(proto: "KEY_FORM_FACTOR_CLOUD_KEY"),
  ]
}

extension VCSEC_InformationRequestType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFORMATION_REQUEST_TYPE_GET_STATUS"),
    5: .same(proto: "INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO"),
    6: .same(proto: "INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO"),
  ]
}

extension VCSEC_RKEAction_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RKE_ACTION_UNLOCK"),
    1: .same(proto: "RKE_ACTION_LOCK"),
    20: .same(proto: "RKE_ACTION_REMOTE_DRIVE"),
    29: .same(proto: "RKE_ACTION_AUTO_SECURE_VEHICLE"),
    30: .same(proto: "RKE_ACTION_WAKE_VEHICLE"),
  ]
}

extension VCSEC_ClosureMoveType_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOSURE_MOVE_TYPE_NONE"),
    1: .same(proto: "CLOSURE_MOVE_TYPE_MOVE"),
    2: .same(proto: "CLOSURE_MOVE_TYPE_STOP"),
    3: .same(proto: "CLOSURE_MOVE_TYPE_OPEN"),
    4: .same(proto: "CLOSURE_MOVE_TYPE_CLOSE"),
  ]
}

extension VCSEC_OperationStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATIONSTATUS_OK"),
    1: .same(proto: "OPERATIONSTATUS_WAIT"),
    2: .same(proto: "OPERATIONSTATUS_ERROR"),
  ]
}

extension VCSEC_SignedMessage_information_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNEDMESSAGE_INFORMATION_NONE"),
    1: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN"),
    2: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST"),
    3: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED"),
    4: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN"),
    5: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID"),
    6: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH"),
    7: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT"),
    8: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE"),
    9: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START"),
    10: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT"),
    11: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY"),
    12: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN"),
    13: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT"),
    14: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH"),
    15: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH"),
    16: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH"),
    17: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED"),
    18: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY"),
    19: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA"),
  ]
}

extension VCSEC_WhitelistOperation_information_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHITELISTOPERATION_INFORMATION_NONE"),
    1: .same(proto: "WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR"),
    2: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF"),
    3: .same(proto: "WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL"),
    4: .same(proto: "WHITELISTOPERATION_INFORMATION_WHITELIST_FULL"),
    5: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD"),
    6: .same(proto: "WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY"),
    7: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE"),
    8: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS"),
    9: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF"),
    10: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF"),
    11: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS"),
    12: .same(proto: "WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST"),
    13: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST"),
    14: .same(proto: "WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER"),
    15: .same(proto: "WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE"),
    16: .same(proto: "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY"),
    17: .same(proto: "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY"),
    18: .same(proto: "WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL"),
    19: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE"),
    20: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE"),
    21: .same(proto: "WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH"),
    22: .same(proto: "WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE"),
  ]
}

extension VCSEC_ClosureState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOSURESTATE_CLOSED"),
    1: .same(proto: "CLOSURESTATE_OPEN"),
    2: .same(proto: "CLOSURESTATE_AJAR"),
    3: .same(proto: "CLOSURESTATE_UNKNOWN"),
    4: .same(proto: "CLOSURESTATE_FAILED_UNLATCH"),
    5: .same(proto: "CLOSURESTATE_OPENING"),
    6: .same(proto: "CLOSURESTATE_CLOSING"),
  ]
}

extension VCSEC_VehicleLockState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VEHICLELOCKSTATE_UNLOCKED"),
    1: .same(proto: "VEHICLELOCKSTATE_LOCKED"),
    2: .same(proto: "VEHICLELOCKSTATE_INTERNAL_LOCKED"),
    3: .same(proto: "VEHICLELOCKSTATE_SELECTIVE_UNLOCKED"),
  ]
}

extension VCSEC_VehicleSleepStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VEHICLE_SLEEP_STATUS_UNKNOWN"),
    1: .same(proto: "VEHICLE_SLEEP_STATUS_AWAKE"),
    2: .same(proto: "VEHICLE_SLEEP_STATUS_ASLEEP"),
  ]
}

extension VCSEC_UserPresence_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VEHICLE_USER_PRESENCE_UNKNOWN"),
    1: .same(proto: "VEHICLE_USER_PRESENCE_NOT_PRESENT"),
    2: .same(proto: "VEHICLE_USER_PRESENCE_PRESENT"),
  ]
}

extension VCSEC_SignedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "protobufMessageAsBytes"),
    3: .same(proto: "signatureType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.protobufMessageAsBytes) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.signatureType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.protobufMessageAsBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.protobufMessageAsBytes, fieldNumber: 2)
    }
    if self.signatureType != .none {
      try visitor.visitSingularEnumField(value: self.signatureType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_SignedMessage, rhs: VCSEC_SignedMessage) -> Bool {
    if lhs.protobufMessageAsBytes != rhs.protobufMessageAsBytes {return false}
    if lhs.signatureType != rhs.signatureType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ToVCSECMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ToVCSECMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signedMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signedMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signedMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ToVCSECMessage, rhs: VCSEC_ToVCSECMessage) -> Bool {
    if lhs._signedMessage != rhs._signedMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_KeyIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKeySHA1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKeySha1) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeySha1.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeySha1, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_KeyIdentifier, rhs: VCSEC_KeyIdentifier) -> Bool {
    if lhs.publicKeySha1 != rhs.publicKeySha1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_KeyMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyFormFactor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.keyFormFactor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFormFactor != .unknown {
      try visitor.visitSingularEnumField(value: self.keyFormFactor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_KeyMetadata, rhs: VCSEC_KeyMetadata) -> Bool {
    if lhs.keyFormFactor != rhs.keyFormFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PublicKeyRaw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKeyRaw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeyRaw.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeyRaw, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_PublicKey, rhs: VCSEC_PublicKey) -> Bool {
    if lhs.publicKeyRaw != rhs.publicKeyRaw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_WhitelistInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WhitelistInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numberOfEntries"),
    2: .same(proto: "whitelistEntries"),
    3: .same(proto: "slotMask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numberOfEntries) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.whitelistEntries) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.slotMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numberOfEntries != 0 {
      try visitor.visitSingularUInt32Field(value: self.numberOfEntries, fieldNumber: 1)
    }
    if !self.whitelistEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.whitelistEntries, fieldNumber: 2)
    }
    if self.slotMask != 0 {
      try visitor.visitSingularUInt32Field(value: self.slotMask, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_WhitelistInfo, rhs: VCSEC_WhitelistInfo) -> Bool {
    if lhs.numberOfEntries != rhs.numberOfEntries {return false}
    if lhs.whitelistEntries != rhs.whitelistEntries {return false}
    if lhs.slotMask != rhs.slotMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_WhitelistEntryInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WhitelistEntryInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyId"),
    2: .same(proto: "publicKey"),
    4: .same(proto: "metadataForKey"),
    6: .same(proto: "slot"),
    7: .same(proto: "keyRole"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadataForKey) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.slot) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._metadataForKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.slot != 0 {
      try visitor.visitSingularUInt32Field(value: self.slot, fieldNumber: 6)
    }
    if self.keyRole != .none {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_WhitelistEntryInfo, rhs: VCSEC_WhitelistEntryInfo) -> Bool {
    if lhs._keyID != rhs._keyID {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._metadataForKey != rhs._metadataForKey {return false}
    if lhs.slot != rhs.slot {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_InformationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InformationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "informationRequestType"),
    2: .same(proto: "keyId"),
    3: .same(proto: "publicKey"),
    4: .same(proto: "slot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.informationRequestType) }()
      case 2: try {
        var v: VCSEC_KeyIdentifier?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .keyID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .keyID(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .publicKey(v)
        }
      }()
      case 4: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .slot(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.informationRequestType != .getStatus {
      try visitor.visitSingularEnumField(value: self.informationRequestType, fieldNumber: 1)
    }
    switch self.key {
    case .keyID?: try {
      guard case .keyID(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .publicKey?: try {
      guard case .publicKey(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .slot?: try {
      guard case .slot(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_InformationRequest, rhs: VCSEC_InformationRequest) -> Bool {
    if lhs.informationRequestType != rhs.informationRequestType {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ClosureMoveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosureMoveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frontDriverDoor"),
    2: .same(proto: "frontPassengerDoor"),
    3: .same(proto: "rearDriverDoor"),
    4: .same(proto: "rearPassengerDoor"),
    5: .same(proto: "rearTrunk"),
    6: .same(proto: "frontTrunk"),
    7: .same(proto: "chargePort"),
    8: .same(proto: "tonneau"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.frontDriverDoor) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.frontPassengerDoor) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rearDriverDoor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rearPassengerDoor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.rearTrunk) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.frontTrunk) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.chargePort) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.tonneau) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frontDriverDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.frontDriverDoor, fieldNumber: 1)
    }
    if self.frontPassengerDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.frontPassengerDoor, fieldNumber: 2)
    }
    if self.rearDriverDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.rearDriverDoor, fieldNumber: 3)
    }
    if self.rearPassengerDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.rearPassengerDoor, fieldNumber: 4)
    }
    if self.rearTrunk != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.rearTrunk, fieldNumber: 5)
    }
    if self.frontTrunk != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.frontTrunk, fieldNumber: 6)
    }
    if self.chargePort != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.chargePort, fieldNumber: 7)
    }
    if self.tonneau != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.tonneau, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ClosureMoveRequest, rhs: VCSEC_ClosureMoveRequest) -> Bool {
    if lhs.frontDriverDoor != rhs.frontDriverDoor {return false}
    if lhs.frontPassengerDoor != rhs.frontPassengerDoor {return false}
    if lhs.rearDriverDoor != rhs.rearDriverDoor {return false}
    if lhs.rearPassengerDoor != rhs.rearPassengerDoor {return false}
    if lhs.rearTrunk != rhs.rearTrunk {return false}
    if lhs.frontTrunk != rhs.frontTrunk {return false}
    if lhs.chargePort != rhs.chargePort {return false}
    if lhs.tonneau != rhs.tonneau {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_PermissionChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PermissionChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    3: .same(proto: "secondsToBeActive"),
    4: .same(proto: "keyRole"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.secondsToBeActive) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.secondsToBeActive != 0 {
      try visitor.visitSingularUInt32Field(value: self.secondsToBeActive, fieldNumber: 3)
    }
    if self.keyRole != .none {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_PermissionChange, rhs: VCSEC_PermissionChange) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.secondsToBeActive != rhs.secondsToBeActive {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ReplaceKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplaceKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKeyToReplace"),
    2: .same(proto: "slotToReplace"),
    3: .same(proto: "keyToAdd"),
    4: .same(proto: "keyRole"),
    5: .same(proto: "impermanent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_PublicKey?
        var hadOneofValue = false
        if let current = self.keyToReplace {
          hadOneofValue = true
          if case .publicKeyToReplace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.keyToReplace = .publicKeyToReplace(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.keyToReplace != nil {try decoder.handleConflictingOneOf()}
          self.keyToReplace = .slotToReplace(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._keyToAdd) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.impermanent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.keyToReplace {
    case .publicKeyToReplace?: try {
      guard case .publicKeyToReplace(let v)? = self.keyToReplace else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .slotToReplace?: try {
      guard case .slotToReplace(let v)? = self.keyToReplace else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._keyToAdd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.keyRole != .none {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 4)
    }
    if self.impermanent != false {
      try visitor.visitSingularBoolField(value: self.impermanent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ReplaceKey, rhs: VCSEC_ReplaceKey) -> Bool {
    if lhs.keyToReplace != rhs.keyToReplace {return false}
    if lhs._keyToAdd != rhs._keyToAdd {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.impermanent != rhs.impermanent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_WhitelistOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WhitelistOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addPublicKeyToWhitelist"),
    2: .same(proto: "removePublicKeyFromWhitelist"),
    3: .same(proto: "addPermissionsToPublicKey"),
    4: .same(proto: "removePermissionsFromPublicKey"),
    5: .same(proto: "addKeyToWhitelistAndAddPermissions"),
    7: .same(proto: "updateKeyAndPermissions"),
    8: .same(proto: "addImpermanentKey"),
    9: .same(proto: "addImpermanentKeyAndRemoveExisting"),
    16: .same(proto: "removeAllImpermanentKeys"),
    17: .same(proto: "replaceKey"),
    6: .same(proto: "metadataForKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_PublicKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addPublicKeyToWhitelist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addPublicKeyToWhitelist(v)
        }
      }()
      case 2: try {
        var v: VCSEC_PublicKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .removePublicKeyFromWhitelist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .removePublicKeyFromWhitelist(v)
        }
      }()
      case 3: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addPermissionsToPublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addPermissionsToPublicKey(v)
        }
      }()
      case 4: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .removePermissionsFromPublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .removePermissionsFromPublicKey(v)
        }
      }()
      case 5: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addKeyToWhitelistAndAddPermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addKeyToWhitelistAndAddPermissions(v)
        }
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._metadataForKey) }()
      case 7: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .updateKeyAndPermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .updateKeyAndPermissions(v)
        }
      }()
      case 8: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addImpermanentKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addImpermanentKey(v)
        }
      }()
      case 9: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addImpermanentKeyAndRemoveExisting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addImpermanentKeyAndRemoveExisting(v)
        }
      }()
      case 16: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .removeAllImpermanentKeys(v)
        }
      }()
      case 17: try {
        var v: VCSEC_ReplaceKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .replaceKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .replaceKey(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .addPublicKeyToWhitelist?: try {
      guard case .addPublicKeyToWhitelist(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .removePublicKeyFromWhitelist?: try {
      guard case .removePublicKeyFromWhitelist(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .addPermissionsToPublicKey?: try {
      guard case .addPermissionsToPublicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .removePermissionsFromPublicKey?: try {
      guard case .removePermissionsFromPublicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .addKeyToWhitelistAndAddPermissions?: try {
      guard case .addKeyToWhitelistAndAddPermissions(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    try { if let v = self._metadataForKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    switch self.subMessage {
    case .updateKeyAndPermissions?: try {
      guard case .updateKeyAndPermissions(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .addImpermanentKey?: try {
      guard case .addImpermanentKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .addImpermanentKeyAndRemoveExisting?: try {
      guard case .addImpermanentKeyAndRemoveExisting(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .removeAllImpermanentKeys?: try {
      guard case .removeAllImpermanentKeys(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
    }()
    case .replaceKey?: try {
      guard case .replaceKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_WhitelistOperation, rhs: VCSEC_WhitelistOperation) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs._metadataForKey != rhs._metadataForKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_WhitelistOperation_status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WhitelistOperation_status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "whitelistOperationInformation"),
    2: .same(proto: "signerOfOperation"),
    3: .same(proto: "operationStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.whitelistOperationInformation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signerOfOperation) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.operationStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.whitelistOperationInformation != .whitelistoperationInformationNone {
      try visitor.visitSingularEnumField(value: self.whitelistOperationInformation, fieldNumber: 1)
    }
    try { if let v = self._signerOfOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.operationStatus != .operationstatusOk {
      try visitor.visitSingularEnumField(value: self.operationStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_WhitelistOperation_status, rhs: VCSEC_WhitelistOperation_status) -> Bool {
    if lhs.whitelistOperationInformation != rhs.whitelistOperationInformation {return false}
    if lhs._signerOfOperation != rhs._signerOfOperation {return false}
    if lhs.operationStatus != rhs.operationStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_SignedMessage_status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedMessage_status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counter"),
    2: .same(proto: "signedMessageInformation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.signedMessageInformation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 1)
    }
    if self.signedMessageInformation != .signedmessageInformationNone {
      try visitor.visitSingularEnumField(value: self.signedMessageInformation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_SignedMessage_status, rhs: VCSEC_SignedMessage_status) -> Bool {
    if lhs.counter != rhs.counter {return false}
    if lhs.signedMessageInformation != rhs.signedMessageInformation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_CommandStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operationStatus"),
    2: .same(proto: "signedMessageStatus"),
    3: .same(proto: "whitelistOperationStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operationStatus) }()
      case 2: try {
        var v: VCSEC_SignedMessage_status?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .signedMessageStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .signedMessageStatus(v)
        }
      }()
      case 3: try {
        var v: VCSEC_WhitelistOperation_status?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistOperationStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistOperationStatus(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operationStatus != .operationstatusOk {
      try visitor.visitSingularEnumField(value: self.operationStatus, fieldNumber: 1)
    }
    switch self.subMessage {
    case .signedMessageStatus?: try {
      guard case .signedMessageStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .whitelistOperationStatus?: try {
      guard case .whitelistOperationStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_CommandStatus, rhs: VCSEC_CommandStatus) -> Bool {
    if lhs.operationStatus != rhs.operationStatus {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_UnsignedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsignedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "InformationRequest"),
    2: .same(proto: "RKEAction"),
    4: .same(proto: "closureMoveRequest"),
    16: .same(proto: "WhitelistOperation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_InformationRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .informationRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .informationRequest(v)
        }
      }()
      case 2: try {
        var v: VCSEC_RKEAction_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .rkeaction(v)
        }
      }()
      case 4: try {
        var v: VCSEC_ClosureMoveRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .closureMoveRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .closureMoveRequest(v)
        }
      }()
      case 16: try {
        var v: VCSEC_WhitelistOperation?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistOperation(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .informationRequest?: try {
      guard case .informationRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .rkeaction?: try {
      guard case .rkeaction(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .closureMoveRequest?: try {
      guard case .closureMoveRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .whitelistOperation?: try {
      guard case .whitelistOperation(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_UnsignedMessage, rhs: VCSEC_UnsignedMessage) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ClosureStatuses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosureStatuses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frontDriverDoor"),
    2: .same(proto: "frontPassengerDoor"),
    3: .same(proto: "rearDriverDoor"),
    4: .same(proto: "rearPassengerDoor"),
    5: .same(proto: "rearTrunk"),
    6: .same(proto: "frontTrunk"),
    7: .same(proto: "chargePort"),
    8: .same(proto: "tonneau"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.frontDriverDoor) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.frontPassengerDoor) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rearDriverDoor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rearPassengerDoor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.rearTrunk) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.frontTrunk) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.chargePort) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.tonneau) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frontDriverDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.frontDriverDoor, fieldNumber: 1)
    }
    if self.frontPassengerDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.frontPassengerDoor, fieldNumber: 2)
    }
    if self.rearDriverDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.rearDriverDoor, fieldNumber: 3)
    }
    if self.rearPassengerDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.rearPassengerDoor, fieldNumber: 4)
    }
    if self.rearTrunk != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.rearTrunk, fieldNumber: 5)
    }
    if self.frontTrunk != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.frontTrunk, fieldNumber: 6)
    }
    if self.chargePort != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.chargePort, fieldNumber: 7)
    }
    if self.tonneau != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.tonneau, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ClosureStatuses, rhs: VCSEC_ClosureStatuses) -> Bool {
    if lhs.frontDriverDoor != rhs.frontDriverDoor {return false}
    if lhs.frontPassengerDoor != rhs.frontPassengerDoor {return false}
    if lhs.rearDriverDoor != rhs.rearDriverDoor {return false}
    if lhs.rearPassengerDoor != rhs.rearPassengerDoor {return false}
    if lhs.rearTrunk != rhs.rearTrunk {return false}
    if lhs.frontTrunk != rhs.frontTrunk {return false}
    if lhs.chargePort != rhs.chargePort {return false}
    if lhs.tonneau != rhs.tonneau {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_DetailedClosureStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetailedClosureStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tonneauPercentOpen"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tonneauPercentOpen) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tonneauPercentOpen != 0 {
      try visitor.visitSingularUInt32Field(value: self.tonneauPercentOpen, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_DetailedClosureStatus, rhs: VCSEC_DetailedClosureStatus) -> Bool {
    if lhs.tonneauPercentOpen != rhs.tonneauPercentOpen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_VehicleStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "closureStatuses"),
    2: .same(proto: "vehicleLockState"),
    3: .same(proto: "vehicleSleepStatus"),
    4: .same(proto: "userPresence"),
    5: .same(proto: "detailedClosureStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._closureStatuses) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.vehicleLockState) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.vehicleSleepStatus) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.userPresence) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._detailedClosureStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._closureStatuses {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.vehicleLockState != .vehiclelockstateUnlocked {
      try visitor.visitSingularEnumField(value: self.vehicleLockState, fieldNumber: 2)
    }
    if self.vehicleSleepStatus != .vehicleSleepStatusUnknown {
      try visitor.visitSingularEnumField(value: self.vehicleSleepStatus, fieldNumber: 3)
    }
    if self.userPresence != .vehicleUserPresenceUnknown {
      try visitor.visitSingularEnumField(value: self.userPresence, fieldNumber: 4)
    }
    try { if let v = self._detailedClosureStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_VehicleStatus, rhs: VCSEC_VehicleStatus) -> Bool {
    if lhs._closureStatuses != rhs._closureStatuses {return false}
    if lhs.vehicleLockState != rhs.vehicleLockState {return false}
    if lhs.vehicleSleepStatus != rhs.vehicleSleepStatus {return false}
    if lhs.userPresence != rhs.userPresence {return false}
    if lhs._detailedClosureStatus != rhs._detailedClosureStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_FromVCSECMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromVCSECMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleStatus"),
    4: .same(proto: "commandStatus"),
    16: .same(proto: "whitelistInfo"),
    17: .same(proto: "whitelistEntryInfo"),
    46: .same(proto: "nominalError"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_VehicleStatus?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .vehicleStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .vehicleStatus(v)
        }
      }()
      case 4: try {
        var v: VCSEC_CommandStatus?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .commandStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .commandStatus(v)
        }
      }()
      case 16: try {
        var v: VCSEC_WhitelistInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistInfo(v)
        }
      }()
      case 17: try {
        var v: VCSEC_WhitelistEntryInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistEntryInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistEntryInfo(v)
        }
      }()
      case 46: try {
        var v: Errors_NominalError?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .nominalError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .nominalError(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .vehicleStatus?: try {
      guard case .vehicleStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .commandStatus?: try {
      guard case .commandStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .whitelistInfo?: try {
      guard case .whitelistInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .whitelistEntryInfo?: try {
      guard case .whitelistEntryInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .nominalError?: try {
      guard case .nominalError(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_FromVCSECMessage, rhs: VCSEC_FromVCSECMessage) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
